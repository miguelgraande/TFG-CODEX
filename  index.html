<!DOCTYPE html>
<html lang="en" data-theme="light">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>M.G.Derivados | Derivatives Platform (TFG)</title>
    <link
        href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">
    <!-- CDN libraries (fallback-safe) -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <!-- Cursor Tracking Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const root = document.documentElement;

            document.addEventListener('mousemove', (e) => {
                // Performance optimization: use requestAnimationFrame if logical, 
                // but direct updates are usually fine for simple variables 
                // on modern browsers.
                root.style.setProperty('--mouse-x', `${e.clientX}px`);
                root.style.setProperty('--mouse-y', `${e.clientY}px`);

                // Optional: normalized coordinates for other effects 
                // (0 to 1)
                const xPct = e.clientX / window.innerWidth;
                const yPct = e.clientY / window.innerHeight;
                root.style.setProperty('--mouse-x-pct', xPct);
                root.style.setProperty('--mouse-y-pct', yPct);
            });
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation"></script>
    <script>
      try {
        if (window.mermaid) {
          mermaid.initialize({
            startOnLoad: false,
            theme: 'base',
            themeVariables: {
              primaryColor: '#003380',
              primaryTextColor: '#fff',
              primaryBorderColor: '#003380',
              lineColor: '#003380',
              secondaryColor: '#f0f4f8'
            }
          });
        } else {
          console.warn('Mermaid no está disponible (no se pudo cargar desde CDN).');
        }
      } catch (e) {
        console.warn('Mermaid init falló:', e);
      }
    </script>
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        if (location.protocol === 'file:') {
          console.warn('Esta app debe servirse desde http://localhost para evitar bloqueos de librerías.');
          const warn = document.createElement('div');
          warn.className = 'local-warning';
          warn.textContent = 'Aviso: abre esta página vía http://localhost para que las librerías (Mermaid/MathJax) carguen sin bloqueos del navegador.';
          document.body.prepend(warn);
        }
        if (!window.MathJax) {
          console.warn('MathJax no está disponible (no se pudo cargar desde CDN).');
        }
      });
    </script>
    <style>
        /* ========== DESIGN TOKENS ========== */
        :root {
            /* Cursor Tracking */
            --mouse-x: 50vw;
            --mouse-y: 50vh;

            /* Core Palette - Deep Financial Tech */
            --primary: #003380;
            --primary-gradient: linear-gradient(135deg, #003380 0%, #0040a0 100%);
            --primary-foreground: #ffffff;

            /* Glassmorphism & Backgrounds */
            --background: #f8f9fc;
            --background-gradient: linear-gradient(to bottom right, #f8f9fc, #eef2f6);
            --surface: rgba(255, 255, 255, 0.7);
            --surface-hover: rgba(255, 255, 255, 0.9);
            --surface-border: rgba(255, 255, 255, 0.5);
            --glass-blur: blur(12px);

            /* Text Colors */
            --foreground: #0f172a;
            --muted: #f1f5f9;
            --muted-foreground: #64748b;
            --border: #e2e8f0;

            /* Interactive Accents */
            --accent-blue: #3b82f6;
            --accent-glow: 0 0 20px rgba(59, 130, 246, 0.15);

            /* Semantic Colors (Vibrant) */
            --success: #10b981;
            --success-bg: rgba(16, 185, 129, 0.1);
            --warning: #f59e0b;
            --warning-bg: rgba(245, 158, 11, 0.1);
            --danger: #ef4444;
            --danger-bg: rgba(239, 68, 68, 0.1);
            --info: #6366f1;

            /* Brand aliases */
            --M.G.Derivados-blue: #003380;
            --M.G.Derivados-blue-muted: rgba(0, 51, 128, 0.08);

            /* Typography */
            --font-display: "EB Garamond", serif;
            --font-sans: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            --font-mono: "JetBrains Mono", monospace;

            /* Modern Spacing */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 24px;
            --space-6: 32px;
            --space-8: 48px;

            /* Premium Radius */
            --radius-sm: 6px;
            --radius-md: 12px;
            --radius-lg: 16px;

            /* Elevated Shadows */
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.05), 0 4px 6px -2px rgba(0, 0, 0, 0.025);
            --shadow-float: 0 20px 25px -5px rgba(0, 0, 0, 0.05), 0 10px 10px -5px rgba(0, 0, 0, 0.02);
        }

        /* Dark Theme - "Terminal Mode" */
        [data-theme="dark"] {
            --background: #0f172a;
            --background-gradient: linear-gradient(to bottom right, #0f172a, #1e293b);
            --surface: rgba(30, 41, 59, 0.7);
            --surface-hover: rgba(30, 41, 59, 0.9);
            --surface-border: rgba(255, 255, 255, 0.1);
            --foreground: #f8fafc;
            --muted: #1e293b;
            --muted-foreground: #94a3b8;
            --border: #334155;
            --primary: #60a5fa;
            --primary-gradient: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
        }

        /* ========== ANIMATIONS ========== */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse-soft {
            0% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4);
            }

            70% {
                box-shadow: 0 0 0 6px rgba(59, 130, 246, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }

        /* ========== CURSOR EFFECTS ========== */
        .cursor-spotlight {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10001;
            /* Above mostly everything, but let clicks through */
            background: radial-gradient(600px circle at var(--mouse-x) var(--mouse-y),
                    rgba(59, 130, 246, 0.08),
                    transparent 40%);
            transition: background 0.1s ease;
            /* Slight smoothing */
            mix-blend-mode: screen;
            /* Nice lighting effect */
        }

        /* ========== BASE STYLES ========== */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-sans);
            background: var(--background);
            background-image: var(--background-gradient);
            background-attachment: fixed;
            /* Parallax feel */
            color: var(--foreground);
            font-size: 14px;
            font-weight: 400;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            overflow-x: hidden;
        }

        h1,
        h2,
        h3,
        h4,
        .font-display {
            font-family: var(--font-display);
            font-weight: 500;
            letter-spacing: -0.01em;
            color: var(--foreground);
        }

        .mono {
            font-family: var(--font-mono);
        }

        .numeric {
            font-family: var(--font-mono);
            font-variant-numeric: tabular-nums;
        }

        /* ========== HEADER ========== */
        .header {
            height: 64px;
            background: rgba(255, 255, 255, 0.85);
            /* Glass base */
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border-bottom: 1px solid var(--surface-border);
            display: flex;
            align-items: center;
            padding: 0 var(--space-6);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            box-shadow: var(--shadow-sm);
            transition: all 0.3s ease;
        }

        [data-theme="dark"] .header {
            background: rgba(15, 23, 42, 0.85);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .logo-mark {
            font-family: var(--font-display);
            font-size: 24px;
            font-weight: 500;
            color: var(--M.G.Derivados-blue);
            letter-spacing: -0.02em;
        }

        .logo-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 var(--space-4);
        }

        .logo-subtitle {
            font-size: 13px;
            font-weight: 500;
            color: var(--muted-foreground);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .nav {
            display: flex;
            gap: var(--space-1);
            margin-left: var(--space-8);
        }

        .nav-item {
            padding: var(--space-2) var(--space-4);
            font-size: 13px;
            font-weight: 500;
            color: var(--muted-foreground);
            cursor: pointer;
            border: none;
            background: transparent;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-radius: var(--radius-sm);
            position: relative;
        }

        .nav-item:hover {
            color: var(--foreground);
            background: var(--surface-hover);
        }

        .nav-item.active {
            color: var(--primary);
            background: rgba(59, 130, 246, 0.1);
        }

        /* Remove old border-bottom approach */
        .nav-item.active::after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 0;
            width: 100%;
            height: 2px;
            background: var(--primary);
            border-radius: 2px;
        }

        .nav-item:hover {
            color: var(--foreground);
        }

        .nav-item.active {
            color: var(--M.G.Derivados-blue);
            border-bottom: 2px solid var(--M.G.Derivados-blue);
        }

        .local-warning {
            background: rgba(255, 193, 7, 0.2);
            color: #7a5a00;
            border: 1px solid rgba(255, 193, 7, 0.5);
            padding: 10px 14px;
            font-size: 12px;
            font-weight: 600;
            font-family: var(--font-sans);
        }

        .spacer {
            flex: 1;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: var(--space-3);
        }

        .btn-icon {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border);
            background: var(--background);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.15s;
            color: var(--muted-foreground);
        }

        .btn-icon:hover {
            background: var(--secondary);
            border-color: var(--M.G.Derivados-blue);
            color: var(--M.G.Derivados-blue);
        }

        /* ========== LAYOUT ========== */
        .app {
            display: flex;
            min-height: 100vh;
            padding-top: 64px;
        }

        .sidebar {
            width: 280px;
            background: rgba(248, 250, 252, 0.8);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border-right: 1px solid var(--surface-border);
            position: fixed;
            top: 64px;
            bottom: 0;
            left: 0;
            overflow-y: auto;
            z-index: 90;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        [data-theme="dark"] .sidebar {
            background: rgba(30, 41, 59, 0.8);
        }

        .sidebar.hidden {
            display: none;
        }

        .sidebar-header {
            padding: var(--space-4) var(--space-5);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--muted-foreground);
        }

        .sidebar-content {
            padding: var(--space-3);
        }

        .main {
            flex: 1;
            margin-left: 280px;
            padding: var(--space-6);
            max-width: 1100px;
        }

        .main.full {
            margin-left: 0;
            max-width: 1280px;
            margin: 0 auto;
        }

        /* ========== TREE NAVIGATION ========== */
        .tree {
            font-size: 13px;
        }

        .tree ul {
            list-style: none;
            padding-left: var(--space-4);
        }

        .tree>ul {
            padding-left: 0;
        }

        .tree li {
            list-style: none;
        }

        .tree-node {
            padding: var(--space-2) var(--space-3);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: var(--space-2);
            color: var(--muted-foreground);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            margin-bottom: 2px;
            border-radius: var(--radius-sm);
            user-select: none;
        }

        .tree-node:hover {
            background: var(--surface-hover);
            color: var(--foreground);
            transform: translateX(4px);
        }

        .tree-node.selected {
            background: rgba(59, 130, 246, 0.1);
            color: var(--primary);
            font-weight: 600;
            box-shadow: var(--shadow-sm);
        }

        .tree-node .caret {
            width: 16px;
            font-size: 10px;
            color: var(--muted-foreground);
            transition: transform 0.2s ease;
        }

        .tree-node .caret.open {
            transform: rotate(90deg);
        }

        .tree-node .caret.none {
            visibility: hidden;
        }

        .tree-node .node-id {
            font-family: var(--font-mono);
            font-size: 10px;
            color: var(--muted-foreground);
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.05);
        }

        .node-label {
            background: transparent;
            border: none;
            text-align: left;
            color: inherit;
            cursor: pointer;
            flex: 1;
            font: inherit;
        }

        .node-label:focus {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        .tree-children {
            display: none;
        }

        .tree-children.open {
            display: block;
        }

        .tab-nav {
            display: flex;
            gap: 8px;
            margin: 8px 0;
        }

        .tab-btn {
            border: 1px solid var(--border);
            background: var(--surface);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            color: var(--foreground);
        }

        .tab-btn.active {
            background: var(--primary);
            color: var(--primary-foreground);
        }

        .tab-btn:focus {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        .tab-panel.hidden {
            display: none;
        }

        /* Market */
        .market-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            gap: 16px;
        }

        .market-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 16px;
            box-shadow: var(--shadow-sm);
        }

        .market-card h4 {
            margin: 0 0 8px 0;
            font-size: 15px;
        }

        .market-input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: var(--font-mono);
            margin-top: 4px;
        }

        .chart-wrap {
            position: relative;
            width: 100%;
            height: 280px;
        }

        .textarea-compact {
            width: 100%;
            min-height: 120px;
            font-family: var(--font-mono);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px;
        }

        .alert {
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 12px;
        }

        .alert-danger {
            background: var(--danger-bg);
            color: var(--danger);
        }

        .alert-warning {
            background: var(--warning-bg);
            color: var(--warning);
        }

        .inline-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .mini-label {
            font-size: 11px;
            color: var(--muted-foreground);
        }

        /* Classification bullets off */
        .tree ul {
            list-style: none;
            padding-left: var(--space-4);
        }

        /* Print */
        @media print {
            header, .sidebar, .nav, .nav-wrapper, .btn, .btn-icon, .tab-nav, .tab-btn, .cursor-spotlight, .workbench-page .toggle-group { display: none !important; }
            body { background: white; color: black; }
            .page, .main, .card, .panel, .panel-body { box-shadow: none !important; border: 1px solid #ddd !important; }
            .print-only { display: block !important; }
            .no-print { display: none !important; }
        }

        .print-only { display: none; }

        .page-transition {
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 200ms ease, transform 200ms ease;
        }

        .page-transition.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* ========== CARDS ========== */
        .card {
            background: var(--surface);
            backdrop-filter: var(--glass-blur);
            -webkit-backdrop-filter: var(--glass-blur);
            border: 1px solid var(--surface-border);
            padding: var(--space-6);
            margin-bottom: var(--space-6);
            box-shadow: var(--shadow-sm);
            border-radius: var(--radius-md);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: fadeIn 0.6s ease-out backwards;
            position: relative;
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary);
        }

        /* Subtle gradient overlay on hover */
        .card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .card:hover::after {
            opacity: 1;
        }

        .card-header {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--muted-foreground);
            margin-bottom: var(--space-5);
            padding-bottom: var(--space-4);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            /* Better layout */
            gap: var(--space-2);
        }

        .card-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-4);
        }

        /* ========== BADGES ========== */
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 10px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .badge-success {
            background: var(--success-muted);
            color: var(--success);
        }

        .badge-warning {
            background: var(--warning-muted);
            color: var(--warning);
        }

        .badge-danger {
            background: var(--danger-muted);
            color: var(--danger);
        }

        .badge-neutral {
            background: var(--muted);
            color: var(--muted-foreground);
        }

        .badge-info {
            background: var(--info-muted);
            color: var(--info);
        }

        .badge-primary {
            background: rgba(0, 51, 128, 0.1);
            color: var(--M.G.Derivados-blue);
        }

        /* ========== BUTTONS ========== */
        /* ========== BUTTONS ========== */
        .btn {
            padding: var(--space-3) var(--space-5);
            font-size: 13px;
            font-weight: 600;
            font-family: var(--font-sans);
            cursor: pointer;
            border: 1px solid var(--border);
            background: var(--surface);
            color: var(--foreground);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-radius: var(--radius-sm);
            box-shadow: var(--shadow-sm);
        }

        .btn:hover {
            background: var(--surface-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--primary);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: var(--primary-gradient);
            border: none;
            color: #fff;
            box-shadow: 0 4px 12px rgba(0, 51, 128, 0.2);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #0040a0 0%, #0050c0 100%);
            box-shadow: 0 6px 16px rgba(0, 51, 128, 0.3);
            color: #fff;
        }

        .btn-sm {
            padding: var(--space-2) var(--space-3);
            font-size: 11px;
        }

        .btn-ghost {
            background: transparent;
            border-color: transparent;
            box-shadow: none;
        }

        .btn-ghost:hover {
            background: rgba(0, 0, 0, 0.05);
            transform: none;
            box-shadow: none;
        }

        /* ========== FORMS ========== */
        .form-group {
            margin-bottom: var(--space-4);
        }

        .form-label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: var(--muted-foreground);
            margin-bottom: var(--space-2);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .form-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: var(--space-3);
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            font-size: 13px;
            color: var(--foreground);
            font-family: var(--font-mono);
            transition: all 0.2s ease;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            background: #fff;
        }

        .form-input.error {
            border-color: var(--danger);
        }

        .form-unit {
            position: absolute;
            right: var(--space-3);
            color: var(--muted-foreground);
            font-size: 11px;
            pointer-events: none;
        }

        .params-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: var(--space-3);
        }

        /* ========== TABLES ========== */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .data-table th,
        .data-table td {
            padding: var(--space-3);
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .data-table th {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--muted-foreground);
            background: rgba(0, 0, 0, 0.02);
            border-bottom: 2px solid var(--border);
        }

        .data-table tbody tr:hover {
            background: var(--muted);
        }

        .data-table td.numeric {
            font-family: var(--font-mono);
            text-align: right;
        }

        /* ========== KPIs ========== */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--space-4);
            margin-bottom: var(--space-6);
        }

        .kpi {
            background: var(--surface);
            backdrop-filter: var(--glass-blur);
            border: 1px solid var(--surface-border);
            padding: var(--space-5);
            text-align: center;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .kpi:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary);
        }

        .kpi-value {
            font-family: var(--font-display);
            font-size: 36px;
            font-weight: 500;
            color: var(--M.G.Derivados-blue);
            margin-bottom: var(--space-1);
        }

        .kpi-label {
            font-size: 11px;
            color: var(--muted-foreground);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .kpi-success .kpi-value {
            color: var(--success);
        }

        .kpi-warning .kpi-value {
            color: var(--warning);
        }

        .kpi-danger .kpi-value {
            color: var(--danger);
        }

        /* ========== GREEKS GRID ========== */
        .greeks-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: var(--space-3);
        }

        .greek {
            background: var(--surface);
            border: 1px solid var(--surface-border);
            border-radius: var(--radius-sm);
            padding: var(--space-4);
            text-align: center;
            transition: all 0.2s ease;
        }

        .greek:hover {
            border-color: var(--primary);
            background: var(--surface-hover);
            transform: translateY(-2px);
        }

        .greek-symbol {
            font-size: 18px;
            color: var(--M.G.Derivados-blue);
            margin-bottom: var(--space-1);
        }

        .greek-value {
            font-size: 16px;
            font-weight: 600;
            font-family: var(--font-mono);
        }

        .greek-label {
            font-size: 9px;
            color: var(--muted-foreground);
            text-transform: uppercase;
            margin-top: var(--space-1);
        }

        /* ========== RESULTS ========== */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: var(--space-3);
            margin-bottom: var(--space-5);
        }

        .result-card {
            background: var(--surface);
            border: 1px solid var(--surface-border);
            border-radius: var(--radius-sm);
            padding: var(--space-4);
            text-align: center;
            transition: all 0.2s ease;
        }

        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        .result-card.primary {
            background: var(--primary-gradient);
            border: none;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 51, 128, 0.2);
        }

        .result-card.primary .result-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .result-card.primary .result-value {
            color: #fff;
        }

        .result-label {
            font-size: 10px;
            color: var(--muted-foreground);
            text-transform: uppercase;
            margin-bottom: var(--space-1);
        }

        .result-value {
            font-size: 16px;
            font-weight: 600;
            font-family: var(--font-mono);
        }

        /* ========== CHARTS ========== */
        /* ========== CHARTS ========== */
        .chart-container {
            background: var(--surface);
            backdrop-filter: var(--glass-blur);
            border: 1px solid var(--surface-border);
            border-radius: var(--radius-md);
            padding: var(--space-4);
            margin-bottom: var(--space-3);
            box-shadow: var(--shadow-sm);
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            gap: var(--space-5);
            font-size: 11px;
            color: var(--muted-foreground);
            margin-top: var(--space-3);
            background: rgba(0, 0, 0, 0.02);
            padding: var(--space-2);
            border-radius: var(--radius-sm);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .legend-line {
            width: 16px;
            height: 2px;
        }

        /* ========== ANALYTICS LAYOUT ========== */
        .analytics-layout {
            display: grid;
            grid-template-columns: 260px 1fr 200px;
            gap: var(--space-5);
            min-height: calc(100vh - 128px);
        }

        .analytics-left,
        .analytics-right {}

        .analytics-center {
            min-width: 0;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
            background: rgba(255, 255, 255, 0.5);
            border: 2px dashed var(--border);
            border-radius: var(--radius-md);
            backdrop-filter: blur(4px);
            transition: all 0.3s ease;
        }

        .empty-state:hover {
            background: rgba(255, 255, 255, 0.8);
            border-color: var(--primary);
        }

        .empty-icon {
            font-size: 48px;
            margin-bottom: var(--space-4);
            opacity: 0.4;
        }

        .empty-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: var(--space-2);
        }

        .empty-text {
            color: var(--muted-foreground);
        }

        /* ========== PAGE HEADER ========== */
        .page-header {
            margin-bottom: var(--space-6);
        }

        .page-breadcrumb {
            font-size: 11px;
            color: var(--muted-foreground);
            margin-bottom: var(--space-2);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .page-title {
            font-family: var(--font-display);
            font-size: 32px;
            font-weight: 400;
            margin-bottom: var(--space-1);
        }

        .page-subtitle {
            font-size: 14px;
            color: var(--muted-foreground);
        }

        .page-badges {
            display: flex;
            gap: var(--space-2);
            margin-top: var(--space-3);
        }

        /* ========== WORKBENCH ========== */
        .workbench-container {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            grid-template-rows: auto 1fr auto;
            height: calc(100vh - 64px);
            gap: 16px;
            padding: 16px;
        }

        .wb-header {
            grid-column: 1 / -1;
            background: var(--surface);
            backdrop-filter: var(--glass-blur);
            padding: var(--space-4) var(--space-5);
            display: flex;
            align-items: center;
            gap: var(--space-5);
            border-bottom: 1px solid var(--surface-border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
        }

        .wb-panel-left,
        .wb-panel-right {
            background: var(--surface);
            backdrop-filter: var(--glass-blur);
            padding: var(--space-4);
            overflow-y: auto;
            border-radius: var(--radius-md);
            border: 1px solid var(--surface-border);
            box-shadow: var(--shadow-sm);
        }

        .wb-panel-center {
            background: transparent;
            /* Let background gradient show */
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .wb-footer {
            grid-column: 1 / -1;
            background: var(--surface);
            border-top: 1px solid var(--surface-border);
            backdrop-filter: var(--glass-blur);
            padding: var(--space-2);
            border-radius: var(--radius-md) var(--radius-md) 0 0;
        }

        .toggle-group {
            display: flex;
            background: rgba(0, 0, 0, 0.05);
            padding: 4px;
            gap: 4px;
            border-radius: var(--radius-sm);
        }

        .toggle-btn {
            padding: var(--space-2) var(--space-4);
            font-size: 13px;
            font-weight: 600;
            color: var(--muted-foreground);
            cursor: pointer;
            border: none;
            background: transparent;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: var(--radius-sm);
            flex: 1;
            text-align: center;
        }

        .toggle-btn:hover {
            color: var(--foreground);
            background: rgba(255, 255, 255, 0.5);
        }

        .toggle-btn.active {
            background: #fff;
            color: var(--primary);
            box-shadow: var(--shadow-sm);
            transform: scale(1.02);
        }

        .toggle-btn.call.active {
            background: var(--success);
            color: white;
            box-shadow: 0 4px 12px var(--success-bg);
        }

        .toggle-btn.put.active {
            background: var(--danger);
            color: white;
            box-shadow: 0 4px 12px var(--danger-bg);
        }

        .wb-section {
            margin-bottom: var(--space-5);
        }

        .wb-section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--muted-foreground);
            margin-bottom: var(--space-3);
            display: flex;
            align-items: center;
            gap: var(--space-2);
        }

        .wb-section-title::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border);
        }

        .param-row {
            margin-bottom: var(--space-4);
        }

        .param-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-2);
        }

        .param-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--muted-foreground);
        }

        .param-value {
            font-family: var(--font-mono);
            font-size: 13px;
            font-weight: 600;
        }

        .param-input {
            width: 100%;
            padding: var(--space-2) var(--space-3);
            background: var(--background);
            border: 1px solid var(--border);
            font-family: var(--font-mono);
            font-size: 13px;
            color: var(--foreground);
            text-align: right;
        }

        .param-input:focus {
            outline: none;
            border-color: var(--M.G.Derivados-blue);
        }

        .param-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(0, 0, 0, 0.1);
            margin-top: var(--space-3);
            cursor: pointer;
            border-radius: 3px;
        }

        .param-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border: 2px solid #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: transform 0.2s;
        }

        .param-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .wb-chart-area {
            flex: 1;
            padding: var(--space-5);
            display: flex;
            flex-direction: column;
        }

        .wb-chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-3);
        }

        .wb-chart-title {
            font-size: 14px;
            font-weight: 600;
        }

        .wb-chart-subtitle {
            font-size: 11px;
            color: var(--muted-foreground);
        }

        .wb-chart-container {
            flex: 1;
            background: var(--secondary);
            border: 1px solid var(--border);
            position: relative;
            min-height: 300px;
            overflow: hidden;
        }

        .wb-chart-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .greeks-strip {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            background: transparent;
            padding: 0;
            margin-bottom: var(--space-4);
        }

        .greek-tile {
            background: var(--surface);
            backdrop-filter: var(--glass-blur);
            padding: var(--space-4);
            text-align: center;
            border: 1px solid var(--surface-border);
            border-radius: var(--radius-sm);
            transition: all 0.2s ease;
        }

        .greek-tile:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        .greek-tile .greek-symbol {
            font-size: 14px;
            color: var(--primary);
            margin-bottom: 2px;
        }

        .greek-tile .greek-value {
            font-family: var(--font-mono);
            font-size: 16px;
            font-weight: 600;
        }

        .greek-tile .greek-label {
            font-size: 9px;
            color: var(--muted-foreground);
            text-transform: uppercase;
        }

        .meta-card {
            background: var(--surface);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--surface-border);
            padding: var(--space-4);
            margin-bottom: var(--space-3);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
        }

        .meta-row {
            display: flex;
            justify-content: space-between;
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--border);
            font-size: 12px;
        }

        .meta-row:last-child {
            border-bottom: none;
        }

        .meta-label {
            color: var(--muted-foreground);
        }

        .meta-value {
            font-family: var(--font-mono);
            font-weight: 500;
        }

        .meta-value.price {
            font-size: 24px;
            color: var(--M.G.Derivados-blue);
        }

        /* ========== DIAGNOSTICS ========== */
        .diag-panel {
            background: var(--secondary);
            border: 1px solid var(--border);
            margin-bottom: var(--space-5);
        }

        .diag-header {
            padding: var(--space-4);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }

        .diag-header:hover {
            background: var(--muted);
        }

        .diag-content {
            padding: var(--space-4);
        }

        .diag-content.hidden {
            display: none;
        }

        .test-result {
            display: flex;
            align-items: center;
            padding: var(--space-2) 0;
            border-bottom: 1px solid var(--border);
            font-size: 12px;
        }

        .test-result:last-child {
            border-bottom: none;
        }

        .test-name {
            flex: 1;
        }

        .test-expected,
        .test-actual {
            width: 100px;
            font-family: var(--font-mono);
            text-align: right;
        }

        .test-status {
            width: 80px;
            text-align: center;
            font-weight: 600;
        }

        .test-pass {
            color: var(--success);
        }

        .test-fail {
            color: var(--danger);
        }

        /* ========== STATUS INDICATORS ========== */
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-dot.complete {
            background: var(--success);
        }

        .status-dot.partial {
            background: var(--warning);
        }

        .status-dot.missing {
            background: var(--danger);
        }

        /* ========== FLUID NAV ========== */
        .nav-wrapper {
            position: relative;
            margin-left: var(--space-8);
        }

        .nav {
            position: relative;
            display: flex;
            gap: var(--space-2);
            z-index: 20;
            margin-left: 0;
            /* Reset since wrapper handles it */
        }

        .nav-item {
            padding: var(--space-2) var(--space-4);
            font-size: 13px;
            font-weight: 500;
            color: var(--muted-foreground);
            cursor: pointer;
            border: none;
            background: transparent;
            transition: color 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-radius: var(--radius-sm);
            position: relative;
        }

        .nav-item:hover {
            color: var(--foreground);
        }

        .nav-item.active {
            color: var(--primary);
            /* Remove old border-bottom */
            border-bottom: none;
        }

        .nav-item.active::after {
            display: none;
        }

        /* Fluid Background for Nav Items */
        .nav-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: var(--surface-hover);
            border-radius: var(--radius-sm);
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: -1;
        }

        /* Dropdown Container */
        .dropdown-wrapper {
            position: absolute;
            top: 100%;
            left: 0;
            padding-top: 12px;
            /* Offset */
            perspective: 2000px;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .dropdown-wrapper.visible {
            opacity: 1;
            visibility: visible;
        }

        /* The morphing box */
        .dropdown-bg {
            position: absolute;
            top: 12px;
            left: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-float);
            transform-origin: 0 0;
            transition: width 0.3s ease, height 0.3s ease, transform 0.3s ease;
            overflow: hidden;
            width: 300px;
            /* Base width */
            height: 200px;
            /* Base height */
        }

        [data-theme="dark"] .dropdown-bg {
            background: rgba(30, 41, 59, 0.95);
            border-color: var(--border);
        }

        .dropdown-arrow {
            position: absolute;
            top: 6px;
            /* -6px from bg top */
            left: 0;
            width: 12px;
            height: 12px;
            background: inherit;
            border-top: 1px solid var(--border);
            border-left: 1px solid var(--border);
            transform: rotate(45deg);
            background: rgba(255, 255, 255, 0.95);
            /* Matches bg */
            z-index: 110;
            transition: transform 0.3s ease;
            pointer-events: none;
        }

        [data-theme="dark"] .dropdown-arrow {
            background: rgba(30, 41, 59, 0.95);
        }

        /* Content Container */
        .dropdown-content-container {
            position: relative;
            z-index: 120;
            padding-top: 12px;
            /* Access tunnel */
        }

        .dropdown-section {
            position: absolute;
            top: 12px;
            /* Match bg top */
            left: 0;
            width: max-content;
            padding: var(--space-5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .dropdown-section.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Content Styling */
        .dd-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--muted-foreground);
            margin-bottom: var(--space-4);
            padding-bottom: var(--space-2);
            border-bottom: 1px solid var(--border);
        }

        .dd-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-4);
            min-width: 300px;
        }

        .dd-item {
            display: flex;
            align-items: center;
            gap: var(--space-3);
            text-decoration: none;
            color: var(--foreground);
            padding: var(--space-2);
            border-radius: var(--radius-sm);
            transition: 0.2s;
        }

        .dd-item:hover {
            background: var(--surface-hover);
        }

        /* Icon reset */
        .dd-item .dd-icon {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--muted);
            border-radius: 4px;
            font-size: 14px;
        }

        .dd-text {
            display: flex;
            flex-direction: column;
        }

        .dd-label {
            font-size: 13px;
            font-weight: 500;
        }

        .dd-desc {
            font-size: 11px;
            color: var(--muted-foreground);
        }

        /* ========== HIDING PAGES ========== */
        .page {
            display: none;
        }

        .page.active {
            display: block;
        }

        .workbench-page {
            display: none;
            position: fixed;
            top: 64px;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50;
        }

        .workbench-page.active {
            display: block;
        }

        /* ========== FLUID TRANSITIONS ========== */
        .main.page {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            display: none;
        }

        .main.page.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .main.page.fade-out {
            opacity: 0;
            transform: translateY(-10px);
        }

        /* ========== COMMAND CENTER (CMD+K) ========== */
        #command-palette {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(4px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }

        #command-palette.open {
            opacity: 1;
            pointer-events: all;
        }

        .cmd-modal {
            width: 600px;
            max-width: 90vw;
            background: var(--surface);
            border: 1px solid var(--surface-border);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            overflow: hidden;
            transform: scale(0.95);
            transition: transform 0.2s;
            display: flex;
            flex-direction: column;
        }

        #command-palette.open .cmd-modal {
            transform: scale(1);
        }

        .cmd-input-wrapper {
            display: flex;
            align-items: center;
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .cmd-icon {
            font-size: 20px;
            color: var(--muted-foreground);
            margin-right: 12px;
        }

        .cmd-input {
            flex: 1;
            background: transparent;
            border: none;
            font-size: 18px;
            color: var(--foreground);
            outline: none;
            font-family: var(--font-sans);
        }

        .cmd-list {
            padding: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        .cmd-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            border-radius: 6px;
            cursor: pointer;
            color: var(--muted-foreground);
            transition: all 0.1s;
        }

        .cmd-item:hover,
        .cmd-item.selected {
            background: var(--primary);
            color: white;
        }

        .cmd-shortcut {
            font-size: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: var(--font-mono);
        }

        /* ========== MARKET SONAR (RADAR) ========== */
        .sonar-widget {
            position: relative;
            height: 300px;
            background: radial-gradient(circle at center, rgba(0, 51, 128, 0.1) 0%, transparent 70%);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            width: 100%;
            /* Fix visibility */
        }

        .sonar-ring {
            position: absolute;
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 50%;
            animation: pulse-ring 3s cubic-bezier(0.215, 0.61, 0.355, 1) infinite;
        }

        .sonar-ring:nth-child(1) {
            width: 50px;
            height: 50px;
            animation-delay: 0s;
        }

        .sonar-ring:nth-child(2) {
            width: 50px;
            height: 50px;
            animation-delay: 1s;
        }

        .sonar-ring:nth-child(3) {
            width: 50px;
            height: 50px;
            animation-delay: 2s;
        }

        @keyframes pulse-ring {
            0% {
                transform: scale(1);
                opacity: 0.6;
            }

            100% {
                transform: scale(6);
                opacity: 0;
            }
        }

        .sonar-sweep {
            position: absolute;
            width: 150px;
            height: 150px;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(59, 130, 246, 0.4) 60deg, transparent 61deg);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform-origin: 0 0;
            /* Corner pivot fix needed or adjust positioning */
            /* Better pivot approach for sweep: */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: auto;
            width: 300px;
            height: 300px;
            background: conic-gradient(from 0deg, transparent 0deg, transparent 20deg, rgba(59, 130, 246, 0.3) 60deg, rgba(59, 130, 246, 0.8) 65deg, transparent 66deg);
            animation: sweep 4s linear infinite;
            pointer-events: none;
        }

        @keyframes sweep {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .sonar-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ef4444;
            border-radius: 50%;
            box-shadow: 0 0 10px #ef4444;
            animation: flash 2s infinite;
        }

        @keyframes flash {

            0%,
            100% {
                opacity: 0;
            }

            50% {
                opacity: 1;
            }
        }

        /* ========== 3D VOLATILITY SURFACE ========== */
        .vol-surface-container {
            position: relative;
            width: 100%;
            height: 350px;
            background: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.2));
            border-radius: 8px;
            overflow: hidden;
        }

        canvas#vol-surface {
            width: 100%;
            height: 100%;
        }

        /* LANDING OVERLAY STYLES */
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            transition: opacity 1s ease-out, visibility 1s;
        }

        #landing-overlay.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .landing-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #sparkles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .grad-beam {
            position: absolute;
            top: 0;
            width: 40%;
            height: 1px;
            filter: blur(8px);
            opacity: 0.6;
        }

        .grad-beam.left {
            left: 10%;
            background: linear-gradient(90deg, transparent, #6366f1, transparent);
            /* Indigo */
            box-shadow: 0 0 50px 2px #6366f1;
        }

        .grad-beam.right {
            right: 10%;
            background: linear-gradient(90deg, transparent, #0ea5e9, transparent);
            /* Sky */
            box-shadow: 0 0 50px 2px #0ea5e9;
        }

        .landing-content {
            position: relative;
            z-index: 10;
            text-align: center;
            cursor: pointer;
        }

        .landing-title {
            font-family: 'EB Garamond', serif;
            font-size: 5rem;
            font-weight: 700;
            color: white;
            background: linear-gradient(to bottom, #ffffff, #94a3b8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeUp 1.2s ease-out forwards 0.5s;
            letter-spacing: -0.02em;
        }

        @keyframes fadeUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .landing-marquee {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: linear-gradient(to top, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0));
            display: flex;
            align-items: center;
            z-index: 10;
            overflow: hidden;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .marquee-track {
            display: flex;
            align-items: center;
            white-space: nowrap;
            animation: marqueeInfo 30s linear infinite;
        }

        .marquee-track span {
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin: 0 20px;
        }

        .marquee-track span.sep {
            color: rgba(255, 255, 255, 0.2);
        }

        @keyframes marqueeInfo {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(-50%);
            }
        }

        /* Radial mask matching React component idea */
        .radial-mask {
            position: absolute;
            inset: 0;
            background: black;
            mask-image: radial-gradient(circle at center, transparent 30%, black 100%);
            -webkit-mask-image: radial-gradient(circle at center, transparent 30%, black 100%);
            z-index: 2;
            pointer-events: none;
        }
    </style>
    <style>
        /* ========== ANALYTICS MODULE STYLES (MIGRATED) ========== */
        .analytics-grid {
            display: grid;
            grid-template-columns: 280px 1fr 260px;
            gap: 24px;
        }

        @media (max-width: 1200px) {
            .analytics-grid {
                grid-template-columns: 1fr;
            }
        }

        .params-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: var(--muted-foreground);
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 8px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 13px;
            color: var(--foreground);
            font-family: var(--font-mono);
            transition: all 0.2s;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: var(--primary);
        }

        .form-input-wrapper {
            position: relative;
            display: flex;
            align-items: center;
        }

        .form-unit {
            position: absolute;
            right: 12px;
            color: var(--muted-foreground);
            font-size: 10px;
            pointer-events: none;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 12px;
            margin-top: 16px;
        }

        .result-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }

        .result-card.primary {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.2);
        }

        .result-label {
            font-size: 10px;
            color: var(--muted-foreground);
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .result-value {
            font-size: 16px;
            font-weight: 600;
            font-family: var(--font-mono);
            color: var(--foreground);
        }

        .result-card.primary .result-value {
            color: var(--primary);
        }

        .greeks-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            margin-top: 12px;
        }

        .greek {
            background: var(--surface);
            border: 1px solid var(--border);
            padding: 8px;
            text-align: center;
            border-radius: 4px;
        }

        .greek-symbol {
            color: var(--primary);
            font-size: 16px;
            margin-bottom: 2px;
        }

        .greek-value {
            font-size: 12px;
            font-family: var(--font-mono);
        }

        .greek-label {
            font-size: 9px;
            color: var(--muted-foreground);
            text-transform: uppercase;
        }

        /* Model Card Styles */
        .model-card {
            background: rgba(59, 130, 246, 0.05);
            border: 1px solid rgba(59, 130, 246, 0.1);
        }

        .model-formula {
            background: var(--surface);
            padding: 12px;
            border-radius: 4px;
            font-family: var(--font-mono);
            font-size: 13px;
            margin: 12px 0;
            overflow-x: auto;
            border: 1px solid var(--border);
        }

        .model-assumptions li {
            margin-bottom: 4px;
            font-size: 12px;
            color: var(--muted-foreground);
        }
    </style>
</head>

<body>
    <!-- Cursor Spotlight Overlay -->
    <div class="cursor-spotlight"></div>
    <!-- SPLASH SCREEN OVERLAY -->
    <div id="landing-overlay">
        <div class="landing-bg">
            <canvas id="sparkles-canvas"></canvas>
            <div class="landing-gradients">
                <div class="grad-beam left"></div>
                <!-- 2px beam style -->
                <div
                    style="position:absolute; top:0; left:10%; width:40%; height:2px; background:linear-gradient(90deg,transparent,#6366f1,transparent); opacity:0.4;">
                </div>
                <div class="grad-beam right"></div>
                <div
                    style="position:absolute; top:0; right:10%; width:40%; height:2px; background:linear-gradient(90deg,transparent,#0ea5e9,transparent); opacity:0.4;">
                </div>
            </div>
            <div class="radial-mask"></div>
        </div>
        <div class="landing-content">
            <h1 class="landing-title">¿Empezamos?</h1>
        </div>
        <div class="landing-marquee">
            <div class="marquee-track">
                <!-- Repeated content for infinite scroll -->
                <span>M.G.Derivados</span> <span class="sep">&bull;</span>
                <span>BlackRock</span> <span class="sep">&bull;</span>
                <span>Vanguard</span> <span class="sep">&bull;</span>
                <span>J.P. Morgan</span> <span class="sep">&bull;</span>
                <span>Goldman Sachs</span> <span class="sep">&bull;</span>
                <span>Morgan Stanley</span> <span class="sep">&bull;</span>
                <span>Credit Suisse</span> <span class="sep">&bull;</span>
                <span>Two Sigma</span> <span class="sep">&bull;</span>
                <span>Bridgewater</span> <span class="sep">&bull;</span>
                <span>D.E. Shaw</span> <span class="sep">&bull;</span>
                <!-- Duplicate -->
                <span>M.G.Derivados</span> <span class="sep">&bull;</span>
                <span>BlackRock</span> <span class="sep">&bull;</span>
                <span>Vanguard</span> <span class="sep">&bull;</span>
                <span>J.P. Morgan</span> <span class="sep">&bull;</span>
                <span>Goldman Sachs</span> <span class="sep">&bull;</span>
                <span>Morgan Stanley</span> <span class="sep">&bull;</span>
                <span>Credit Suisse</span> <span class="sep">&bull;</span>
                <span>Two Sigma</span> <span class="sep">&bull;</span>
                <span>Bridgewater</span> <span class="sep">&bull;</span>
                <span>D.E. Shaw</span> <span class="sep">&bull;</span>
            </div>
        </div>
    </div>
    <!-- COMMAND CENTER OVERLAY -->
    <div id="command-palette">
        <div class="cmd-modal">
            <div class="cmd-input-wrapper">
                <span class="cmd-icon">🔍</span>
                <input type="text" class="cmd-input" id="cmdInput" placeholder="Type a command or search...">
                <span class="cmd-shortcut">ESC</span>
            </div>
            <div class="cmd-list" id="cmdList">
                <!-- Items populated by JS -->
            </div>
        </div>
    </div>



    <!-- Header -->
    <header class="header">
        <div class="logo">
            <span class="logo-mark">DERIVADOS</span>
            <div class="logo-divider"></div>
            <span class="logo-subtitle">PLATAFORMA INTERACTIVA</span>
        </div>
        <div class="nav-wrapper">
            <nav class="nav">
                <div class="nav-backdrop" id="navBackdrop"></div>
                <button class="nav-item active" data-page="taxonomy" data-target="dd-taxonomy">Taxonomía</button>
                <button class="nav-item" data-page="market" data-target="dd-market">Mercado</button>
                <button class="nav-item" data-page="analytics" data-target="dd-analytics">Análisis</button>
                <button class="nav-item" data-page="workbench" data-target="dd-workbench">Simulador</button>
            </nav>

            <div class="dropdown-wrapper" id="dropdownWrapper">
                <div class="dropdown-bg" id="dropdownBg"></div>
                <div class="dropdown-arrow" id="dropdownArrow"></div>

                <div class="dropdown-content-container">
                    <!-- TAXONOMY -->
                    <div class="dropdown-section" id="dd-taxonomy">
                        <div class="dd-title">Instrumentos Financieros</div>
                        <div class="dd-grid" style="min-width: 380px;">
                            <a href="#" class="dd-item" onclick="app.navigate('taxonomy'); return false;">
                                <div class="dd-icon">📈</div>
                                <div class="dd-text">
                                    <span class="dd-label">Derivados Lineales</span>
                                    <span class="dd-desc">Forwards, Futuros, Swaps</span>
                                </div>
                            </a>
                            <a href="#" class="dd-item" onclick="app.navigate('taxonomy'); return false;">
                                <div class="dd-icon">⚡</div>
                                <div class="dd-text">
                                    <span class="dd-label">Opciones (No Lineales)</span>
                                    <span class="dd-desc">Vanilla, Exóticas, Griegas</span>
                                </div>
                            </a>
                            <div class="dd-item">
                                <div class="dd-icon">🏗️</div>
                                <div class="dd-text">
                                    <span class="dd-label">Estructurados</span>
                                    <span class="dd-desc">Notas, Autocallables, Range Accruals</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ANALYTICS -->
                    <div class="dropdown-section" id="dd-analytics">
                        <div class="dd-title">Análisis de Mercado</div>
                        <div class="dd-grid">
                            <div class="dd-item" onclick="app.navigate('analytics');">
                                <div class="dd-icon">📊</div>
                                <div class="dd-text">
                                    <span class="dd-label">Curvas de Mercado</span>
                                    <span class="dd-desc">Tipos de Interés, Volatilidad</span>
                                </div>
                            </div>
                            <div class="dd-item" onclick="app.navigate('analytics');">
                                <div class="dd-icon">🧮</div>
                                <div class="dd-text">
                                    <span class="dd-label">Sensibilidad (Griegas)</span>
                                    <span class="dd-desc">Delta, Gamma, Vega, Theta</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- WORKBENCH -->
                    <div class="dropdown-section" id="dd-workbench">
                        <div class="dd-title">Motor de Valoración</div>
                        <div class="dd-grid" style="grid-template-columns: 1fr; min-width:280px;">
                            <div class="dd-item" onclick="app.navigate('workbench');">
                                <div class="dd-icon">🔧</div>
                                <div class="dd-text">
                                    <span class="dd-label">Black-Scholes-Merton</span>
                                    <span class="dd-desc">Calculadora interactiva de precios</span>
                                </div>
                            </div>
                            <div class="dd-item" style="opacity:0.6;">
                                <div class="dd-icon">🎲</div>
                                <div class="dd-text">
                                    <span class="dd-label">Simulación Monte Carlo</span>
                                    <span class="dd-desc">Próximamente</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="spacer"></div>
        <div class="header-actions">
            <button class="btn-icon" id="themeToggle" title="Cambiar tema">☀️</button>
        </div>
    </header>

    <div class="app">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span class="sidebar-title">Clasificación</span>
                <button class="btn btn-ghost btn-sm" id="collapseBtn">−</button>
            </div>
            <div class="sidebar-content" id="sidebarContent"></div>
        </aside>

        <!-- Main Content - Taxonomy Page -->
        <main class="main page active" id="page-taxonomy"></main>

        <!-- Main Content - Analytics Page -->
        <!-- Main Content - Market Page (New) -->
        <main class="main full page" id="page-market">
            <div id="market-root"></div>
        </main>

        <!-- Main Content - Analytics Page -->
        <main class="main full page" id="page-analytics">
            <h2 class="font-display" style="font-size:24px; margin-bottom: 24px;">Análisis de Cartera</h2>
            <div
                style="padding: 40px; text-align: center; color: var(--muted-foreground); border: 2px dashed var(--border); border-radius: 12px;">
                <div style="font-size: 48px; margin-bottom: 16px;">📊</div>
                <h3>Herramientas de Análisis</h3>
                <p>Seleccione una herramienta del menú superior para comenzar el análisis detallado de riesgos y
                    sensibilidades.</p>
            </div>
        </main>

        <!-- Audit Page -->
        <main class="main full page" id="page-audit"></main>
    </div>

    <!-- Workbench Page (separate layout) -->
    <div class="workbench-page" id="page-workbench">
        <div class="workbench-container">
            <header class="wb-header">
                <div class="toggle-group" id="typeToggle">
                    <button class="toggle-btn call active" data-type="call">Call</button>
                    <button class="toggle-btn put" data-type="put">Put</button>
                </div>
                <div class="toggle-group" id="posToggle">
                    <button class="toggle-btn active" data-pos="long">Long</button>
                    <button class="toggle-btn" data-pos="short">Short</button>
                </div>
                <div class="spacer"></div>
                <span class="badge badge-primary">BSM Engine</span>
                <span class="badge badge-success">Live</span>
            </header>

            <aside class="wb-panel-left">
                <div class="wb-section">
                    <div class="wb-section-title">Market Data</div>
                    <div class="param-row">
                        <div class="param-header">
                            <span class="param-label">Spot Price (S)</span>
                            <span class="param-value" id="wbSpotDisplay">100.00</span>
                        </div>
                        <input type="number" class="param-input" id="wbSpotInput" value="100" step="0.5" min="1"
                            max="10000">
                        <input type="range" class="param-slider" id="wbSpotSlider" min="50" max="200" value="100"
                            step="0.5">
                    </div>
                    <div class="param-row">
                        <div class="param-header">
                            <span class="param-label">Strike (K)</span>
                            <span class="param-value" id="wbStrikeDisplay">105.00</span>
                        </div>
                        <input type="number" class="param-input" id="wbStrikeInput" value="105" step="0.5" min="1"
                            max="10000">
                        <input type="range" class="param-slider" id="wbStrikeSlider" min="50" max="200" value="105"
                            step="0.5">
                    </div>
                </div>
                <div class="wb-section">
                    <div class="wb-section-title">Contract Terms</div>
                    <div class="param-row">
                        <div class="param-header">
                            <span class="param-label">Time to Expiry (T)</span>
                            <span class="param-value" id="wbTimeDisplay">0.25 yr</span>
                        </div>
                        <input type="number" class="param-input" id="wbTimeInput" value="0.25" step="0.01" min="0.001"
                            max="10">
                        <input type="range" class="param-slider" id="wbTimeSlider" min="0.01" max="2" value="0.25"
                            step="0.01">
                    </div>
                </div>
                <div class="wb-section">
                    <div class="wb-section-title">Volatility & Rates</div>
                    <div class="param-row">
                        <div class="param-header">
                            <span class="param-label">Volatility (σ)</span>
                            <span class="param-value" id="wbVolDisplay">20.0%</span>
                        </div>
                        <input type="number" class="param-input" id="wbVolInput" value="20" step="0.5" min="0.1"
                            max="200">
                        <input type="range" class="param-slider" id="wbVolSlider" min="5" max="80" value="20"
                            step="0.5">
                    </div>
                    <div class="param-row">
                        <div class="param-header">
                            <span class="param-label">Risk-Free Rate (r)</span>
                            <span class="param-value" id="wbRateDisplay">5.0%</span>
                        </div>
                        <input type="number" class="param-input" id="wbRateInput" value="5" step="0.1" min="-10"
                            max="50">
                        <input type="range" class="param-slider" id="wbRateSlider" min="0" max="15" value="5"
                            step="0.1">
                    </div>
                </div>
            </aside>

            <main class="wb-panel-center">
                <div class="wb-chart-area">
                    <div class="wb-chart-header">
                        <div>
                            <div class="wb-chart-title">Payoff & P/L Diagram</div>
                            <div class="wb-chart-subtitle">At expiration · Premium included</div>
                        </div>
                        <div class="inline-controls" style="gap:6px;">
                            <label class="mini-label"><input type="checkbox" id="wbAutoScale" checked> Auto</label>
                            <input type="number" id="wbMinRange" class="market-input" style="max-width:90px;" placeholder="Min S">
                            <input type="number" id="wbMaxRange" class="market-input" style="max-width:90px;" placeholder="Max S">
                            <button class="btn btn-ghost btn-sm" id="wbResetRange">Reset</button>
                        </div>
                    </div>
                    <div class="wb-chart-container">
                        <canvas id="wbChart"></canvas>
                    </div>
                    <div class="card" style="margin-top:8px;">
                        <div class="card-header">Resumen payoff</div>
                        <div class="card-body">
                            <div class="inline-controls" style="gap:16px;">
                                <div><span class="mini-label">Break-even</span><div id="wbBreakEven">--</div></div>
                                <div><span class="mini-label">Pérdida máx</span><div id="wbMaxLoss">--</div></div>
                                <div><span class="mini-label">Ganancia máx</span><div id="wbMaxProfit">--</div></div>
                                <div><span class="mini-label">Signo</span><div id="wbSign">Long</div></div>
                            </div>
                        </div>
                    </div>
                </div>
            </main>

            <aside class="wb-panel-right">
                <div class="wb-section">
                    <div class="wb-section-title">Valuation</div>
                    <div class="meta-card" style="text-align:center;padding:var(--space-5);">
                        <div
                            style="font-size:10px;color:var(--muted-foreground);text-transform:uppercase;margin-bottom:4px;">
                            Theoretical Price</div>
                        <div class="meta-value price" id="wbPriceDisplay">3.86</div>
                        <div style="font-size:10px;color:var(--muted-foreground);margin-top:4px;">per contract</div>
                    </div>
                    <div class="meta-card">
                        <div class="meta-row">
                            <span class="meta-label">Intrinsic</span>
                            <span class="meta-value" id="wbIntrinsicDisplay">0.00</span>
                        </div>
                        <div class="meta-row">
                            <span class="meta-label">Time Value</span>
                            <span class="meta-value" id="wbTimeValueDisplay">3.86</span>
                        </div>
                        <div class="meta-row">
                            <span class="meta-label">Moneyness</span>
                            <span class="meta-value" id="wbMoneynessDisplay">OTM</span>
                        </div>
                    </div>
                </div>
                <div class="wb-section">
                    <div class="wb-section-title">Details</div>
                    <div class="meta-card">
                        <div class="meta-row">
                            <span class="meta-label">d₁</span>
                            <span class="meta-value mono" id="wbD1Display">0.0000</span>
                        </div>
                        <div class="meta-row">
                            <span class="meta-label">d₂</span>
                            <span class="meta-value mono" id="wbD2Display">0.0000</span>
                        </div>
                    </div>
                </div>
                <div class="wb-section">
                    <div class="wb-section-title">Actions</div>
                    <button class="btn btn-primary" style="width:100%;justify-content:center;">📊 Export Report</button>
                </div>
            </aside>

            <footer class="wb-footer">
                <div class="greeks-strip">
                    <div class="greek-tile">
                        <div class="greek-symbol">Δ</div>
                        <div class="greek-value" id="wbDeltaValue">0.4534</div>
                        <div class="greek-label">Delta</div>
                    </div>
                    <div class="greek-tile">
                        <div class="greek-symbol">Γ</div>
                        <div class="greek-value" id="wbGammaValue">0.0392</div>
                        <div class="greek-label">Gamma</div>
                    </div>
                    <div class="greek-tile">
                        <div class="greek-symbol">Θ</div>
                        <div class="greek-value" id="wbThetaValue">-0.0452</div>
                        <div class="greek-label">Theta</div>
                    </div>
                    <div class="greek-tile">
                        <div class="greek-symbol">V</div>
                        <div class="greek-value" id="wbVegaValue">0.1962</div>
                        <div class="greek-label">Vega</div>
                    </div>
                    <div class="greek-tile">
                        <div class="greek-symbol">ρ</div>
                        <div class="greek-value" id="wbRhoValue">0.1125</div>
                        <div class="greek-label">Rho</div>
                    </div>
                </div>
            </footer>
        </div>
    </div>

    <script>
        // ========== LANDING SCREEN LOGIC ==========
        // ========== LANDING SCREEN LOGIC ==========
        // REFACTORED TO GLOBAL SCOPE
        let particles = [];
        let animationId;
        const canvas = document.getElementById('sparkles-canvas');
        const ctx = canvas ? canvas.getContext('2d') : null;


        function initApp() {
            // Start Landing Particles
            if (document.getElementById('landing-overlay')) {
                initParticles();
            }
            // Add any other init logic here if needed
        }

        function initParticles() {
            const c = document.getElementById('sparkles-canvas');
            if (!c) return;
            const context = c.getContext('2d');

            const resize = () => {
                c.width = window.innerWidth;
                c.height = window.innerHeight;
            };
            resize();
            window.addEventListener('resize', resize);

            // Create particles
            const pList = [];
            const particleCount = 150;
            for (let i = 0; i < particleCount; i++) {
                pList.push({
                    x: Math.random() * c.width,
                    y: Math.random() * c.height,
                    size: Math.random() * 2 + 0.1,
                    speedX: (Math.random() - 0.5) * 0.5,
                    speedY: (Math.random() - 0.5) * 0.5,
                    opacity: Math.random(),
                    fadeSpeed: Math.random() * 0.01 + 0.005,
                    fadingIn: true
                });
            }

            const animate = () => {
                context.clearRect(0, 0, c.width, c.height);

                pList.forEach(p => {
                    p.x += p.speedX;
                    p.y += p.speedY;

                    if (p.x < 0) p.x = c.width;
                    if (p.x > c.width) p.x = 0;
                    if (p.y < 0) p.y = c.height;
                    if (p.y > c.height) p.y = 0;

                    if (p.fadingIn) {
                        p.opacity += p.fadeSpeed;
                        if (p.opacity >= 1) p.fadingIn = false;
                    } else {
                        p.opacity -= p.fadeSpeed;
                        if (p.opacity <= 0.1) {
                            p.fadingIn = true;
                            if (Math.random() < 0.1) {
                                p.x = Math.random() * c.width;
                                p.y = Math.random() * c.height;
                            }
                        }
                    }

                    context.beginPath();
                    context.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    context.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
                    context.fill();
                });

                animationId = requestAnimationFrame(animate);
            };
            animate();
        }

        function startApp() {
            const overlay = document.getElementById('landing-overlay');
            if (!overlay) return;

            overlay.classList.add('hidden');

            setTimeout(() => {
                if (animationId) cancelAnimationFrame(animationId);
                overlay.style.display = 'none';
            }, 1000);
        }
        window.startApp = startApp;

        // ========== FLUID TRANSITIONS ==========
        // ========== TAXONOMY DATA ==========
        // ========== TAXONOMY DATA (Aligned with NUMERADA.md) ==========
        const taxonomyData = [
            {
                id: '1', label: 'DERIVADOS LINEALES', children: [
                    {
                        id: '1.1', label: 'Forward', children: [
                            {
                                id: '1.1.1', label: 'Financial Forwards', children: [
                                    { id: '1.1.1.1', label: 'FX Forward' },
                                    { id: '1.1.1.2', label: 'Forward Rate Agreement' },
                                    { id: '1.1.1.4', label: 'Forward sobre acciones' }
                                ]
                            },
                            {
                                id: '1.1.2', label: 'Commodity Forwards', children: [
                                    { id: '1.1.2.1', label: 'Forward sobre petróleo' }
                                ]
                            },
                            {
                                id: '1.1.6', label: 'Equity Total Return Forwards', children: [
                                    { id: '1.1.6.1', label: 'TR Forward sobre acciones' }
                                ]
                            }
                        ]
                    },
                    {
                        id: '1.2', label: 'Futuros', children: [
                            {
                                id: '1.2.1', label: 'Futuros Financieros', children: [
                                    { id: '1.2.1.1', label: 'Sobre índices' },
                                    { id: '1.2.1.2', label: 'Sobre acciones' }
                                ]
                            },
                            {
                                id: '1.2.2', label: 'Futuros sobre Commodities', children: [
                                    { id: '1.2.2.1', label: 'Petróleo' }
                                ]
                            }
                        ]
                    },
                    {
                        id: '1.3', label: 'Swaps', children: [
                            {
                                id: '1.3.1', label: 'IRS (Interest Rate Swaps)', children: [
                                    { id: '1.3.1.1', label: 'IRS fijo–variable' }
                                ]
                            },
                            {
                                id: '1.3.4', label: 'Equity Swaps', children: [
                                    { id: '1.3.4.2', label: 'TRS' }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                id: '2', label: 'Derivados No Lineales', children: [
                    {
                        id: '2.1', label: 'Opciones Vanilla', children: [
                            {
                                id: '2.1.1', label: 'Call Europea', children: [
                                    { id: '2.1.1.1', label: 'Sobre acciones / índices' },
                                    { id: '2.1.1.2', label: 'Sobre divisas' }
                                ]
                            },
                            {
                                id: '2.1.3', label: 'Put Europea', children: [
                                    { id: '2.1.3.1', label: 'Sobre acciones / índices' },
                                    { id: '2.1.3.2', label: 'Sobre divisas' }
                                ]
                            }
                        ]
                    },
                    {
                        id: '2.3', label: 'Opciones Exóticas', children: [
                            {
                                id: '2.3.1', label: 'Opciones Barrera', children: [
                                    { id: '2.3.1.2', label: 'Knock-Out (up-and-out / down-and-out)' }
                                ]
                            },
                            {
                                id: '2.3.2', label: 'Opciones Asiáticas', children: [
                                    { id: '2.3.2.1', label: 'Asiática de precio' }
                                ]
                            },
                            {
                                id: '2.3.4', label: 'Opciones Digitales (Binarias)', children: [
                                    { id: '2.3.4.1', label: 'Cash-or-Nothing' }
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                id: '3', label: 'Productos Estructurados', children: [
                    {
                        id: '3.1', label: 'Notas Estructuradas', children: [
                            {
                                id: '3.1.1', label: 'Autocallables', children: [
                                    { id: '3.1.1.1', label: 'Autocall sobre acciones / índices' }
                                ]
                            },
                            {
                                id: '3.1.3', label: 'Range Accrual Notes', children: [
                                    { id: '3.1.3.1', label: 'Range Accrual sobre tipos' }
                                ]
                            }
                        ]
                    }
                ]
            }
        ];

        // ========== CATEGORY DESCRIPTIONS FOR PARENT NODES ==========
        const categoryDescriptions = {
            '1': {
                title: 'DERIVADOS LINEALES',
                definition: 'Instrumentos financieros cuyo valor (o payoff) varía de forma proporcional y directa con el precio del subyacente. Se caracterizan por tener un Delta constante igual a 1 (o -1 para posiciones cortas).',
                characteristics: [
                    'Payoff simétrico: ganancias y pérdidas son proporcionales al movimiento del subyacente',
                    'Delta = 1 (posición larga) o Delta = -1 (posición corta)',
                    'Sin convexidad: Gamma = 0',
                    'Valoración basada en no-arbitraje y cost-of-carry'
                ],
                keyConcept: 'El término "lineal" se refiere a que el gráfico Payoff vs Precio del Subyacente es una línea recta. No hay asimetría ni "kink" (quiebre) como en las opciones.',
                diagram: `graph LR
    subgraph "Payoff Derivado Lineal"
        A[Precio Subyacente ↓] --> B[Pérdida Proporcional]
        C[Precio Subyacente ↑] --> D[Ganancia Proporcional]
    end
    style A fill:#ef4444
    style C fill:#22c55e`,
                examples: ['Forwards', 'Futuros', 'Swaps (flujos de caja lineales)']
            },
            '1.1': {
                title: 'Forward',
                definition: 'Acuerdo bilateral OTC para comprar o vender un activo en una fecha futura a un precio fijado hoy. Es el derivado más puro y el bloque fundamental de la valoración de derivados.',
                characteristics: [
                    'Contrato OTC (no estandarizado)',
                    'Sin flujo de caja inicial (salvo colateral/margen)',
                    'Obligatorio para ambas partes',
                    'Riesgo de contraparte significativo'
                ],
                keyConcept: 'Fórmula de valoración: F = S₀ × e^(r-q)T, donde r es la tasa libre de riesgo, q es el dividend yield (o tasa foránea en FX), y T es el tiempo.',
                diagram: `sequenceDiagram
    participant A as Comprador
    participant B as Vendedor
    Note over A,B: t=0: Acuerdo Forward (F)
    A->>B: Compromiso de compra
    B->>A: Compromiso de venta
    Note over A,B: t=T: Liquidación
    A->>B: Paga F (precio forward)
    B->>A: Entrega Activo`,
                examples: ['FX Forward', 'Equity Forward', 'Commodity Forward']
            },
            '1.2': {
                title: 'Futuros',
                definition: 'Versión estandarizada del Forward, negociada en mercados organizados (bolsas) con liquidación diaria (mark-to-market) y cámara de compensación que elimina el riesgo de contraparte.',
                characteristics: [
                    'Estandarización: fechas, tamaños, calidades predefinidas',
                    'Mark-to-Market diario (margen de variación)',
                    'Cámara de Compensación (CCP) como contraparte central',
                    'Alta liquidez y transparencia de precios'
                ],
                keyConcept: 'La diferencia clave con el Forward es la liquidación diaria. Los flujos de caja ocurren cada día, no solo al vencimiento. Esto afecta ligeramente la valoración cuando las tasas de interés son estocásticas.',
                diagram: `graph TB
    subgraph "Estructura Futuros"
        C[Comprador] --> CCP[Cámara de Compensación]
        CCP --> V[Vendedor]
        CCP -->|Margen Diario| C
        CCP -->|Margen Diario| V
    end
    style CCP fill:#3b82f6`,
                examples: ['E-mini S&P 500', 'Eurodollar Futures', 'WTI Crude Oil Futures']
            },
            '1.3': {
                title: 'Swaps',
                definition: 'Intercambio de flujos de caja entre dos partes según una fórmula predefinida. Un swap puede verse como una cartera de forwards con diferentes fechas de vencimiento.',
                characteristics: [
                    'Flujos múltiples durante la vida del contrato',
                    'OTC pero con compensación central obligatoria (post-crisis 2008)',
                    'El nocional no se intercambia (salvo Cross-Currency Swaps)',
                    'Permite transformación de perfiles de riesgo'
                ],
                keyConcept: 'Un IRS (Interest Rate Swap) es una cartera de FRAs (Forward Rate Agreements). Un TRS (Total Return Swap) sintetiza la propiedad económica de un activo sin comprarlo.',
                diagram: `graph LR
    subgraph "IRS Fijo-Variable"
        A[Payer] -->|Paga Tasa Fija| B[Receiver]
        B -->|Paga Tasa Variable| A
    end
    Note[Nocional: Solo referencia]
    style A fill:#f59e0b
    style B fill:#8b5cf6`,
                examples: ['IRS Fijo-Variable', 'Cross-Currency Swap', 'Equity TRS']
            },
            '2': {
                title: 'Derivados No Lineales',
                definition: 'Instrumentos cuyo valor no varía proporcionalmente con el subyacente. Se caracterizan por tener convexidad (Gamma ≠ 0) y un payoff asimétrico, típico de las opciones.',
                characteristics: [
                    'Payoff asimétrico: riesgo limitado, potencial ilimitado (para el comprador)',
                    'Delta variable: cambia con el precio del subyacente',
                    'Gamma positivo: la convexidad beneficia al tenedor de la opción',
                    'Valor temporal que decae (Theta)'
                ],
                keyConcept: 'El "kink" (quiebre) en el Strike es lo que genera la no linealidad. A la izquierda del Strike, una Call vale cero. A la derecha, crece linealmente. Esta discontinuidad crea la convexidad.',
                diagram: `graph LR
    subgraph "Payoff Call Europea"
        A[S < K: Payoff = 0] --> B[Strike K]
        B --> C[S > K: Payoff = S-K]
    end
    style A fill:#94a3b8
    style C fill:#22c55e`,
                examples: ['Opciones Call/Put', 'Opciones Exóticas (Barrier, Asian)', 'Warrants']
            },
            '2.1': {
                title: 'Opciones Vanilla',
                definition: 'Opciones estándar (Call y Put) con características básicas: un strike, una fecha de vencimiento, ejercicio europeo o americano. Son los bloques fundamentales de productos más complejos.',
                characteristics: [
                    'Call: Derecho a comprar al Strike',
                    'Put: Derecho a vender al Strike',
                    'Prima: Precio pagado por el derecho',
                    'Europea: Ejercicio solo al vencimiento'
                ],
                keyConcept: 'Paridad Put-Call: C - P = S - K×e^(-rT). Esta relación fundamental conecta calls, puts, el subyacente y el bono cero-cupón.',
                diagram: `graph TB
    subgraph "Tipos de Opciones Vanilla"
        Call[Call: max(S-K, 0)]
        Put[Put: max(K-S, 0)]
    end
    Call --> Alcista[Visión Alcista]
    Put --> Bajista[Visión Bajista / Cobertura]
    style Call fill:#22c55e
    style Put fill:#ef4444`,
                examples: ['Call Europea sobre Equity', 'Put Americana sobre Índices', 'FX Options']
            },
            '2.3': {
                title: 'Opciones Exóticas',
                definition: 'Opciones con características adicionales que las diferencian de las vanilla: barreras, promedios, lookbacks, digitales, etc. Generalmente OTC y path-dependent.',
                characteristics: [
                    'Path-dependent: El payoff depende de la trayectoria del precio, no solo del valor final',
                    'Mayor complejidad de valoración (Monte Carlo, PDE)',
                    'Prima más barata que vanilla equivalente (típicamente)',
                    'Riesgos de modelo significativos'
                ],
                keyConcept: 'La "exoticidad" permite customizar el perfil de riesgo. Un Barrier reduce la prima pero introduce riesgo de "muerte" del contrato. Un Asian reduce volatilidad promediando.',
                diagram: `graph TB
    subgraph "Tipos Exóticos Principales"
        B[Barrier] --> KI[Knock-In]
        B --> KO[Knock-Out]
        A[Asian] --> AP[Average Price]
        A --> AS[Average Strike]
        D[Digital] --> CN[Cash-or-Nothing]
        D --> AN[Asset-or-Nothing]
    end`,
                examples: ['Knock-Out Call', 'Asian Average Price Option', 'Cash-or-Nothing Digital']
            },
            '3': {
                title: 'Productos Estructurados',
                definition: 'Combinaciones de instrumentos (bonos, opciones, swaps) empaquetados en un solo producto. Diseñados para retail o banca privada, ofrecen perfiles de riesgo-retorno personalizados.',
                characteristics: [
                    'Combinación de renta fija + derivados',
                    'Capital protegido (total o parcialmente) en muchos casos',
                    'Cupones condicionados a eventos de mercado',
                    'Riesgo de emisor (crédito del banco emisor)'
                ],
                keyConcept: 'El estructurador (banco) descompone las necesidades del cliente en bloques (bono cero-cupón + opciones) y los combina. El margen está en la diferencia entre valor teórico del paquete y precio de venta.',
                diagram: `graph LR
    subgraph "Estructura Autocall"
        BC[Bono Cero Cupón] --> AC[Autocall]
        OV[Opciones Vendidas] --> AC
        AC --> CUP[Cupón Condicionado]
        AC --> KI[Barrera Knock-In]
    end
    style AC fill:#8b5cf6`,
                examples: ['Autocall', 'Reverse Convertible', 'Range Accrual Note']
            },
            '3.1': {
                title: 'Notas Estructuradas',
                definition: 'Títulos de deuda cuyo rendimiento está ligado al comportamiento de un subyacente (acciones, índices, tipos de interés). Combina características de bonos y derivados.',
                characteristics: [
                    'Emitidas por bancos de inversión',
                    'Rentabilidad condicional (si el subyacente sube/baja)',
                    'Vencimiento típico: 1-5 años',
                    'Liquidez secundaria limitada'
                ],
                keyConcept: 'El inversor está asumiendo riesgos de mercado Y riesgo de crédito del emisor. Si el banco quiebra, la nota puede no pagarse aunque el subyacente haya tenido buen rendimiento.',
                diagram: `graph TB
    subgraph "Flujos Nota Estructurada"
        INV[Inversor] -->|Principal| BANCO[Banco Emisor]
        BANCO -->|Cupones + Principal*| INV
    end
    Note[*Sujeto a condiciones de mercado]
    style BANCO fill:#3b82f6`,
                examples: ['Autocall sobre IBEX', 'Range Accrual sobre Euribor', 'Reverse Convertible']
            }
        };

        // ========== LEAF ENGINE REGISTRY ==========
        const leafEngineMap = {
            // Linear
            '1.1.1.1': { engineType: 'linear', label: 'FX Forward', models: ['cost-of-carry'] },
            '1.1.1.2': { engineType: 'fra', label: 'Forward Rate Agreement', models: ['fra-pricing', 'fra-sim'] },
            '1.1.1.4': { engineType: 'linear', label: 'Equity Forward', models: ['cost-of-carry'] },
            '1.1.2.1': { engineType: 'linear', label: 'Oil Forward', models: ['cost-of-carry'] },
            '1.1.6.1': { engineType: 'linear', label: 'Total Return Forward', models: ['cost-of-carry'] },
            '1.2.1.1': { engineType: 'cfd', label: 'Index Future (CFD proxy)', models: ['linear'] },
            '1.2.2.1': { engineType: 'linear', label: 'Oil Future', models: ['cost-of-carry'] },
            '1.3.1.1': { engineType: null, label: 'IRS Fixed-Float', reason: 'Requires yield curve bootstrap - NOT IMPLEMENTED' },
            '1.3.4.2': { engineType: 'trs', label: 'Equity TRS', models: ['linear'] },

            // Options
            '2.1.1.1': { engineType: 'bsm', label: 'European Call (Equity)', optionType: 'call', models: ['bsm', 'mc'] },
            '2.1.1.2': { engineType: 'garman', label: 'European Call (FX)', optionType: 'call', models: ['garman-kohlhagen'] },
            '2.1.3.1': { engineType: 'bsm', label: 'European Put (Equity)', optionType: 'put', models: ['bsm', 'mc'] },
            '2.1.3.2': { engineType: 'garman', label: 'European Put (FX)', optionType: 'put', models: ['garman-kohlhagen'] },

            // Exotics
            '2.3.1.2': { engineType: 'barrierMC', label: 'Knock-Out Barrier', optionType: 'call', barrierType: 'down-out', models: ['mc'] },
            '2.3.2.1': { engineType: 'asianMC', label: 'Asian Average Price', models: ['mc'] },
            '2.3.4.1': { engineType: 'digital', label: 'Digital Cash-or-Nothing', models: ['bsm'] },

            // Structured
            '3.1.1.1': { engineType: null, label: 'Autocall Note', reason: 'Path-dependent MC with early exercise - NOT IMPLEMENTED' },
            '3.1.3.1': { engineType: null, label: 'Range Accrual', reason: 'Path-dependent simulation - NOT IMPLEMENTED' }
        };

        // ========== MICRO DATA BY LEAF ID ==========
        const microDataByLeafId = {
            '1.1.1.1': { // FX Forward
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Contrato obligatorio entre dos partes para comprar/vender una cantidad específica de divisas en una fecha futura a un tipo de cambio fijado hoy (forward rate). Su función principal es eliminar la incertidumbre del tipo de cambio.',
                    s1_2: 'Derivado lineal (delta 1).',
                    s1_3: 'Principalmente OTC (Over-the-Counter).',
                    s1_4: 'A diferencia del FX Future, no es estandarizado ni requiere margen diario. A diferencia del FX Swap, es una sola pata (outright), no un intercambio spot+forward.'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Comprador de divisa base / Vendedor de divisa cotizada. Contrapartes bancarias o corporativas.',
                    s2_2: 'Par de divisas (EUR/USD, USD/JPY, etc.).',
                    s2_3: 'Nocional (cantidad exacta en divisa base).',
                    s2_4: 'Vencimiento usualmente menor a 1 año (hasta 10 años en pares líquidos).'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Puede ser Deliverable (entrega física de las divisas) o Non-Deliverable (NDF, liquidación por diferencias en USD).',
                    s3_2: 'Pago único al vencimiento.',
                    s3_3: 'En T, A paga N × K (divisa cotizada) y B entrega N (divisa base).'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'Fecha valor spot + plazo (1W, 1M, 3M, 6M, 1Y).',
                    s4_2: 'Mercado interbancario global (altamente líquido).',
                    s4_3: 'Extremadamente alta en G10.'
                },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'El segmento de FX Forwards/Swaps es el mayor del mundo (trillions diarios según BIS).',
                    s5_2: 'Instrumento dominante en gestión de tesorería corporativa.',
                    s5_3: 'Corporates (import/export), Bancos Centrales, Fondos.'
                },
                s6: {
                    title: '6. Ejemplo numérico',
                    s6_1: 'Spot EUR/USD = 1.1000. Tipos: EUR 3%, USD 5%. Plazo 1 año.',
                    s6_2: 'F = 1.10 × (1+0.05)/(1+0.03) ≈ 1.1213.',
                    s6_3: 'Si al vencimiento Spot = 1.1500, el comprador del Forward (que fijó comprar a 1.1213) gana: (1.1500 - 1.1213) × N USD.'
                },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Asegurar tipo de cambio para pagos/cobros futuros.',
                    s7_2: 'Apostar a la apreciación/depreciación de una divisa.',
                    s7_3: 'Covered Interest Parity (CIP).',
                    s7_4: 'Pendiente de fuentes'
                },
                s8: {
                    title: '8. Ventajas y limitaciones',
                    s8_1: 'Personalización total (fechas, montos). Coste explícito cero (solo spread).',
                    s8_2: 'Riesgo de contraparte (sin cámara). Iliquidez para cerrar posición antes de vencimiento.'
                },
                s9: {
                    title: '9. Riesgos financieros asociados',
                    mercado: 'Riesgo de tipo de cambio y riesgo de base (tipos de interés).',
                    credito: 'Alto (liquidación del principal al vencimiento o Herstatt risk).',
                    liquidez: 'Bajo en G10, medio/alto en emergentes.',
                    operacional: 'Pendiente de fuentes',
                    correlacion: 'Pendiente de fuentes'
                },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'No arbitraje (Covered Interest Parity).',
                    variables: 'Spot, tipos de interés doméstico y foráneo, plazo.',
                    griegas: 'Delta (sensibilidad a Spot), Rho (sensibilidad a tipos).',
                    ejemplo: 'Pendiente de fuentes'
                },
                s11: {
                    title: '11. Aplicaciones profesionales',
                    caso: 'Empresa europea compra maquinaria en USD a pagar en 6 meses. Contrata FX Forward para fijar coste en EUR hoy.',
                    historico: 'Pendiente de fuentes',
                    conclusion: 'Pendiente de fuentes'
                }
            },
            '1.1.1.4': { // Forward sobre acciones
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Derivado lineal (delta-one) OTC mediante el cual dos partes se obligan a comprar o vender una cantidad específica de renta variable (acciones, índices o cestas) a un precio predeterminado en fecha futura.',
                    s1_2: 'Derivado lineal (delta = 1).',
                    s1_3: 'OTC (Over-the-Counter), no estandarizado.',
                    s1_4: 'A diferencia del Futuro, no requiere margen diario ni cámara de compensación. Usado para operaciones estratégicas (M&A) donde no se quiere revelar posición.'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Posición Larga (comprador): se compromete a comprar, se beneficia si sube. Posición Corta (vendedor): se compromete a vender, se beneficia si baja.',
                    s2_2: 'Single Name (acción específica), Equity Index (ej. S&P 500), o Basket (cesta de acciones).',
                    s2_3: 'Nocional = Precio unitario × Número de acciones. Determina los flujos de efectivo en liquidación.',
                    s2_4: 'Cláusulas anti-dilución para splits, dividendos extraordinarios, M&A. Vencimiento pactado libremente.'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Física (entrega de acciones a cambio de precio forward) o Cash Settlement (intercambio de diferencia neta).',
                    s3_2: 'Cash: Si S_T > K, vendedor paga (S_T - K) al comprador. Si S_T < K, comprador paga (K - S_T) al vendedor.',
                    s3_3: 'Física común en operaciones estratégicas; Cash más común en especulación y hedge funds.'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'OTC bilateral. Fecha de trade, fecha de vencimiento (maturity), fecha de liquidación.',
                    s4_2: 'Bancos de Inversión (Equity Finance), Hedge Funds, Corporaciones en M&A.',
                    s4_3: 'Regulación post-2008: reporting obligatorio, posible compensación central para forwards estandarizados.'
                },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'Mercado OTC significativo, menor transparencia que futuros. Nocionales en billones USD globalmente.',
                    s5_2: 'Clave en Equity Finance, préstamos de valores (Securities Lending), y estructuración de productos.',
                    s5_3: 'Permite exposición sintética sin comprar acciones, ahorrando capital y evitando disclosure.'
                },
                s6: {
                    title: '6. Ejemplo numérico',
                    s6_1: 'S₀=100€, r=5%, T=0.5 años, div yield q=2%. F = 100 × e^((0.05-0.02)×0.5) = 100 × e^0.015 = 101.51€.',
                    s6_2: 'F = S₀ × e^(r-q)T o F = S₀ × e^(rT) - VP(Dividendos discretos).',
                    s6_3: 'Muy sensible a proyección de dividendos. Error en dividendo impacta directamente en precio forward.'
                },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Cobertura de posiciones largas en acciones sin venderlas.',
                    s7_2: 'Especulación apalancada sobre movimiento de precio.',
                    s7_3: 'Monetización de posiciones restringidas (insiders, lockups).',
                    s7_4: 'Arbitraje entre forward y spot + financiación.'
                },
                s8: {
                    title: '8. Ventajas y limitaciones',
                    s8_1: 'Ventajas: Flexibilidad total (nocional, vencimiento, subyacente), no requiere desembolso inicial, no disclosure pública.',
                    s8_2: 'Limitaciones: Riesgo de contraparte significativo, sin liquidez secundaria, costes de documentación ISDA.'
                },
                s9: {
                    title: '9. Riesgos financieros asociados',
                    mercado: 'Riesgo de precio del subyacente (delta = 1). Pérdidas potencialmente ilimitadas.',
                    credito: 'Riesgo de contraparte alto sin colateralización. CSA (Credit Support Annex) mitiga.',
                    liquidez: 'Sin mercado secundario. Posición puede ser difícil de cerrar antes del vencimiento.',
                    operacional: 'Errores en cálculo de dividendos, fechas ex-div, corporate actions.',
                    correlacion: 'En baskets: riesgo de correlación entre componentes afecta hedge ratio.'
                },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'No-arbitraje: F = S₀ × e^(r-q)T. Valor del contrato existente: V = (F_actual - F_pactado) × e^(-rT).',
                    variables: 'S₀ (spot), r (tasa libre riesgo), q (div yield), T (tiempo), dividendos discretos proyectados.',
                    griegas: 'Delta = 1 (o -1 short), Gamma = 0, Theta = r × Forward Value, Vega = 0 (no hay volatilidad implícita).',
                    ejemplo: 'Forward comprado a F=100, ahora F_mercado=103, T_restante=0.25, r=5%: V = (103-100)×e^(-0.05×0.25) = 2.96€.'
                },
                s11: {
                    title: '11. Aplicaciones profesionales',
                    caso: 'CEO con 1M acciones en lockup de 2 años. Equity Forward le permite monetizar el 70% del valor hoy sin vender.',
                    historico: 'Enron usó equity forwards sobre sus propias acciones para manipular balance (caso de estudio negativo).',
                    conclusion: 'Herramienta esencial en Equity Finance moderna, requiere gestión cuidadosa de riesgo de contraparte.'
                }
            },
            '1.1.2.1': { // Forward sobre petróleo
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Contrato bilateral personalizado OTC para comprar/vender crudo (Brent, WTI) o refinados a precio fijado hoy para entrega futura.',
                    s1_2: 'Derivado lineal sobre commodity energético.',
                    s1_3: 'OTC (cargamentos físicos) y Financiero (Papel/swaps referenciados).',
                    s1_4: 'A diferencia del Futuro, implica logística real (buques, oleoductos, tanques) y riesgo de entrega física.'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Comprador (Posición Larga): refinerías, aerolíneas fijando costes. Vendedor (Posición Corta): productores asegurando precio de venta.',
                    s2_2: 'Crudos marcadores: WTI (Cushing, Oklahoma) o Brent (Mar del Norte). Precio = Índice +/- diferencial por calidad (API, azufre) y ubicación.',
                    s2_3: 'Nocional = Precio unitario × Número de barriles (ej. 100,000 bbl). Contratos de requerimientos cubren consumo real.',
                    s2_4: 'Incoterms (FOB, CIF). Ventana de carga específica (Laycan). Cláusulas de calidad y demurrage.'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Física (Gross Settlement): entrega real mediante transferencia de títulos en oleoductos o hubs. Financiera (Net Settlement): diferencia en efectivo.',
                    s3_2: 'Al completar carga/descarga (físico) o al fixing del índice (financiero).',
                    s3_3: 'Física predomina en mercado real de commodities; financiera en especulación y cobertura pura.'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'OTC bilateral con confirmación ISDA o contrato físico estándar. Date Brent (21 días adelante) es referencia clave.',
                    s4_2: 'Mercado del Mar del Norte (BFOET) para Brent. Cushing para WTI. Trading Houses: Vitol, Trafigura, Glencore.',
                    s4_3: 'Regulación CFTC/FCA para derivados financieros. Mercado físico menos regulado pero con obligaciones de reporting.'
                },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'Determina precios de referencia mundial (Benchmark Pricing). Brent es referencia para 2/3 del crudo mundial.',
                    s5_2: 'Mercado de trillones USD anuales. Esencial para cobertura de aerolíneas, navieras, refinerías.',
                    s5_3: 'Permite transferencia de riesgo de precio entre productores y consumidores de energía.'
                },
                s6: {
                    title: '6. Ejemplo numérico',
                    s6_1: 'Spot $80/bbl. Coste almacenamiento $1/mes. Convenience yield y=2%. r=5%. T=3 meses. F = 80 × e^((0.05+0.04-0.02)×0.25) = 81.41 (Contango).',
                    s6_2: 'Fórmula: F = S × e^((r + u - y)T), donde u=coste almacenamiento anualizado, y=convenience yield.',
                    s6_3: 'Si y > r+u → Backwardation (S > F). Si y < r+u → Contango (F > S). Situación de mercado determina estructura.'
                },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Refinerías cubriendo margen de refino (Crack Spread = Gasolina + Diésel - 3×Crudo).',
                    s7_2: 'Arbitraje físico: almacenamiento flotante (buques) cuando contango cubre costes de storage.',
                    s7_3: 'Aerolíneas fijando coste de jet fuel para presupuesto trimestral/anual.',
                    s7_4: 'Productores (NOCs, IOCs) asegurando flujo de caja predecible para inversiones CAPEX.'
                },
                s8: {
                    title: '8. Ventajas y limitaciones',
                    s8_1: 'Ventajas: Garantiza suministro físico (no solo precio), flexibilidad total en calidad/ubicación, cobertura perfecta para consumidores reales.',
                    s8_2: 'Limitaciones: Complejidad logística enorme, riesgo operacional (demurrage, calidad), capital intensivo, riesgo de contraparte sin CCP.'
                },
                s9: {
                    title: '9. Riesgos financieros asociados',
                    mercado: 'Volatilidad extrema por geopolítica (guerras, sanciones OPEP). Movimientos de 10% en un día son posibles.',
                    credito: 'Alto riesgo de contraparte. Colateralización mediante LOCs (Letters of Credit) o prepagos es común.',
                    liquidez: 'Mercado concentrado en pocos players. Posiciones grandes difíciles de cerrar rápido sin impact.',
                    operacional: 'Demurrage (retrasos de barcos cuestan $30-50k/día), calidad off-spec, fuerza mayor (bloqueo de canales).',
                    correlacion: 'Basis risk entre grado contratado y hedge con futuro (ej. crudo pesado vs WTI ligero).'
                },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'Cost of Carry con Convenience Yield: F = S × e^((r + u - y)T). Backwardation si y alta (escasez), Contango si y baja.',
                    variables: 'S (spot), r (tasa interés), u (coste almacenamiento), y (convenience yield), T (tiempo). También: calidad, ubicación, Incoterms.',
                    griegas: 'Delta ≈ 1. No hay gamma/vega en sentido de opciones. Sensibilidad a basis (diferencial de grado/ubicación).',
                    ejemplo: 'Refiner compra 1M bbl a F=$82 para 6 meses. Spot a vencimiento $90. Ahorro = 8M USD. Pero pierde upside si spot cae.'
                },
                s11: {
                    title: '11. Aplicaciones profesionales',
                    caso: 'Aerolínea (Ryanair, Southwest) comprando Jet Fuel Forward para fijar 50% de su consumo anual y estabilizar guidance financiero.',
                    historico: 'Southwest Airlines famosa por hedging agresivo pre-2008 que le dio ventaja competitiva vs. peers no cubiertos.',
                    conclusion: 'Instrumento fundamental para gestión de riesgo energético. Requiere expertise operativo además de financiero.'
                }
            },
            '1.1.6.1': { // TR Forward sobre acciones
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Sintetizar la propiedad económica completa de una acción sin comprarla. El comprador recibe la apreciación del precio + dividendos. Paga una tasa de financiación.',
                    s1_2: 'Lineal.',
                    s1_3: 'OTC.',
                    s1_4: 'Pendiente de fuentes'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Pendiente de fuentes',
                    s2_2: 'Pata Equity: (S_T - S_0) + Dividendos. Pata Financiación: S_0 × (r + spread) × T.',
                    s2_3: 'Pendiente de fuentes',
                    s2_4: 'Pendiente de fuentes'
                },
                s3: { title: '3. Forma de liquidación', s3_1: 'Pendiente de fuentes', s3_2: 'Pendiente de fuentes', s3_3: 'Pendiente de fuentes' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'Pendiente de fuentes', s4_3: 'Pendiente de fuentes' },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'Pendiente de fuentes', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Pendiente de fuentes', s6_3: 'Pendiente de fuentes' },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Hedge Funds para apalancamiento (no desembolsan el nocional, solo margen) y acceso a mercados complejos.',
                    s7_2: 'Evitar impuestos de retención en origen sobre dividendos (en ciertas jurisdicciones).',
                    s7_3: 'Pendiente de fuentes',
                    s7_4: 'Pendiente de fuentes'
                },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Pendiente de fuentes', s8_2: 'Pendiente de fuentes' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Pendiente de fuentes', credito: 'Pendiente de fuentes', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: { title: '10. Valoración y métricas cuantitativas', principio: 'Pendiente de fuentes', variables: 'Pendiente de fuentes', griegas: 'Pendiente de fuentes', ejemplo: 'Pendiente de fuentes' },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '1.2.1.1': { // Futuros sobre índices
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Contrato estandarizado negociado en bolsa (ETD) para comprar/vender el valor de un índice bursátil en una fecha futura.',
                    s1_2: 'Derivado lineal, estandarizado, compensado centralmente (CCP).',
                    s1_3: 'Mercado organizado (Eurex, CME, MEFF).',
                    s1_4: 'Al ser sobre un índice (intangible), la liquidación es exclusivamente por diferencias (Cash Settlement).'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Posición Larga (comprador): gana si el índice sube. Posición Corta (vendedor): gana si baja.',
                    s2_2: 'Índices Equity: S&P 500, Euro Stoxx 50, IBEX 35, DAX, Nikkei 225.',
                    s2_3: 'Nocional = Nivel del Índice × Multiplicador monetario (ej. 10€ por punto IBEX).',
                    s2_4: 'Vencimientos trimestrales (Marzo, Junio, Sept, Dic). Tick mínimo de cotización.'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Exclusivamente Financiera (Cash Settlement). Imposible la entrega física de "un índice".',
                    s3_2: 'Liquidación diaria de pérdidas y ganancias (Mark-to-Market) y final al vencimiento contra el precio de liquidación oficial.',
                    s3_3: 'Precio de Liquidación Final (EDSP) calculado por la bolsa (ej. media precios entre 8:30 y 9:00).'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'Negociación electrónica continua. Último día negociación suele ser el tercer viernes del mes de vencimiento (Hora de brujas).',
                    s4_2: 'CME Group (E-mini S&P), Eurex (Euro Stoxx), ICE, MEFF.',
                    s4_3: 'Supervisión estricta por CNMV/ESMA/CFTC. Contrapartida Central (BME Clearing, Eurex Clearing) garantiza cumplimiento.'
                },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'Los instrumentos más líquidos del mundo. E-mini S&P 500 negocia millones de contratos diarios.',
                    s5_2: 'Termómetro del sentimiento de mercado global y herramienta principal para cobertura de carteras de fondos.',
                    s5_3: 'Permite Beta Hedging: ajustar la exposición sistemática de una cartera de forma rápida y barata.'
                },
                s6: {
                    title: '6. Ejemplo numérico',
                    s6_1: 'Compra 1 Futuro EuroStoxx 50 a 4.000 puntos. Multiplicador 10€. Nocional = 40.000€.',
                    s6_2: 'Día 1: Cierra a 4.050. Ganancia = (4050-4000)×10 = 500€. Se abonan en la cuenta de garantías.',
                    s6_3: 'Día 2: Cierra a 3.900. Pérdida = (3900-4050)×10 = -1.500€. Margin Call si baja del margen de mantenimiento.'
                },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Cobertura (Hedging): Proteger cartera de acciones contra caída general del mercado (reducir Beta).',
                    s7_2: 'Especulación direccional: Apostar al alza/baja del mercado con apalancamiento.',
                    s7_3: 'Asset Allocation: Cambiar ponderación de RV en una cartera mixta sin vender las acciones físicas.',
                    s7_4: 'Arbitraje de Índice (Cash-and-Carry): Explotar diferencias entre futuro y cesta de acciones spot.'
                },
                s8: {
                    title: '8. Ventajas y limitaciones',
                    s8_1: 'Ventajas: Liquidez extrema, bajos costes de transacción, apalancamiento, facilidad de venta corta, sin riesgo contraparte bilateral.',
                    s8_2: 'Limitaciones: Rigidez de vencimientos trimestrales (riesgo de base si se cubre fecha intermedia), necesidad de gestión de liquidez para margin calls.'
                },
                s9: {
                    title: '9. Riesgos financieros asociados',
                    mercado: 'Apalancamiento (1:10 o 1:20): pequeñas variaciones del índice causan grandes impactos en el capital.',
                    credito: 'Nulo frente a contraparte (asumido por CCP). Riesgo de quiebra del bróker o de la propia CCP (muy remoto).',
                    liquidez: 'Generalmente muy alta, salvo en "flash crash" o cierres de mercado.',
                    operacional: 'Errores en órdenes (fat finger). Riesgo de ejecución (slippage) en momentos de alta volatilidad.',
                    correlacion: 'Basis Risk: Si la cartera a cubrir no se correlaciona perfectamente con el índice (Tracking Error).'
                },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'Cost of Carry: F = S × e^((r-q)T). Convergencia al precio spot en vencimiento.',
                    variables: 'Nivel índice (S), tipos interés (r), dividendos esperados (q), tiempo (T). Base = F - S.',
                    griegas: 'Delta (exposición direccional), Theta (coste intereses). Beta de la cartera para calcular ratio de cobertura: N = (Beta × ValorCartera) / NocionalFuturo.',
                    ejemplo: 'Cubrir cartera 10M€ (Beta 1.2) con Futuro IBEX (Nocional 100k€). N = (1.2 × 10M)/100k = Vender 120 contratos.'
                },
                s11: {
                    title: '11. Aplicaciones profesionales',
                    caso: 'Gestora de Fondos recibe suscripción de 50M€ en efectivo. Compra futuros inmediatamente para tener exposición a mercado mientras selecciona las acciones ("Equitizing Cash").',
                    historico: 'Crash 1987: El "Portfolio Insurance" con futuros exacerbó la caída por ventas automáticas en espiral.',
                    conclusion: 'La herramienta más eficiente y líquida para gestionar riesgo de mercado sistemático (Beta).'
                }
            },
            '1.2.1.2': { // Futuros SSF
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Contrato de futuro estandarizado sobre 100 acciones individuales (Single Stock Futures).',
                    s1_2: 'Derivado lineal, ETD.',
                    s1_3: 'Mercado organizado (MEFF, Eurex, ICE).',
                    s1_4: 'Compite directamente con la compra de acciones a crédito (margin trading) y el préstamo de títulos.'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Comprador (Largo) y Vendedor (Corto) anónimos a través de la CCP.',
                    s2_2: 'Acciones de gran capitalización y liquidez (Blue Chips).',
                    s2_3: '1 Contrato = 100 Acciones generalmente. Ajustes por splits o dividendos extraordinarios.',
                    s2_4: 'Vencimientos mensuales y trimestrales estándar.'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Puede ser Física (entrega de acciones) o por Diferencias (Cash), dependiendo del mercado.',
                    s3_2: 'Liquidación diaria de márgenes (como todos los futuros) y liquidación final al vencimiento.',
                    s3_3: 'Si es física, el vendedor entrega acciones y recibe el precio final de liquidación.'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'Negociación continua. Vencimiento suele ser el tercer viernes de mes.',
                    s4_2: 'Mercado español (MEFF) es muy activo en futuros sobre acciones. Eurex en Europa.',
                    s4_3: 'La CCP gestiona el riesgo de entrega en la liquidación física.'
                },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'Menor volumen que los futuros sobre índices, pero clave para estrategias específicas (pares, dividendos).',
                    s5_2: 'Permite ponerse corto en acciones de forma más barata y eficiente que el préstamo de valores (SBL).',
                    s5_3: 'Usado por market makers de opciones para cubrir su Delta.'
                },
                s6: {
                    title: '6. Ejemplo numérico',
                    s6_1: 'Comprar 10 Futuros BBVA a 6.00€. Nocional = 10 × 100 × 6 = 6.000€.',
                    s6_2: 'Margen requerido: ~10% (600€). Apalancamiento 10x.',
                    s6_3: 'Si sube a 6.60€ (+10%), Ganancia = 10 × 100 × 0.60 = 600€ (100% retorno sobre margen).'
                },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Venta en corto (Short Selling) para especular con caídas sin pedir prestado el título.',
                    s7_2: 'Captura de dividendos (DividendPlays) si el descuento del futuro difiere del dividendo real.',
                    s7_3: 'Trading de pares (Long Telefónica / Short Vodafone) neutral al mercado.',
                    s7_4: 'Sustitución de acciones: Mantener exposición alcista liberando capital (cash extraction).'
                },
                s8: {
                    title: '8. Ventajas y limitaciones',
                    s8_1: 'Ventajas: Bajos costes, facilidad de short, apalancamiento, transparencia.',
                    s8_2: 'Limitaciones: Menor liquidez que el contado en algunos valores, spreads más amplios.'
                },
                s9: {
                    title: '9. Riesgos financieros asociados',
                    mercado: 'Riesgo específico de la acción (idiosincrático). Gaps de apertura.',
                    credito: 'Nulo (CCP).',
                    liquidez: 'Riesgo de horquilla (bid-ask) en vencimientos lejanos.',
                    operacional: 'Gestión de ajustes por Dividendos y Ampliaciones de Capital (Corporate Actions).',
                    correlacion: 'N/A (Single Stock).'
                },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'F = S × e^(rT) - VP(Dividendos).',
                    variables: 'Curva de tipos, calendario de dividendos proyectados.',
                    griegas: 'Delta=100 (por contrato), Gamma=0.',
                    ejemplo: 'Si futuro cotiza por debajo del teórico (F < S*e^rT - Div), arbitraje compra futuro y vende contado.'
                },
                s11: {
                    title: '11. Aplicaciones profesionales',
                    caso: 'Fondo Long/Short Equity usa SSF para ejecutar la pata "Short" de sus ideas de inversión.',
                    historico: 'Introducción de SSF en EEUU (OneChicago) tuvo éxito moderado vs opciones.',
                    conclusion: 'Herramienta táctica para gestores activos y traders de volatilidad.'
                }
            },
            '1.2.2.1': { // Futuros Petróleo
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Contrato más negociado del mundo (NYMEX WTI, ICE Brent). Estandarizado por vencimientos mensuales.',
                    s1_2: 'Lineal.',
                    s1_3: 'Organizado (NYMEX, ICE).',
                    s1_4: 'Pendiente de fuentes'
                },
                s2: { title: '2. Estructura contractual', s2_1: 'Pendiente de fuentes', s2_2: 'WTI, Brent.', s2_3: 'Pendiente de fuentes', s2_4: 'Pendiente de fuentes' },
                s3: { title: '3. Forma de liquidación', s3_1: 'NYMEX WTI es Físico (entrega en Cushing, Oklahoma). ICE Brent es Cash Settled (contra índice BFOET).', s3_2: 'Pendiente de fuentes', s3_3: 'Pendiente de fuentes' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'NYMEX, ICE.', s4_3: 'Pendiente de fuentes' },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'El más negociado del mundo.', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Pendiente de fuentes', s6_3: 'Pendiente de fuentes' },
                s7: { title: '7. Usos y funciones principales', s7_1: 'Pendiente de fuentes', s7_2: 'Pendiente de fuentes', s7_3: 'Pendiente de fuentes', s7_4: 'Pendiente de fuentes' },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Pendiente de fuentes', s8_2: 'Pendiente de fuentes' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Pendiente de fuentes', credito: 'Pendiente de fuentes', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: { title: '10. Valoración y métricas cuantitativas', principio: 'Pendiente de fuentes', variables: 'Pendiente de fuentes', griegas: 'Pendiente de fuentes', ejemplo: 'Pendiente de fuentes' },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '1.3.1.1': { // IRS fijo-variable
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Intercambio de flujos de intereses sobre un nocional: una parte paga tasa fija y recibe tasa variable (Euribor/Libor).',
                    s1_2: 'Lineal.',
                    s1_3: 'OTC (pero con compensación central obligatoria en LCH/Eurex para divisas mayores).',
                    s1_4: 'Es una cartera de FRAs.'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Payer (paga fijo) / Receiver (recibe fijo).',
                    s2_2: 'Tasa variable (Euribor 3M/6M, SOFR, ESTR).',
                    s2_3: 'Convenciones: Day count (Act/360 en EUR, 30/360 en USD fijo).',
                    s2_4: 'Pendiente de fuentes'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Financiera (Netting de intereses).',
                    s3_2: 'Trimestral o semestral.',
                    s3_3: 'Pendiente de fuentes'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'Pendiente de fuentes',
                    s4_2: 'El mercado de derivados más grande del mundo en nocional. Curva Swap es la referencia de tasa libre de riesgo para el sector privado.',
                    s4_3: 'Pendiente de fuentes'
                },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'El mayor mercado de derivados en nocional.', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Pendiente de fuentes', s6_3: 'Pendiente de fuentes' },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Convertir deuda variable a fija (empresas).',
                    s7_2: 'Pendiente de fuentes',
                    s7_3: 'Pendiente de fuentes',
                    s7_4: 'Gestión de duración (fondos de pensiones).'
                },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Pendiente de fuentes', s8_2: 'Pendiente de fuentes' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Pendiente de fuentes', credito: 'Pendiente de fuentes', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'Valor Presente de Pata Fija vs Valor Presente de Pata Variable (proyectada con curva forward). El Swap Rate es la tasa fija que hace VP=0 al inicio.',
                    variables: 'Pendiente de fuentes',
                    griegas: 'Pendiente de fuentes',
                    ejemplo: 'Pendiente de fuentes'
                },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '1.3.4.2': { // TRS
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'El receptor obtiene la rentabilidad total (Precio + Dividendos) a cambio de pagar financiación.',
                    s1_2: 'Lineal.',
                    s1_3: 'OTC.',
                    s1_4: 'Instrumento clave para Prime Brokerage (Hedge Funds obteniendo apalancamiento sintético).'
                },
                s2: { title: '2. Estructura contractual', s2_1: 'Pendiente de fuentes', s2_2: 'Equity o índice.', s2_3: 'Pendiente de fuentes', s2_4: 'Pendiente de fuentes' },
                s3: { title: '3. Forma de liquidación', s3_1: 'Pendiente de fuentes', s3_2: 'Pendiente de fuentes', s3_3: 'Pendiente de fuentes' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'Pendiente de fuentes', s4_3: 'Pendiente de fuentes' },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'Pendiente de fuentes',
                    s5_2: 'Permite vender en corto (Short Selling) sintéticamente: el HF paga el rendimiento del Equity y recibe intereses.',
                    s5_3: 'Pendiente de fuentes'
                },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Pendiente de fuentes', s6_3: 'Pendiente de fuentes' },
                s7: { title: '7. Usos y funciones principales', s7_1: 'Pendiente de fuentes', s7_2: 'Pendiente de fuentes', s7_3: 'Pendiente de fuentes', s7_4: 'Pendiente de fuentes' },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Pendiente de fuentes', s8_2: 'Pendiente de fuentes' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Pendiente de fuentes', credito: 'Pendiente de fuentes', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: { title: '10. Valoración y métricas cuantitativas', principio: 'Pendiente de fuentes', variables: 'Pendiente de fuentes', griegas: 'Pendiente de fuentes', ejemplo: 'Pendiente de fuentes' },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '2.1.1.1': { // Call Europea Equity
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Contrato que otorga al comprador el derecho (pero no la obligación) de comprar el subyacente a un precio fijo (Strike) en una fecha futura (Vencimiento).',
                    s1_2: 'No lineal (Convexidad positiva para el comprador).',
                    s1_3: 'Organizado y OTC.',
                    s1_4: 'Solo ejercitable al vencimiento (vs Americana).'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Comprador (long) y Vendedor (short/writer).',
                    s2_2: 'Acciones (ej. SAN) o Índices (IBEX, SPX).',
                    s2_3: 'Pendiente de fuentes',
                    s2_4: 'Muy alta en índices; cash settled habitual en índices.'
                },
                s3: { title: '3. Forma de liquidación', s3_1: 'Cash settled en índices, física en acciones.', s3_2: 'Única al vencimiento.', s3_3: 'max(S_T - K, 0).' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'MEFF, CBOE, Eurex.', s4_3: 'Alta.' },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'Pendiente de fuentes', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Modelo Black-Scholes-Merton.', s6_3: 'Pendiente de fuentes' },
                s7: { title: '7. Usos y funciones principales', s7_1: 'Cobertura.', s7_2: 'Especulación direccional alcista.', s7_3: 'Pendiente de fuentes', s7_4: 'Pendiente de fuentes' },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Pérdida limitada a la prima.', s8_2: 'Prima puede ser costosa.' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Delta, Gamma, Vega, Theta.', credito: 'Bajo (CCP).', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'Black-Scholes-Merton.',
                    variables: 'S, K, T, r, σ, q.',
                    griegas: 'Delta, Gamma, Theta, Vega, Rho.',
                    ejemplo: 'Pendiente de fuentes'
                },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '2.1.1.2': { // Call Europea FX
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Derecho a comprar Divisa A pagando Divisa B.',
                    s1_2: 'No lineal.',
                    s1_3: 'OTC principalmente.',
                    s1_4: 'Pendiente de fuentes'
                },
                s2: { title: '2. Estructura contractual', s2_1: 'Pendiente de fuentes', s2_2: 'Par de divisas.', s2_3: 'Pendiente de fuentes', s2_4: 'Pendiente de fuentes' },
                s3: { title: '3. Forma de liquidación', s3_1: 'Pendiente de fuentes', s3_2: 'Pendiente de fuentes', s3_3: 'Pendiente de fuentes' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'Pendiente de fuentes', s4_3: 'Pendiente de fuentes' },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'Pendiente de fuentes', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Modelo: Garman-Kohlhagen (extensión de BS para dos tasas de interés).', s6_3: 'Pendiente de fuentes' },
                s7: { title: '7. Usos y funciones principales', s7_1: 'Pendiente de fuentes', s7_2: 'Pendiente de fuentes', s7_3: 'Pendiente de fuentes', s7_4: 'Pendiente de fuentes' },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Pendiente de fuentes', s8_2: 'Pendiente de fuentes' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Pendiente de fuentes', credito: 'Pendiente de fuentes', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: { title: '10. Valoración y métricas cuantitativas', principio: 'Garman-Kohlhagen.', variables: 'S, K, r_d, r_f, σ, T.', griegas: 'Pendiente de fuentes', ejemplo: 'Pendiente de fuentes' },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '2.1.3.1': { // Put Europea Equity
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Derecho a vender el subyacente a precio fijo (K). Beneficia si el mercado cae. Payoff: max(K - S_T, 0).',
                    s1_2: 'No lineal.',
                    s1_3: 'Organizado y OTC.',
                    s1_4: 'Pendiente de fuentes'
                },
                s2: { title: '2. Estructura contractual', s2_1: 'Pendiente de fuentes', s2_2: 'Acciones/índices.', s2_3: 'Pendiente de fuentes', s2_4: 'Pendiente de fuentes' },
                s3: { title: '3. Forma de liquidación', s3_1: 'Pendiente de fuentes', s3_2: 'Pendiente de fuentes', s3_3: 'max(K - S_T, 0).' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'Pendiente de fuentes', s4_3: 'Pendiente de fuentes' },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'Pendiente de fuentes', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Pendiente de fuentes', s6_3: 'Pendiente de fuentes' },
                s7: { title: '7. Usos y funciones principales', s7_1: 'Seguro de cartera (Portfolio Insurance).', s7_2: 'Pendiente de fuentes', s7_3: 'Pendiente de fuentes', s7_4: 'Pendiente de fuentes' },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Pendiente de fuentes', s8_2: 'Pendiente de fuentes' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Pendiente de fuentes', credito: 'Pendiente de fuentes', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: { title: '10. Valoración y métricas cuantitativas', principio: 'Black-Scholes-Merton.', variables: 'S, K, T, r, σ, q.', griegas: 'Pendiente de fuentes', ejemplo: 'Pendiente de fuentes' },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '2.1.3.2': { // Put Europea FX
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Derecho a vender divisa a tipo de cambio fijo.',
                    s1_2: 'No lineal.',
                    s1_3: 'OTC.',
                    s1_4: 'Pendiente de fuentes'
                },
                s2: { title: '2. Estructura contractual', s2_1: 'Pendiente de fuentes', s2_2: 'Par de divisas.', s2_3: 'Pendiente de fuentes', s2_4: 'Pendiente de fuentes' },
                s3: { title: '3. Forma de liquidación', s3_1: 'Pendiente de fuentes', s3_2: 'Pendiente de fuentes', s3_3: 'Pendiente de fuentes' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'Pendiente de fuentes', s4_3: 'Pendiente de fuentes' },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'Pendiente de fuentes', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Pendiente de fuentes', s6_3: 'Pendiente de fuentes' },
                s7: { title: '7. Usos y funciones principales', s7_1: 'Exportador asegurando un tipo de cambio mínimo de venta de sus divisas.', s7_2: 'Pendiente de fuentes', s7_3: 'Pendiente de fuentes', s7_4: 'Pendiente de fuentes' },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Pendiente de fuentes', s8_2: 'Pendiente de fuentes' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Pendiente de fuentes', credito: 'Pendiente de fuentes', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: { title: '10. Valoración y métricas cuantitativas', principio: 'Garman-Kohlhagen.', variables: 'Pendiente de fuentes', griegas: 'Pendiente de fuentes', ejemplo: 'Pendiente de fuentes' },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '2.3.1.2': { // Knock-Out Barrier
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Opción que "muere" (se desactiva) si el subyacente toca una barrera predefinida (H). Tipos principales: Down-and-Out (se desactiva si S ≤ H), Up-and-Out (se desactiva si S ≥ H). Existe también la versión Knock-In que se activa al tocar la barrera.',
                    s1_2: 'Derivado no lineal, exótico, path-dependent.',
                    s1_3: 'OTC principalmente. Negociado entre bancos de inversión y clientes institucionales.',
                    s1_4: 'Más barata que vanilla equivalente porque tiene probabilidad de "morir" sin valor. Relación: Knock-In + Knock-Out = Vanilla (misma barrera y strike).'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Comprador (paga prima, recibe payoff condicionado) y Vendedor (recibe prima, paga payoff condicionado).',
                    s2_2: 'Equity, FX (muy común), Commodities, Índices.',
                    s2_3: 'Nocional = Cantidad × Precio unitario. Barrera H puede ser continua (24/7) o discreta (solo cierres diarios).',
                    s2_4: 'Parámetros clave: Strike K, Barrera H, Tipo (Up/Down, In/Out), Monitoreo (continuo/discreto), Rebate (pago si se activa barrera).'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Cash settlement predominante. Si toca barrera → opción "muere" (Knock-Out) o "nace" (Knock-In).',
                    s3_2: 'Liquidación única al vencimiento, si sobrevive.',
                    s3_3: 'Down-Out Call: Si S nunca tocó H durante la vida, payoff = max(S_T - K, 0). Si tocó H, payoff = Rebate (usualmente 0).'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'Negociación OTC bilateral. Confirmación ISDA estándar para exóticos.',
                    s4_2: 'Muy líquido en mercado FX (EUR/USD, USD/JPY). Común en productos estructurados de banca privada.',
                    s4_3: 'Menor liquidez que vanilla. Spreads más amplios cerca de la barrera (hedging difícil).'
                },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'Segmento significativo del mercado OTC de opciones exóticas. Datos específicos: PENDING_VERIFICATION.',
                    s5_2: 'Muy popular en FX por reducción de prima. Común en notes estructuradas con "capital protegido condicionado".',
                    s5_3: 'Bancos de inversión (emisores), Hedge Funds, Tesorerías corporativas (cobertura de divisas).'
                },
                s6: {
                    title: '6. Ejemplo numérico',
                    s6_1: 'Down-and-Out Call: S₀=100, K=105, H=90, T=0.5, r=5%, σ=25%.',
                    s6_2: 'Precio (fórmula cerrada Rubinstein-Reiner): Se calcula usando reflexión y ajustes por barrera. Precio ≈ 3.5 (vs Vanilla Call ≈ 5.2).',
                    s6_3: 'Ahorro de prima ~33%, pero si S cae a 90 en cualquier momento, la opción desaparece sin valor.'
                },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Reducir coste de cobertura cuando la barrera está en zona "improbable" según visión del hedger.',
                    s7_2: 'Especulación con leverage: Comprar Up-and-Out Put barato apostando a caída moderada.',
                    s7_3: 'Construcción de productos estructurados con protección condicional (si no toca barrera, capital garantizado).',
                    s7_4: 'Arbitraje entre barrera continua y discreta (existe diferencia de precio por gap risk).'
                },
                s8: {
                    title: '8. Ventajas y limitaciones',
                    s8_1: 'Prima significativamente menor que vanilla. Permite cobertura más barata si se acepta riesgo de knock-out.',
                    s8_2: 'Riesgo de pérdida total cerca de la barrera. Hedging muy difícil (gamma/vanna explosivos cerca de H). Gap risk en monitoreo discreto.'
                },
                s9: {
                    title: '9. Riesgos financieros asociados',
                    mercado: 'Delta y Gamma explotan cerca de la barrera. Vega muy alto. Volga y Vanna son críticos.',
                    credito: 'Riesgo OTC estándar. Mitigado con CSA/colateral.',
                    liquidez: 'Difícil cerrar posición cerca de la barrera. Spreads se amplían significativamente.',
                    operacional: 'Definición precisa del evento de barrera (hora, fixing oficial, spread). Disputas si precio "tocó" pero no cerró bajo barrera.',
                    correlacion: 'N/A para single-asset. En multi-asset barriers, correlación es crítica.'
                },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'Fórmula cerrada de Rubinstein-Reiner (1991) para barreras continuas. Monte Carlo para discretas o path-dependent complejas.',
                    variables: 'S (spot), K (strike), H (barrera), T (tiempo), r (tasa), q (div yield), σ (volatilidad), λ = (r-q+σ²/2)/σ².',
                    griegas: 'Delta discontinuo en H. Gamma → ∞ cerca de H. Vanna y Volga muy significativos. Theta depende de proximidad a barrera.',
                    ejemplo: 'Down-Out Call: C_do = C_vanilla - C_di, donde C_di se calcula con reflexión: C_di = (S/H)^(2λ) × C(H²/S, K). Ver Hull Cap.26.'
                },
                s11: {
                    title: '11. Aplicaciones profesionales',
                    caso: 'Exportador europeo compra Down-and-Out Put EUR/USD con barrera 1.05 y strike 1.10. Prima 50% menor que vanilla. Protegido salvo si EUR sube mucho.',
                    historico: 'Crisis 2008: Muchas barrier options en CHF "murieron" cuando SNB dejó de defender el piso de 1.20, causando pérdidas masivas.',
                    conclusion: 'Instrumento potente para reducir costes pero requiere comprensión profunda de los riesgos cerca de la barrera y gestión activa.'
                }
            },
            '2.3.2.1': { // Asiática de precio
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Opción cuyo payoff depende del precio promedio del subyacente durante un período de observación. Dos tipos: Average Price (payoff = max(S_avg - K, 0)) y Average Strike (payoff = max(S_T - S_avg, 0)).',
                    s1_2: 'Derivado no lineal, exótico, path-dependent.',
                    s1_3: 'OTC. Muy común en commodities y FX.',
                    s1_4: 'Más barata que vanilla porque la volatilidad de un promedio es menor que la volatilidad del precio final. Evita manipulación del precio al vencimiento.'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Comprador (paga prima, recibe payoff basado en promedio) y Vendedor.',
                    s2_2: 'Commodities (petróleo, gas, metales), FX, Equity. Muy usado en energía donde hay fixings diarios.',
                    s2_3: 'Nocional estándar. Período de averaging (ej. últimos 30 días). Frecuencia de observación (diaria, semanal, mensual).',
                    s2_4: 'Tipo de promedio: Aritmético (más común) o Geométrico (tiene fórmula cerrada). Fechas de observación específicas.'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Cash settlement basado en el promedio calculado según las observaciones del contrato.',
                    s3_2: 'Única al vencimiento.',
                    s3_3: 'Average Price Call: Payoff = max(S_avg - K, 0). Average Strike Call: Payoff = max(S_T - S_avg, 0).'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'OTC con confirmación ISDA. Fechas de observación claramente definidas (ej. fixing de las 16:00 de cada día hábil).',
                    s4_2: 'Muy líquido en mercados de energía (WTI, Brent, Gas Natural). Común en FX para tesorerías.',
                    s4_3: 'Liquidez menor que vanilla pero mayor que otras exóticas. Spreads razonables en subyacentes líquidos.'
                },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'Instrumento dominante en hedging de commodities. Datos específicos de volumen: PENDING_VERIFICATION.',
                    s5_2: 'Esencial para empresas con consumo/producción continua que necesitan cubrir precio promedio, no precio puntual.',
                    s5_3: 'Aerolíneas (jet fuel), refinerías, traders de commodities, tesorerías de multinacionales.'
                },
                s6: {
                    title: '6. Ejemplo numérico',
                    s6_1: 'Asian Call Aritmético: S₀=100, K=100, T=1 año, r=5%, σ=20%, 12 observaciones mensuales.',
                    s6_2: 'Volatilidad del promedio ≈ σ/√3 = 11.5% para averaging continuo. Precio Asian ≈ 4.5 vs Vanilla ≈ 8.9 (50% ahorro).',
                    s6_3: 'El ahorro viene de que el promedio tiene mucha menos varianza que el precio final. A más observaciones, menor volatilidad del promedio.'
                },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Cobertura de flujos de caja continuos: aerolínea que compra jet fuel cada semana cubre el precio promedio del mes.',
                    s7_2: 'Reducir coste de cobertura cuando el riesgo real es sobre un promedio, no sobre un precio puntual.',
                    s7_3: 'Evitar manipulación del precio de vencimiento (importante en mercados menos líquidos).',
                    s7_4: 'Matching con contabilidad: muchas empresas reportan costes promedio, no costes puntuales.'
                },
                s8: {
                    title: '8. Ventajas y limitaciones',
                    s8_1: 'Prima ~50% menor que vanilla. Cobertura más ajustada al riesgo real de empresas con exposición continua. Inmune a manipulación puntual.',
                    s8_2: 'No protege contra picos de precio (solo promedio). Más compleja de valorar (no hay fórmula cerrada exacta para aritmética). Basis risk si el averaging no coincide con exposición real.'
                },
                s9: {
                    title: '9. Riesgos financieros asociados',
                    mercado: 'Delta decrece a medida que se acumulan observaciones ("delta bleed"). Vega menor que vanilla. Theta más suave.',
                    credito: 'Riesgo OTC estándar. Mitigado con CSA.',
                    liquidez: 'Menor que vanilla. Difícil ajustar posición a mitad del período de averaging.',
                    operacional: 'Definición precisa de observaciones (hora, fuente de precio, días festivos). Errores pueden causar disputas.',
                    correlacion: 'N/A para single-asset.'
                },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'Geométrica: Fórmula cerrada (Kemna-Vorst 1990). Aritmética: Aproximación de momentos (Turnbull-Wakeman) o Monte Carlo.',
                    variables: 'S₀, K, T, r, q, σ, n (número de observaciones), promedio ya fijado (si está a mitad de vida).',
                    griegas: 'Delta: Decrece linealmente con observaciones fijadas. Vega: Menor que vanilla (≈ Vega_vanilla × √(T_restante/T_total)). Gamma: Bajo.',
                    ejemplo: 'Volatilidad efectiva del promedio aritmético ≈ σ × √[(1/T) × ∫(T-t)²dt] ≈ σ/√3 para averaging continuo desde t=0 hasta T.'
                },
                s11: {
                    title: '11. Aplicaciones profesionales',
                    caso: 'Aerolínea cubre consumo de 1M barriles/mes de jet fuel con Asian Put mensual. Coste de cobertura 50% menor que con vanilla puts semanales.',
                    historico: 'Desarrolladas originalmente para el mercado de commodities japonés ("Asian" options). Ahora estándar global en energía.',
                    conclusion: 'Instrumento ideal para hedgers con exposición continua. Requiere entender que protege promedios, no picos.'
                }
            },
            '2.3.4.1': { // Cash-or-Nothing
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Opción binaria que paga una cantidad fija Q si el subyacente termina ITM, o cero si termina OTM. Payoff Call: Q × 𝟙{S_T > K}. Payoff Put: Q × 𝟙{S_T < K}. No hay proporcionalidad con cuánto ITM esté.',
                    s1_2: 'Derivado no lineal, exótico, digital/binario.',
                    s1_3: 'OTC principalmente. También en mercados de retail (opciones binarias reguladas) y como componente de estructurados.',
                    s1_4: 'También existe Asset-or-Nothing (paga S_T si ITM, 0 si OTM). Relación: Vanilla Call = Asset-or-Nothing Call - K × Cash-or-Nothing Call.'
                },
                s2: {
                    title: '2. Estructura contractual',
                    s2_1: 'Comprador (paga prima, recibe Q si ITM) y Vendedor (recibe prima, paga Q si ITM).',
                    s2_2: 'Equity, FX, Índices, Commodities. Cualquier subyacente con precio observable.',
                    s2_3: 'Payout fijo Q (ej. 100 USD, 1000 EUR). No depende del nocional tradicional.',
                    s2_4: 'Tipo (Call/Put), Strike K, Payout Q, Vencimiento. Puede ser europea o americana (one-touch).'
                },
                s3: {
                    title: '3. Forma de liquidación',
                    s3_1: 'Cash settlement. Binario: paga Q o paga 0. No hay entrega física.',
                    s3_2: 'Única al vencimiento (europea) o al tocar strike (one-touch/americana).',
                    s3_3: 'Digital Call: Si S_T > K → Pago = Q. Si S_T ≤ K → Pago = 0. Sin términos intermedios.'
                },
                s4: {
                    title: '4. Mercado y fechas relevantes',
                    s4_1: 'OTC para institucionales. Plataformas reguladas para retail (con restricciones en EU desde 2018).',
                    s4_2: 'Común en FX y equity. Base de muchos productos estructurados (cupones digitales).',
                    s4_3: 'Liquidez moderada. Los dealers cotizan pero con spreads amplios cerca del strike.'
                },
                s5: {
                    title: '5. Volumen de negociación y relevancia económica',
                    s5_1: 'Componente fundamental de productos estructurados. Datos específicos: PENDING_VERIFICATION.',
                    s5_2: 'Usado como building block: Autocalls, Range Accruals, y notas con cupones digitales se construyen con digitales.',
                    s5_3: 'Bancos de inversión (pricing de estructurados), Hedge Funds, y desafortunadamente retail especulativo.'
                },
                s6: {
                    title: '6. Ejemplo numérico',
                    s6_1: 'Digital Call: S₀=100, K=100, Q=10 USD, T=0.25, r=5%, σ=20%.',
                    s6_2: 'Precio = e^(-rT) × Q × N(d₂) = e^(-0.05×0.25) × 10 × N(0.175) = 9.88 × 0.5695 = 5.63 USD.',
                    s6_3: 'd₂ = [ln(S/K) + (r - σ²/2)T] / (σ√T) = [0 + (0.05-0.02)×0.25] / (0.2×0.5) = 0.075/0.1 = 0.75. Probabilidad risk-neutral de ITM ≈ 57%.'
                },
                s7: {
                    title: '7. Usos y funciones principales',
                    s7_1: 'Apuestas binarias sobre eventos de mercado (S > K o no). Simple de entender para cliente retail.',
                    s7_2: 'Componente de estructurados: Cupones digitales ("si IBEX > 10000, cupón 5%, sino 0%").',
                    s7_3: 'Arbitraje con vanilla: Un call spread super-replicado con digitales debe tener mismo precio si no hay arb.',
                    s7_4: 'Hedging de eventos binarios: Fusiones (si se aprueba/si no), elecciones, decisiones de bancos centrales.'
                },
                s8: {
                    title: '8. Ventajas y limitaciones',
                    s8_1: 'Payoff simple y predecible (Q o 0). Perfecto para estructurar cupones condicionados. Prima barata si OTM.',
                    s8_2: 'Delta → ∞ cerca de vencimiento si ATM (hedging imposible). Muy sensible a volatilidad cerca del strike. Riesgo de "pin" al strike.'
                },
                s9: {
                    title: '9. Riesgos financieros asociados',
                    mercado: 'Delta = e^(-rT) × Q × n(d₂)/(S×σ√T), explota cerca de ATM en vencimiento. Gamma extremo. Vega cambia de signo en el strike.',
                    credito: 'Riesgo OTC estándar.',
                    liquidez: 'Difícil de cerrar cerca de vencimiento si ATM. Spreads enormes.',
                    operacional: 'Definición precisa del fixing (hora exacta, fuente). Disputas comunes por diferencias de milisegundos.',
                    correlacion: 'N/A para single-asset.'
                },
                s10: {
                    title: '10. Valoración y métricas cuantitativas',
                    principio: 'Fórmula cerrada Black-Scholes: Digital_Call = e^(-rT) × Q × N(d₂). Réplica: Límite de call spread estrecho.',
                    variables: 'S (spot), K (strike), T (tiempo), r (tasa), σ (volatilidad), Q (payout).',
                    griegas: 'Delta = e^(-rT) × Q × n(d₂)/(Sσ√T). Vega tiene forma de "S" (positivo OTM, negativo ITM). Theta muy negativo cerca de vencimiento si ATM.',
                    ejemplo: 'Réplica con call spread: Digital_Call(K) ≈ [C(K-ε) - C(K+ε)]/(2ε) × Q, cuando ε→0. En práctica, usar ε=0.01×K.'
                },
                s11: {
                    title: '11. Aplicaciones profesionales',
                    caso: 'Banco estructura nota con cupón digital: "Si Euro Stoxx > nivel inicial en fecha de observación, cupón 8%, sino 1%". Precio digital embebido financia el cupón extra.',
                    historico: 'Mercado retail de opciones binarias (Binary Options) creció explosivamente 2010-2018, luego regulado/prohibido en EU por pérdidas de inversores (ESMA 2018).',
                    conclusion: 'Instrumento esencial para estructuración pero peligroso cerca del strike. Hedging de digitales ATM es uno de los problemas más difíciles en trading de volatilidad.'
                }
            },
            '3.1.1.1': { // Autocall
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Producto estrella de la Banca Privada. Paga cupones periódicos altos condicionada a que ningún subyacente caiga por debajo de una barrera (Coupon Barrier). Si en fecha de observación todos los activos > Strike inicial, el producto cancela anticipadamente y devuelve 100% + Cupón.',
                    s1_2: 'Estructurado.',
                    s1_3: 'OTC (emitido por bancos).',
                    s1_4: 'Capital protegido al vencimiento si no toca la Barrera de Protección (Knock-In ~60%). Si la toca, el inversor recibe el peor activo (Worst-of).'
                },
                s2: { title: '2. Estructura contractual', s2_1: 'Emisor (banco) e inversor.', s2_2: 'Cesta de acciones o índices.', s2_3: 'Pendiente de fuentes', s2_4: 'Pendiente de fuentes' },
                s3: { title: '3. Forma de liquidación', s3_1: 'Cash o entrega física del worst-of.', s3_2: 'Periódica (cupones) o única (cancelación).', s3_3: 'Pendiente de fuentes' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'Banca Privada.', s4_3: 'Pendiente de fuentes' },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'Pendiente de fuentes', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Pendiente de fuentes', s6_2: 'Pendiente de fuentes', s6_3: 'Pendiente de fuentes' },
                s7: { title: '7. Usos y funciones principales', s7_1: 'Pendiente de fuentes', s7_2: 'Venta de volatilidad y correlación implícita.', s7_3: 'Pendiente de fuentes', s7_4: 'Pendiente de fuentes' },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Cupones altos.', s8_2: 'Riesgo de pérdida de capital si hay market crash.' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Venta de volatilidad y correlación implícita.', credito: 'Riesgo emisor.', liquidez: 'Baja (producto a vencimiento).', operacional: 'Pendiente de fuentes', correlacion: 'Alto.' },
                s10: { title: '10. Valoración y métricas cuantitativas', principio: 'Monte Carlo path-dependent.', variables: 'Pendiente de fuentes', griegas: 'Pendiente de fuentes', ejemplo: 'Pendiente de fuentes' },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            },
            '3.1.3.1': { // Range Accrual
                s1: {
                    title: '1. Definición y naturaleza del contrato',
                    s1_1: 'Nota que paga un cupón alto (ej. 6%) por cada día que el Euribor se mantiene dentro de un rango (ej. 0% - 4%). Payoff diarios: Cupón × (n/N) (días dentro / días totales).',
                    s1_2: 'Estructurado.',
                    s1_3: 'OTC.',
                    s1_4: 'Pendiente de fuentes'
                },
                s2: { title: '2. Estructura contractual', s2_1: 'Pendiente de fuentes', s2_2: 'Tipo de interés (Euribor, SOFR).', s2_3: 'Pendiente de fuentes', s2_4: 'Pendiente de fuentes' },
                s3: { title: '3. Forma de liquidación', s3_1: 'Financiera.', s3_2: 'Periódica (cupón acumulado).', s3_3: 'Cupón × (días dentro / días totales).' },
                s4: { title: '4. Mercado y fechas relevantes', s4_1: 'Pendiente de fuentes', s4_2: 'Pendiente de fuentes', s4_3: 'Pendiente de fuentes' },
                s5: { title: '5. Volumen de negociación y relevancia económica', s5_1: 'Pendiente de fuentes', s5_2: 'Pendiente de fuentes', s5_3: 'Pendiente de fuentes' },
                s6: { title: '6. Ejemplo numérico', s6_1: 'Cupón 6%. Rango 0%-4%. Si Euribor está dentro 250 de 365 días.', s6_2: 'Cupón pagado = 6% × (250/365) = 4.11%.', s6_3: 'Pendiente de fuentes' },
                s7: { title: '7. Usos y funciones principales', s7_1: 'Pendiente de fuentes', s7_2: 'Apostar a estabilidad de tipos.', s7_3: 'Pendiente de fuentes', s7_4: 'Pendiente de fuentes' },
                s8: { title: '8. Ventajas y limitaciones', s8_1: 'Cupón potencialmente alto.', s8_2: 'Cupón reducido si tipos salen del rango.' },
                s9: { title: '9. Riesgos financieros asociados', mercado: 'Sensibilidad a la volatilidad de tipos.', credito: 'Pendiente de fuentes', liquidez: 'Pendiente de fuentes', operacional: 'Pendiente de fuentes', correlacion: 'Pendiente de fuentes' },
                s10: { title: '10. Valoración y métricas cuantitativas', principio: 'Monte Carlo o modelo de tipos con calibración a swaptions.', variables: 'Pendiente de fuentes', griegas: 'Pendiente de fuentes', ejemplo: 'Pendiente de fuentes' },
                s11: { title: '11. Aplicaciones profesionales', caso: 'Pendiente de fuentes', historico: 'Pendiente de fuentes', conclusion: 'Pendiente de fuentes' }
            }
        };

        // Helper function to calculate MICRO coverage
        function getMicroCoverage(leafId) {
            const data = microDataByLeafId[leafId];
            if (!data) return { completed: 0, total: 39, percentage: 0 };
            let completed = 0;
            const total = 39;
            const checkValue = (v) => v && v !== 'Pendiente de fuentes';
            // Check all subsections
            Object.keys(data).forEach(sKey => {
                if (sKey.startsWith('s')) {
                    const section = data[sKey];
                    Object.keys(section).forEach(subKey => {
                        if (subKey !== 'title' && checkValue(section[subKey])) completed++;
                    });
                }
            });
            return { completed, total, percentage: Math.round((completed / total) * 100) };
        }

        // ========== ENGINE PARAMETERS DEFINITION ==========
        const engineParams = {
            linear: [
                { id: 'S', label: 'Spot Price', unit: 'USD', default: 100, min: 0.01 },
                { id: 'K', label: 'Forward/Strike', unit: 'USD', default: 102, min: 0.01 },
                { id: 'T', label: 'Time to Maturity', unit: 'years', default: 0.25, min: 0.001, max: 30 },
                { id: 'r', label: 'Risk-Free Rate', unit: '%', default: 5, min: -5, max: 50 },
                { id: 'q', label: 'Dividend Yield', unit: '%', default: 2, min: 0, max: 30 }
            ],
            bsm: [
                { id: 'S', label: 'Spot Price', unit: 'USD', default: 100, min: 0.01 },
                { id: 'K', label: 'Strike Price', unit: 'USD', default: 100, min: 0.01 },
                { id: 'T', label: 'Time to Expiry', unit: 'years', default: 0.25, min: 0, max: 30 },
                { id: 'r', label: 'Risk-Free Rate', unit: '%', default: 5, min: -5, max: 50 },
                { id: 'sigma', label: 'Volatility', unit: '%', default: 20, min: 0.1, max: 200 },
                { id: 'q', label: 'Dividend Yield', unit: '%', default: 0, min: 0, max: 30 }
            ],
            garman: [
                { id: 'S', label: 'Spot FX Rate', unit: 'CCY', default: 1.10, min: 0.01 },
                { id: 'K', label: 'Strike', unit: 'CCY', default: 1.10, min: 0.01 },
                { id: 'T', label: 'Time to Expiry', unit: 'years', default: 0.25, min: 0, max: 30 },
                { id: 'r_d', label: 'Domestic Rate', unit: '%', default: 5, min: -5, max: 50 },
                { id: 'r_f', label: 'Foreign Rate', unit: '%', default: 3, min: -5, max: 50 },
                { id: 'sigma', label: 'Volatility', unit: '%', default: 10, min: 0.1, max: 100 }
            ],
            barrierMC: [
                { id: 'S', label: 'Spot Price', unit: 'USD', default: 100, min: 0.01 },
                { id: 'K', label: 'Strike Price', unit: 'USD', default: 100, min: 0.01 },
                { id: 'B', label: 'Barrier Level', unit: 'USD', default: 90, min: 0.01 },
                { id: 'T', label: 'Time to Expiry', unit: 'years', default: 0.25, min: 0.01, max: 5 },
                { id: 'r', label: 'Risk-Free Rate', unit: '%', default: 5, min: -5, max: 50 },
                { id: 'sigma', label: 'Volatility', unit: '%', default: 20, min: 0.1, max: 100 },
                { id: 'nPaths', label: 'Monte Carlo Paths', unit: '', default: 10000, min: 1000, max: 100000 }
            ],
            cfd: [
                { id: 'S0', label: 'Entry Price', unit: 'USD', default: 100, min: 0.01 },
                { id: 'S1', label: 'Current/Exit Price', unit: 'USD', default: 105, min: 0.01 },
                { id: 'qty', label: 'Quantity', unit: 'units', default: 100, min: 1 }
            ],
            trs: [
                { id: 'notional', label: 'Notional', unit: 'USD', default: 1000000, min: 1 },
                { id: 'returnPct', label: 'Underlying Return', unit: '%', default: 8, min: -100, max: 200 },
                { id: 'fundingRate', label: 'Funding Rate', unit: '%', default: 5, min: -5, max: 50 },
                { id: 'T', label: 'Tenor', unit: 'years', default: 1, min: 0.01, max: 30 }
            ],
            digital: [
                { id: 'S', label: 'Spot Price', unit: 'USD', default: 100, min: 0.01 },
                { id: 'K', label: 'Strike', unit: 'USD', default: 100, min: 0.01 },
                { id: 'T', label: 'Time to Expiry', unit: 'years', default: 0.25, min: 0, max: 30 },
                { id: 'r', label: 'Risk-Free Rate', unit: '%', default: 5, min: -5, max: 50 },
                { id: 'sigma', label: 'Volatility', unit: '%', default: 20, min: 0.1, max: 200 },
                { id: 'payout', label: 'Digital Payout', unit: 'USD', default: 1, min: 0.01 }
            ],
            asianMC: [
                { id: 'S', label: 'Spot Price', unit: 'USD', default: 100, min: 0.01 },
                { id: 'K', label: 'Strike', unit: 'USD', default: 100, min: 0.01 },
                { id: 'T', label: 'Time to Expiry', unit: 'years', default: 0.5, min: 0.01, max: 5 },
                { id: 'r', label: 'Risk-Free Rate', unit: '%', default: 5, min: -5, max: 50 },
                { id: 'sigma', label: 'Volatility', unit: '%', default: 20, min: 0.1, max: 100 },
                { id: 'nPaths', label: 'Monte Carlo Paths', unit: '', default: 10000, min: 1000, max: 100000 },
                { id: 'nSteps', label: 'Averaging Steps', unit: '', default: 12, min: 2, max: 252 }
            ]
        };

        // ========== APPLICATION STATE ==========
        const state = {
            page: 'taxonomy',
            selectedNode: null,
            expandedNodes: new Set(['1', '2', '3']),
            params: {},
            position: 'long',
            diagExpanded: true,
            activeTab: 'pricing',
            wbAutoScale: true,
            wbRange: { min: null, max: null },
            taxonomyView: 'overview'
        };

        // ========== MATH UTILITIES ==========
        function normalCDF(x) {
            const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
            const a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2);
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return 0.5 * (1.0 + sign * y);
        }

        function normalPDF(x) {
            return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
        }

        // ========== INPUT UTILITIES ==========
        /**
         * Safely parse a float with fallback, bounds clamping, and validation.
         * @param {string|number} value - The value to parse
         * @param {number} defaultVal - Default value if parsing fails
         * @param {number} [min] - Minimum allowed value
         * @param {number} [max] - Maximum allowed value
         * @returns {number} - Parsed and clamped value
         */
        function safeParseFloat(value, defaultVal, min, max) {
            // Normalize European decimal comma to point (e.g., "0,25" -> "0.25")
            const normalized = String(value).replace(',', '.');
            let num = parseFloat(normalized);
            if (isNaN(num) || !isFinite(num)) {
                num = defaultVal;
            }
            if (typeof min === 'number' && num < min) {
                num = min;
            }
            if (typeof max === 'number' && num > max) {
                num = max;
            }
            return num;
        }

        /**
         * Validate pricing parameters and return errors if any.
         * @param {Object} params - Parameters object
         * @returns {string|null} - Error message or null if valid
         */
        function validatePricingParams(params) {
            const errors = [];
            if (params.S !== undefined && params.S <= 0) errors.push('Spot (S) must be positive');
            if (params.K !== undefined && params.K <= 0) errors.push('Strike (K) must be positive');
            if (params.T !== undefined && params.T < 0) errors.push('Time (T) cannot be negative');
            if (params.sigma !== undefined && params.sigma <= 0) errors.push('Volatility (σ) must be positive');
            return errors.length > 0 ? errors.join('; ') : null;
        }

        // ========== PRICING ENGINES ==========
        const PricingEngines = {
            // Black-Scholes-Merton
            bsm: function (params, optionType = 'call') {
                let { S, K, T, r, sigma, q } = params;
                r = r / 100; sigma = sigma / 100; q = (q || 0) / 100;

                if (S <= 0 || K <= 0 || sigma <= 0) {
                    return { price: NaN, greeks: {}, error: 'Invalid inputs: S, K, σ must be positive' };
                }

                // Edge case: T = 0 (at expiration)
                if (T <= 0.0001) {
                    const intrinsic = optionType === 'call' ? Math.max(S - K, 0) : Math.max(K - S, 0);
                    return {
                        price: intrinsic,
                        d1: NaN, d2: NaN,
                        greeks: {
                            delta: optionType === 'call' ? (S > K ? 1 : 0) : (S < K ? -1 : 0),
                            gamma: 0, theta: 0, vega: 0, rho: 0
                        }
                    };
                }

                const d1 = (Math.log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
                const d2 = d1 - sigma * Math.sqrt(T);

                let price, delta, rho;
                const Nd1 = normalCDF(d1);
                const Nd2 = normalCDF(d2);
                const nd1 = normalPDF(d1);
                const discountFactor = Math.exp(-r * T);
                const dividendFactor = Math.exp(-q * T);

                if (optionType === 'call') {
                    price = S * dividendFactor * Nd1 - K * discountFactor * Nd2;
                    delta = dividendFactor * Nd1;
                    rho = K * T * discountFactor * Nd2 / 100;
                } else {
                    price = K * discountFactor * normalCDF(-d2) - S * dividendFactor * normalCDF(-d1);
                    delta = -dividendFactor * normalCDF(-d1);
                    rho = -K * T * discountFactor * normalCDF(-d2) / 100;
                }

                const gamma = dividendFactor * nd1 / (S * sigma * Math.sqrt(T));
                const vega = S * dividendFactor * nd1 * Math.sqrt(T) / 100;
                const theta = ((-S * dividendFactor * nd1 * sigma) / (2 * Math.sqrt(T))
                    - r * K * discountFactor * (optionType === 'call' ? Nd2 : -normalCDF(-d2))
                    + q * S * dividendFactor * (optionType === 'call' ? Nd1 : -normalCDF(-d1))) / 365;

                return {
                    price: price,
                    d1: d1, d2: d2,
                    greeks: { delta, gamma, theta, vega, rho }
                };
            },

            // Garman-Kohlhagen for FX options
            garman: function (params, optionType = 'call') {
                let { S, K, T, r_d, r_f, sigma } = params;
                r_d = r_d / 100; r_f = r_f / 100; sigma = sigma / 100;

                if (T <= 0.0001) {
                    const intrinsic = optionType === 'call' ? Math.max(S - K, 0) : Math.max(K - S, 0);
                    return { price: intrinsic, greeks: { delta: optionType === 'call' ? 1 : -1, gamma: 0, theta: 0, vega: 0, rho: 0 } };
                }

                const d1 = (Math.log(S / K) + (r_d - r_f + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
                const d2 = d1 - sigma * Math.sqrt(T);

                if (optionType === 'call') {
                    const price = S * Math.exp(-r_f * T) * normalCDF(d1) - K * Math.exp(-r_d * T) * normalCDF(d2);
                    return { price, d1, d2, greeks: { delta: Math.exp(-r_f * T) * normalCDF(d1), gamma: 0, theta: 0, vega: 0, rho: 0 } };
                } else {
                    const price = K * Math.exp(-r_d * T) * normalCDF(-d2) - S * Math.exp(-r_f * T) * normalCDF(-d1);
                    return { price, d1, d2, greeks: { delta: -Math.exp(-r_f * T) * normalCDF(-d1), gamma: 0, theta: 0, vega: 0, rho: 0 } };
                }
            },

            // Black-76 (opciones sobre forward/futuros)
            black76: function (params, optionType = 'call') {
                let { F, K, T, r, sigma } = params;
                r = r / 100; sigma = sigma / 100;
                if (!F || F <= 0 || !K || K <= 0 || sigma <= 0) return { price: NaN, greeks: {}, error: 'Inputs inválidos' };
                if (T <= 0.0001) {
                    const intrinsic = optionType === 'call' ? Math.max(F - K, 0) : Math.max(K - F, 0);
                    return { price: intrinsic * Math.exp(-r * T), greeks: {} };
                }
                const d1 = (Math.log(F / K) + 0.5 * sigma * sigma * T) / (sigma * Math.sqrt(T));
                const d2 = d1 - sigma * Math.sqrt(T);
                const disc = Math.exp(-r * T);
                const price = optionType === 'call'
                    ? disc * (F * normalCDF(d1) - K * normalCDF(d2))
                    : disc * (K * normalCDF(-d2) - F * normalCDF(-d1));
                return { price, d1, d2, greeks: {} };
            },

            // Árbol binomial (CRR) europeo
            binomial: function (params, optionType = 'call') {
                let { S, K, T, r, sigma, q, steps } = params;
                r = r / 100; sigma = sigma / 100; q = (q || 0) / 100;
                steps = Math.min(Math.max(parseInt(steps, 10) || 100, 1), 500);
                if (S <= 0 || K <= 0 || sigma <= 0) return { price: NaN, error: 'Inputs inválidos' };
                if (T <= 0.0001) {
                    const intrinsic = optionType === 'call' ? Math.max(S - K, 0) : Math.max(K - S, 0);
                    return { price: intrinsic, greeks: {} };
                }
                const dt = T / steps;
                const u = Math.exp(sigma * Math.sqrt(dt));
                const d = 1 / u;
                const disc = Math.exp(-r * dt);
                const p = (Math.exp((r - q) * dt) - d) / (u - d);
                if (p < 0 || p > 1) return { price: NaN, error: 'Probabilidad fuera de rango (revisar σ/T)' };
                const values = [];
                for (let i = 0; i <= steps; i++) {
                    const St = S * Math.pow(u, i) * Math.pow(d, steps - i);
                    values[i] = optionType === 'call' ? Math.max(St - K, 0) : Math.max(K - St, 0);
                }
                for (let step = steps - 1; step >= 0; step--) {
                    for (let i = 0; i <= step; i++) {
                        values[i] = disc * (p * values[i + 1] + (1 - p) * values[i]);
                    }
                }
                return { price: values[0], greeks: {} };
            },

            // Linear pricing for forwards
            linear: function (params) {
                let { S, K, T, r, q } = params;
                r = r / 100; q = (q || 0) / 100;
                const forwardPrice = S * Math.exp((r - q) * T);
                const mtm = (forwardPrice - K) * Math.exp(-r * T);
                return { price: mtm, fairForward: forwardPrice, greeks: { delta: Math.exp(-q * T), gamma: 0, theta: 0, vega: 0, rho: 0 } };
            },

            // CFD P&L
            cfd: function (params) {
                const { S0, S1, qty } = params;
                const pnl = (S1 - S0) * qty;
                return { price: pnl, greeks: { delta: qty, gamma: 0, theta: 0, vega: 0, rho: 0 } };
            },

            // Total Return Swap
            trs: function (params) {
                let { notional, returnPct, fundingRate, T } = params;
                returnPct = returnPct / 100; fundingRate = fundingRate / 100;
                const totalReturn = notional * returnPct * T;
                const fundingCost = notional * fundingRate * T;
                const netPnL = totalReturn - fundingCost;
                return { price: netPnL, totalReturn, fundingCost, greeks: { delta: notional, gamma: 0, theta: 0, vega: 0, rho: 0 } };
            },

            // Digital option
            digital: function (params, optionType = 'call') {
                let { S, K, T, r, sigma, payout } = params;
                r = r / 100; sigma = sigma / 100;

                if (T <= 0.0001) {
                    const itm = optionType === 'call' ? (S > K) : (S < K);
                    return { price: itm ? payout * Math.exp(-r * T) : 0, greeks: { delta: 0, gamma: 0, theta: 0, vega: 0, rho: 0 } };
                }

                const d2 = (Math.log(S / K) + (r - 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
                const discountedPayout = payout * Math.exp(-r * T);
                const price = optionType === 'call' ? discountedPayout * normalCDF(d2) : discountedPayout * normalCDF(-d2);
                return { price, greeks: { delta: 0, gamma: 0, theta: 0, vega: 0, rho: 0 } };
            },

            // Monte Carlo for barrier options
            barrierMC: function (params, optionType = 'call', barrierType = 'down-out') {
                let { S, K, B, T, r, sigma, nPaths } = params;
                r = r / 100; sigma = sigma / 100;
                nPaths = Math.min(nPaths || 10000, 50000);
                const nSteps = Math.max(50, Math.floor(T * 252));
                const dt = T / nSteps;

                let payoffSum = 0;
                for (let i = 0; i < nPaths; i++) {
                    let St = S;
                    let knocked = false;
                    for (let j = 0; j < nSteps; j++) {
                        const z = (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() - 3) * Math.sqrt(2);
                        St *= Math.exp((r - 0.5 * sigma * sigma) * dt + sigma * Math.sqrt(dt) * z);
                        if (barrierType === 'down-out' && St <= B) { knocked = true; break; }
                        if (barrierType === 'up-out' && St >= B) { knocked = true; break; }
                    }
                    if (!knocked) {
                        const payoff = optionType === 'call' ? Math.max(St - K, 0) : Math.max(K - St, 0);
                        payoffSum += payoff;
                    }
                }
                const price = Math.exp(-r * T) * (payoffSum / nPaths);
                return { price, nPaths, greeks: { delta: 0, gamma: 0, theta: 0, vega: 0, rho: 0 } };
            },

            // Monte Carlo for Asian options
            asianMC: function (params, optionType = 'call') {
                let { S, K, T, r, sigma, nPaths, nSteps } = params;
                r = r / 100; sigma = sigma / 100;
                nPaths = Math.min(nPaths || 10000, 50000);
                nSteps = nSteps || 12;
                const dt = T / nSteps;

                let payoffSum = 0;
                for (let i = 0; i < nPaths; i++) {
                    let St = S;
                    let avgSum = S;
                    for (let j = 0; j < nSteps; j++) {
                        const z = (Math.random() + Math.random() + Math.random() + Math.random() + Math.random() + Math.random() - 3) * Math.sqrt(2);
                        St *= Math.exp((r - 0.5 * sigma * sigma) * dt + sigma * Math.sqrt(dt) * z);
                        avgSum += St;
                    }
                    const avgPrice = avgSum / (nSteps + 1);
                    const payoff = optionType === 'call' ? Math.max(avgPrice - K, 0) : Math.max(K - avgPrice, 0);
                    payoffSum += payoff;
                }
                const price = Math.exp(-r * T) * (payoffSum / nPaths);
                return { price, nPaths, greeks: { delta: 0, gamma: 0, theta: 0, vega: 0, rho: 0 } };
            }
        };

        // ========== DIAGNOSTICS TEST SUITE ==========
        function runDiagnostics() {
            const results = [];
            const ε = 0.0001;

            // Test 1: Put-Call Parity
            const pcParams = { S: 100, K: 100, T: 0.25, r: 5, sigma: 20, q: 0 };
            const call = PricingEngines.bsm(pcParams, 'call');
            const put = PricingEngines.bsm(pcParams, 'put');
            const S = pcParams.S, K = pcParams.K, T = pcParams.T, r = pcParams.r / 100;
            const parity = call.price - put.price - (S - K * Math.exp(-r * T));
            results.push({
                name: 'Put-Call Parity (BSM)',
                test: '|C - P - (S - K·e^(-rT))| < ε',
                expected: '≈ 0',
                actual: parity.toFixed(6),
                pass: Math.abs(parity) < ε
            });

            // Test 2: Delta finite difference
            const h = 0.01;
            const callUp = PricingEngines.bsm({ ...pcParams, S: pcParams.S + h }, 'call');
            const callDown = PricingEngines.bsm({ ...pcParams, S: pcParams.S - h }, 'call');
            const deltaFD = (callUp.price - callDown.price) / (2 * h);
            const deltaAnalytic = call.greeks.delta;
            results.push({
                name: 'Delta Finite Difference',
                test: '|Δ_FD - Δ_analytic| < 0.001',
                expected: deltaAnalytic.toFixed(4),
                actual: deltaFD.toFixed(4),
                pass: Math.abs(deltaFD - deltaAnalytic) < 0.001
            });

            // Test 3: Gamma finite difference
            const gammaFD = (callUp.price - 2 * call.price + callDown.price) / (h * h);
            const gammaAnalytic = call.greeks.gamma;
            results.push({
                name: 'Gamma Finite Difference',
                test: '|Γ_FD - Γ_analytic| < 0.001',
                expected: gammaAnalytic.toFixed(4),
                actual: gammaFD.toFixed(4),
                pass: Math.abs(gammaFD - gammaAnalytic) < 0.001
            });

            // Test 4: T=0 Edge Case (intrinsic value)
            const atmCall = PricingEngines.bsm({ S: 110, K: 100, T: 0, r: 5, sigma: 20, q: 0 }, 'call');
            results.push({
                name: 'T=0 ITM Call Intrinsic',
                test: 'Price = max(S-K, 0) = 10',
                expected: '10.0000',
                actual: atmCall.price.toFixed(4),
                pass: Math.abs(atmCall.price - 10) < 0.0001
            });

            // Test 5: OTM at expiry
            const otmPut = PricingEngines.bsm({ S: 110, K: 100, T: 0, r: 5, sigma: 20, q: 0 }, 'put');
            results.push({
                name: 'T=0 OTM Put Zero',
                test: 'Price = max(K-S, 0) = 0',
                expected: '0.0000',
                actual: otmPut.price.toFixed(4),
                pass: Math.abs(otmPut.price) < 0.0001
            });

            // Test 6: Input validation (negative S)
            const badResult = PricingEngines.bsm({ S: -100, K: 100, T: 0.25, r: 5, sigma: 20, q: 0 }, 'call');
            results.push({
                name: 'Input Validation (S<0)',
                test: 'Should return NaN/error',
                expected: 'NaN',
                actual: isNaN(badResult.price) ? 'NaN' : badResult.price.toFixed(4),
                pass: isNaN(badResult.price)
            });

            // Test 7: Long/Short sign consistency
            const longPrice = call.price;
            const shortPrice = -call.price;
            results.push({
                name: 'Long/Short Sign Flip',
                test: 'Short P&L = -Long P&L',
                expected: (-longPrice).toFixed(4),
                actual: shortPrice.toFixed(4),
                pass: Math.abs(shortPrice + longPrice) < ε
            });

            return results;
        }

        // ========== UI RENDERING ==========
        function renderTree(nodes, container, level = 0) {
            const ul = document.createElement('ul');
            nodes.forEach(node => {
                const li = document.createElement('li');
                const hasChildren = node.children && node.children.length > 0;
                const isExpanded = state.expandedNodes.has(node.id);
                const isSelected = state.selectedNode && state.selectedNode.id === node.id;
                const leafInfo = leafEngineMap[node.id];

                const nodeEl = document.createElement('div');
                nodeEl.className = 'tree-node' + (isSelected ? ' selected' : '');
                nodeEl.innerHTML = `
                <span class="caret ${hasChildren ? (isExpanded ? 'open' : '') : 'none'}">${hasChildren ? '▶' : ''}</span>
                <span class="node-id">${node.id}</span>
                <span>${node.label}</span>
                ${!hasChildren && leafInfo && !leafInfo.engineType ? '<span class="badge badge-warning" style="margin-left:auto;font-size:9px;">N/A</span>' : ''}
            `;

                nodeEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (hasChildren) {
                        if (isExpanded) state.expandedNodes.delete(node.id);
                        else state.expandedNodes.add(node.id);
                    }
                    state.selectedNode = node;
                    state.page = 'taxonomy';
                    render();
                });

                li.appendChild(nodeEl);
                if (hasChildren) {
                    const childContainer = document.createElement('div');
                    childContainer.className = 'tree-children' + (isExpanded ? ' open' : '');
                    renderTree(node.children, childContainer, level + 1);
                    li.appendChild(childContainer);
                }
                ul.appendChild(li);
            });
            container.appendChild(ul);
        }

        function renderTaxonomyPage() {
            const page = document.getElementById('page-taxonomy');
            if (!page) return;
            if (state.taxonomyView === 'overview') {
                page.innerHTML = `
                <div class="page-header">
                    <div class="page-breadcrumb">Derivatives Classification</div>
                    <h1 class="page-title">Taxonomy Explorer</h1>
                    <p class="page-subtitle">Select an instrument from the sidebar</p>
                </div>
                <div class="kpi-grid">
                    <div class="kpi"><div class="kpi-value">17</div><div class="kpi-label">Instruments</div></div>
                    <div class="kpi kpi-success"><div class="kpi-value">14</div><div class="kpi-label">Implemented</div></div>
                    <div class="kpi kpi-warning"><div class="kpi-value">3</div><div class="kpi-label">Pending</div></div>
                    <div class="kpi"><div class="kpi-value">7</div><div class="kpi-label">Engines</div></div>
                </div>`;
            } else if (state.selectedNode) {
                page.innerHTML = '';
                renderNodeDetail(page);
            } else {
                state.taxonomyView = 'overview';
                renderTaxonomyPage();
            }
        }

        function renderNodeDetail(container) {
            try {
                const node = state.selectedNode;
                if (!node) return;

                const hasChildren = node.children && node.children.length > 0;
                const leafInfo = (typeof leafEngineMap !== 'undefined') ? leafEngineMap[node.id] : null;
                const microData = (typeof microDataByLeafId !== 'undefined') ? microDataByLeafId[node.id] : null;
                const coverage = typeof getMicroCoverage === 'function' ? getMicroCoverage(node.id) : { percentage: 0, completed: 0, total: 0 };

                let content = `<div class="page-header">
                <div class="page-breadcrumb">Taxonomy › ${node.id}</div>
                <h1 class="page-title">${node.label}</h1>
                <div class="page-badges">
                    <span class="badge badge-primary">${node.id}</span>
                    ${!hasChildren ? (leafInfo && leafInfo.engineType ? `<span class="badge badge-success">Implemented</span>` : `<span class="badge badge-danger">Not Implemented</span>`) : `<span class="badge badge-neutral">Category</span>`}
                    ${!hasChildren && microData ? `<span class="badge" style="background:${coverage.percentage > 70 ? 'var(--success)' : coverage.percentage > 40 ? 'var(--warning)' : 'var(--danger)'};color:white;">MICRO ${coverage.completed}/${coverage.total}</span>` : ''}
                </div>
            </div>`;

                if (!hasChildren && leafInfo) {
                    content += `<div class="tab-nav" style="display:flex;gap:4px;margin-bottom:16px;">
                        <button class="tab-btn ${state.activeTab !== 'micro' ? 'active' : ''}" data-tab="pricing" style="padding:8px 16px;border:1px solid var(--border);background:${state.activeTab !== 'micro' ? 'var(--card)' : 'transparent'};color:var(--foreground);border-radius:6px;cursor:pointer;">📊 Pricing</button>
                        <button class="tab-btn ${state.activeTab === 'micro' ? 'active' : ''}" data-tab="micro" style="padding:8px 16px;border:1px solid var(--border);background:${state.activeTab === 'micro' ? 'var(--card)' : 'transparent'};color:var(--foreground);border-radius:6px;cursor:pointer;">📖 MICRO</button>
                    </div>`;

                    if (state.activeTab === 'micro' && microData) {
                        content += `<div class="micro-content">`;
                        if (typeof renderMicroSection === 'function') {
                            content += renderMicroSection(microData.s1, ['s1_1', 's1_2', 's1_3', 's1_4'], ['1.1 Qué es y qué función cumple', '1.2 Tipo de derivado', '1.3 Mercado: OTC o estandarizado', '1.4 Breve comparación con derivados similares']);
                            content += renderMicroSection(microData.s2, ['s2_1', 's2_2', 's2_3', 's2_4'], ['2.1 Partes intervinientes', '2.2 Subyacente', '2.3 Magnitud contractual', '2.4 Condiciones de ejecución y vencimiento']);
                            content += renderMicroSection(microData.s3, ['s3_1', 's3_2', 's3_3'], ['3.1 Liquidación física o por diferencias', '3.2 Frecuencia de pagos', '3.3 Ejemplo esquemático de flujo de caja']);
                            content += renderMicroSection(microData.s4, ['s4_1', 's4_2', 's4_3'], ['4.1 Fecha de contratación y vencimiento', '4.2 Tipo de mercado', '4.3 Liquidez, profundidad y estandarización']);
                            content += renderMicroSection(microData.s5, ['s5_1', 's5_2', 's5_3'], ['5.1 Tamaño del mercado global', '5.2 Peso relativo dentro de su categoría', '5.3 Actores principales']);
                            content += renderMicroSection(microData.s6, ['s6_1', 's6_2', 's6_3'], ['6.1 Datos del caso', '6.2 Cálculo paso a paso del payoff', '6.3 Interpretación económica']);
                            content += renderMicroSection(microData.s7, ['s7_1', 's7_2', 's7_3', 's7_4'], ['7.1 Cobertura (hedging)', '7.2 Especulación', '7.3 Arbitraje', '7.4 Gestión de balance y financiación']);
                            content += renderMicroSection(microData.s8, ['s8_1', 's8_2'], ['8.1 Beneficios', '8.2 Limitaciones o riesgos técnicos']);
                            content += renderMicroSection(microData.s9, ['mercado', 'credito', 'liquidez', 'operacional', 'correlacion'], ['Riesgo de mercado', 'Riesgo de crédito / contraparte', 'Riesgo de liquidez', 'Riesgo operacional / legal / de modelo', 'Riesgo de correlación']);
                            content += renderMicroSection(microData.s10, ['principio', 'variables', 'griegas', 'ejemplo'], ['Principio de valoración', 'Variables relevantes', 'Sensibilidades / Griegas', 'Ejemplo de valoración básica']);
                            content += renderMicroSection(microData.s11, ['caso', 'historico', 'conclusion'], ['Ejemplo de uso real', 'Referencias históricas', 'Conclusión institucional']);
                        }
                        content += `</div>`;
                    } else if (state.activeTab !== 'micro') {
                        if (!leafInfo.engineType) {
                            content += `<div class="card" style="background:var(--danger-muted);border-color:var(--danger);"><div class="card-header" style="color:var(--danger);">⚠️ NOT IMPLEMENTED</div><p>${leafInfo.reason}</p></div>`;
                        } else {
                            content += `<div class="card"><div class="card-header">⚙️ ${leafInfo.engineType.toUpperCase()} Engine</div><div class="params-grid" id="pricingInputsPlace">Loading inputs...</div><div style="margin-top:16px;"><button class="btn btn-primary" id="calcBtn">Calculate</button></div><div id="resultsContainer"></div></div>`;
                        }
                    }
                } else if (hasChildren) {
                    const catInfo = (typeof categoryDescriptions !== 'undefined') ? categoryDescriptions[node.id] : null;
                    if (catInfo) {
                        content += `<div class="card" style="margin-bottom:16px;"><div class="card-header">📚 Definición</div><p style="padding:16px;line-height:1.6;">${catInfo.definition}</p></div>`;
                        content += `<div class="card" style="margin-bottom:16px;"><div class="card-header">✅ Características</div><ul style="padding:16px 16px 16px 32px;">${catInfo.characteristics.map(c => `<li style="margin-bottom:8px;">${c}</li>`).join('')}</ul></div>`;
                        content += `<div class="card" style="margin-bottom:16px;"><div class="card-header">💡 Concepto Clave</div><p style="padding:16px;line-height:1.6;background:var(--M.G.Derivados-blue-muted);border-left:4px solid var(--M.G.Derivados-blue);">${catInfo.keyConcept}</p></div>`;
                        if (catInfo.diagram) {
                            content += `<div class="card" style="margin-bottom:16px;"><div class="card-header">📊 Diagrama</div><div class="mermaid" style="padding:16px;text-align:center;">${catInfo.diagram}</div></div>`;
                        }
                        content += `<div class="card"><div class="card-header">📂 Subcategorías</div><ul style="padding:16px 16px 16px 32px;">${node.children.map(c => `<li style="margin-bottom:8px;"><span class="node-id">${c.id}</span> ${c.label}</li>`).join('')}</ul></div>`;
                    } else {
                        content += `<div class="card"><div class="card-header">📂 Subcategories</div><ul style="padding-left:20px;">${node.children.map(c => `<li>${c.id} - ${c.label}</li>`).join('')}</ul></div>`;
                    }
                }

                container.innerHTML = content;

                // Re-attach listeners safely
                container.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        state.activeTab = btn.dataset.tab;
                        render();
                    });
                });
                // Accordion toggles
                container.querySelectorAll('.micro-accordion-header').forEach(header => {
                    header.addEventListener('click', () => {
                        const content = header.nextElementSibling;
                        const isOpen = content.style.display !== 'none';
                        content.style.display = isOpen ? 'none' : 'block';
                        header.querySelector('.accordion-icon').textContent = isOpen ? '▶' : '▼';
                    });
                });

                // Mermaid
                if (container.querySelectorAll('.mermaid').length > 0) {
                    try {
                        if (window.mermaid) {
                            mermaid.run({ nodes: container.querySelectorAll('.mermaid') });
                        } else {
                            console.warn('Mermaid no está disponible (render omitido).');
                        }
                    } catch (e) { console.log('Mermaid render:', e); }
                }

                // Pricing Inputs (Late Render)
                if (!hasChildren && leafInfo && leafInfo.engineType && state.activeTab !== 'micro') {
                    const paramsContainer = document.getElementById('pricingInputsPlace');
                    if (paramsContainer) {
                        const params = engineParams[leafInfo.engineType] || [];
                        paramsContainer.innerHTML = params.map(p => {
                            const val = state.params[p.id] !== undefined ? state.params[p.id] : p.default;
                            return `<div class="form-group"><label class="form-label">${p.label}</label><div class="form-input-wrapper"><input type="number" class="form-input" id="param-${p.id}" value="${val}" step="0.01">${p.unit ? `<span class="form-unit">${p.unit}</span>` : ''}</div></div>`;
                        }).join('');
                        // Re-bind inputs
                        params.forEach(p => {
                            const input = document.getElementById(`param-${p.id}`);
                            if (input) input.addEventListener('input', e => { state.params[p.id] = parseFloat(e.target.value) || 0; });
                        });
                    }
                    const calcBtn = document.getElementById('calcBtn');
                    const positionToggle = document.getElementById('positionToggle'); // Might be missing in this simplified string, but ok
                    if (calcBtn) calcBtn.addEventListener('click', calculateAndRender);
                }

            } catch (e) {
                console.error("Critical Render Error:", e);
                container.innerHTML = `<div class="card" style="border-color:red;color:red;padding:20px;">
                        <h3>⚠️ Error Rendering Page</h3>
                        <pre>${e.message}</pre>
                        <p>This section is temporarily unavailable.</p>
                    </div>`;
            }
        }

        function renderMicroSection(section, keys, labels) {
            if (!section) return '';
            const completedCount = keys.filter(k => section[k] && section[k] !== 'Pendiente de fuentes').length;
            const statusColor = completedCount === keys.length ? 'var(--success)' : completedCount > 0 ? 'var(--warning)' : 'var(--danger)';
            let html = `<div class="card" style="margin-bottom:8px;">
                <div class="micro-accordion-header" style="display:flex;justify-content:space-between;align-items:center;cursor:pointer;padding:12px;background:var(--muted);border-radius:6px;">
                    <span><span class="accordion-icon" style="margin-right:8px;">▼</span><strong>${section.title}</strong></span>
                    <span style="font-size:11px;color:${statusColor};">${completedCount}/${keys.length}</span>
                </div>
                <div class="micro-accordion-content" style="padding:12px;">`;
            keys.forEach((key, i) => {
                const value = section[key] || 'Pendiente de fuentes';
                const isPending = value === 'Pendiente de fuentes';
                html += `<div style="margin-bottom:8px;padding:8px;background:${isPending ? 'var(--danger-muted)' : 'var(--card)'};border-radius:4px;border-left:3px solid ${isPending ? 'var(--danger)' : 'var(--success)'};">
                    <div style="font-size:11px;color:var(--muted-foreground);margin-bottom:4px;">${labels[i]}</div>
                    <div style="font-size:13px;${isPending ? 'color:var(--danger);font-style:italic;' : ''}">${value}</div>
                </div>`;
            });
            html += `</div></div>`;
            return html;
        }


        function calculateAndRender() {
            const node = state.selectedNode;
            const leafInfo = leafEngineMap[node.id];
            if (!leafInfo || !leafInfo.engineType) return;
            const params = engineParams[leafInfo.engineType] || [];
            params.forEach(p => { const input = document.getElementById(`param-${p.id}`); if (input) state.params[p.id] = parseFloat(input.value) || 0; });

            let result;
            const engine = PricingEngines[leafInfo.engineType];
            if (!engine) return;
            if (leafInfo.engineType === 'bsm' || leafInfo.engineType === 'garman' || leafInfo.engineType === 'digital') result = engine(state.params, leafInfo.optionType || 'call');
            else if (leafInfo.engineType === 'barrierMC') result = engine(state.params, leafInfo.optionType || 'call', leafInfo.barrierType || 'down-out');
            else if (leafInfo.engineType === 'asianMC') result = engine(state.params, 'call');
            else result = engine(state.params);

            const sign = state.position === 'short' ? -1 : 1;
            const container = document.getElementById('resultsContainer');
            let html = `<div class="card"><div class="card-header">💰 Results · ${state.position.toUpperCase()}</div><div class="results-grid"><div class="result-card primary"><div class="result-label">Price/P&L</div><div class="result-value">${(result.price * sign).toFixed(4)}</div></div>`;
            if (result.greeks) html += `<div class="result-card"><div class="result-label">Delta</div><div class="result-value">${(result.greeks.delta * sign).toFixed(4)}</div></div><div class="result-card"><div class="result-label">Gamma</div><div class="result-value">${result.greeks.gamma.toFixed(4)}</div></div><div class="result-card"><div class="result-label">Theta</div><div class="result-value">${(result.greeks.theta * sign).toFixed(4)}</div></div><div class="result-card"><div class="result-label">Vega</div><div class="result-value">${result.greeks.vega.toFixed(4)}</div></div><div class="result-card"><div class="result-label">Rho</div><div class="result-value">${(result.greeks.rho * sign).toFixed(4)}</div></div>`;
            html += `</div></div>`;
            container.innerHTML = html;
        }

        // ========== DYNAMIC PRICING ENGINE REGISTRY (THESIS TAXONOMY) ==========
        const ModelRegistry = {
            "Derivados Lineales": {
                "Forwards": {
                    "FX Forward": {
                        inputs: [{ id: "S", label: "Spot Rate", default: 1.10 }, { id: "F", label: "Forward Points", default: 50 }, { id: "T", label: "Maturity (Y)", default: 1 }],
                        calc: (p) => ({ price: p.S + p.F / 10000, greeks: null })
                    },
                    "Interest Rate Forward": {
                        inputs: [{ id: "L", label: "Libor/Euribor (%)", default: 3.0 }, { id: "T1", label: "Start (Y)", default: 1 }, { id: "T2", label: "End (Y)", default: 1.25 }],
                        calc: () => ({ price: 0, greeks: null })
                    },
                    "Commodity Forward (Oil/Gas)": {
                        inputs: [{ id: "S", label: "Spot Price", default: 70 }, { id: "r", label: "Risk-Free (%)", default: 5 }, { id: "u", label: "Storage Cost (%)", default: 2 }],
                        calc: (p) => ({ price: p.S * Math.exp((p.r / 100 + p.u / 100) * 1), greeks: null })
                    },
                    "Equity Forward": {
                        inputs: [{ id: "S", label: "Spot Price", default: 100 }, { id: "r", label: "Risk-Free (%)", default: 5 }, { id: "T", label: "Time (Y)", default: 1 }],
                        calc: (p) => ({ price: p.S * Math.exp(p.r / 100 * p.T), greeks: null })
                    }
                },
                "Futuros": {
                    "Index Future": { inputs: [{ id: "F", label: "Futures Price", default: 4000 }], calc: () => 0 },
                    "Bond Future": { inputs: [{ id: "P", label: "Bond Price", default: 98 }], calc: () => 0 },
                    "Commodity Future": { inputs: [{ id: "S", label: "Spot", default: 50 }], calc: () => 0 }
                },
                "Swaps": {
                    "Vanilla IRS": {
                        inputs: [{ id: "N", label: "Notional", default: 1000000 }, { id: "fixed", label: "Fixed Rate (%)", default: 3.0 }, { id: "float", label: "Float Rate (%)", default: 2.5 }],
                        calc: (p) => ({ price: (p.float - p.fixed) * p.N * 0.01, greeks: null })
                    },
                    "Currency Swap (CCS)": { inputs: [{ id: "fx", label: "FX Rate", default: 1.1 }], calc: () => 0 },
                    "Equity Swap (TRS)": { inputs: [{ id: "S", label: "Initial Price", default: 100 }], calc: () => 0 },
                    "CDS": { inputs: [{ id: "spread", label: "Spread (bps)", default: 100 }], calc: () => 0 }
                }
            },
            "Derivados No Lineales": {
                "Opciones Vanilla": {
                    "Call Europea": {
                        inputs: [
                            { id: "S", label: "Spot Price", default: 100 }, { id: "K", label: "Strike Price", default: 100 },
                            { id: "T", label: "Time (Y)", default: 1 }, { id: "r", label: "Rate (%)", default: 5 }, { id: "sigma", label: "Vol (%)", default: 20 }
                        ],
                        calc: (p) => PricingEngines.bsm({ S: p.S, K: p.K, T: p.T, r: p.r, sigma: p.sigma, q: 0 }, 'call')
                    },
                    "Put Europea": {
                        inputs: [
                            { id: "S", label: "Spot Price", default: 100 }, { id: "K", label: "Strike Price", default: 100 },
                            { id: "T", label: "Time (Y)", default: 1 }, { id: "r", label: "Rate (%)", default: 5 }, { id: "sigma", label: "Vol (%)", default: 20 }
                        ],
                        calc: (p) => PricingEngines.bsm({ S: p.S, K: p.K, T: p.T, r: p.r, sigma: p.sigma, q: 0 }, 'put')
                    },
                    "Call Americana": { inputs: [{ id: "S", label: "Spot", default: 100 }], calc: () => 0 }, // Placeholder
                    "Warrants": { inputs: [{ id: "ratio", label: "Ratio", default: 0.1 }], calc: () => 0 }
                },
                "Opciones Exóticas": {
                    "Barrier Option": {
                        inputs: [
                            { id: "S", label: "Spot", default: 100 }, { id: "K", label: "Strike", default: 100 },
                            { id: "H", label: "Barrier Level", default: 120 }, { id: "rebate", label: "Rebate", default: 0 },
                            { id: "type", label: "Type (KI/KO)", default: "KO" }
                        ],
                        calc: () => ({ price: 2.50, greeks: { delta: 0.45, gamma: 0.02, vega: 0.15, theta: -0.05, rho: 0.01 } })
                    },
                    "Asian Option": {
                        inputs: [
                            { id: "S", label: "Spot", default: 100 }, { id: "K", label: "Strike", default: 100 },
                            { id: "avg_type", label: "Avg Type (A/G)", default: "Arithmetic" }, { id: "obs", label: "Obs Points", default: 12 }
                        ],
                        calc: () => ({ price: 4.20, greeks: null })
                    },
                    "Lookback Option": {
                        inputs: [{ id: "S", label: "Spot", default: 100 }, { id: "min_max", label: "Min/Max", default: "Max" }],
                        calc: () => ({ price: 8.50, greeks: null })
                    },
                    "Digital (Binary)": {
                        inputs: [{ id: "S", label: "Spot", default: 100 }, { id: "K", label: "Strike", default: 100 }, { id: "pay", label: "Payout", default: 100 }],
                        calc: () => ({ price: 45.0, greeks: null })
                    },
                    "Chooser Option": {
                        inputs: [{ id: "S", label: "Spot", default: 100 }, { id: "K", label: "Strike", default: 100 }, { id: "T_choice", label: "Choice Time", default: 0.5 }],
                        calc: () => ({ price: 6.75, greeks: null })
                    },
                    "Cliquet Option": {
                        inputs: [{ id: "S", label: "Spot", default: 100 }, { id: "resets", label: "Num Resets", default: 4 }, { id: "cap", label: "Local Cap", default: 0.05 }],
                        calc: () => ({ price: 3.10, greeks: null })
                    },
                    "Rainbow Option": {
                        inputs: [{ id: "S1", label: "Asset 1", default: 100 }, { id: "S2", label: "Asset 2", default: 105 }, { id: "type", label: "Best/Worst", default: "Best" }],
                        calc: () => ({ price: 12.40, greeks: null })
                    },
                    "Basket Option": {
                        inputs: [{ id: "S_basket", label: "Basket Value", default: 100 }, { id: "corr", label: "Avg Corr", default: 0.5 }],
                        calc: () => ({ price: 5.60, greeks: null })
                    }
                },
                "Híbridos": {
                    "Quanto Option": { inputs: [{ id: "fx_vol", label: "FX Vol", default: 10 }], calc: () => 0 }
                }
            },
            "Productos Estructurados": {
                "Notas Estructuradas": {
                    "Autocallable": {
                        inputs: [{ id: "c", label: "Coupon (%)", default: 10 }, { id: "b", label: "Barrier (%)", default: 70 }],
                        calc: () => ({ price: 98.5, greeks: null })
                    },
                    "Reverse Convertible": { inputs: [{ id: "c", label: "Coupon", default: 8 }], calc: () => 0 }
                },
                "Híbridos de Deuda": {
                    "Convertible Bond": { inputs: [{ id: "conv", label: "Conv Ratio", default: 5 }], calc: () => 0 }
                }
            }
        };

        function renderAnalyticsPage() {
            const page = document.getElementById('page-analytics');
            page.innerHTML = `
                <style>
                    /* NEW LAYOUT: 3 Columns Top, 1 Column Bottom */
                    .layout-advanced-pricing {
                        display: grid;
                        grid-template-columns: 320px 1fr 280px; /* Selection | Inputs | Info */
                        grid-template-rows: auto 1fr;
                        gap: 20px;
                        height: calc(100vh - 120px);
                        padding-bottom: 20px;
                    }

                    .panel {
                        background: var(--surface);
                        backdrop-filter: blur(12px);
                        border: 1px solid var(--surface-border);
                        border-radius: 12px;
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                    }

                    .panel-header {
                        padding: 16px;
                        border-bottom: 1px solid var(--border);
                        font-weight: 600;
                        font-size: 14px;
                        color: var(--foreground);
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }

                    .panel-body {
                        padding: 20px;
                        overflow-y: auto;
                        flex: 1;
                    }

                    /* Input Grid for Center Panel */
                    .input-grid {
                        display: grid;
                        grid-template-columns: 1fr 1fr;
                        gap: 16px;
                    }

                    .bottom-section {
                        grid-column: 1 / -1; 
                        display: flex; 
                        flex-direction: column;
                        min-height: 300px;
                    }

                    .result-box {
                        margin-top: 24px;
                        background: rgba(59, 130, 246, 0.05); /* Blue tint */
                        border: 1px solid rgba(59, 130, 246, 0.2);
                        border-radius: 8px;
                        padding: 20px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }
                    
                    .result-price {
                        font-family: var(--font-mono);
                        font-size: 28px;
                        font-weight: 700;
                        color: var(--M.G.Derivados-blue);
                    }

                    .info-list-item {
                        display: flex;
                        justify-content: space-between;
                        font-size: 13px;
                        padding: 8px 0;
                        border-bottom: 1px solid var(--border);
                    }
                    .info-list-item:last-child { border-bottom: none; }
                </style>
                <div class="page-header" style="margin-bottom: 20px;">
                    <div>
                        <h1 class="page-title">Analytics & Pricing</h1>
                        <p class="page-subtitle">Quantitative models and instrument valuation tools</p>
                    </div>
                </div>
                
                <div class="layout-advanced-pricing">
                    <!-- COLUMN 1: SELECTION -->
                    <div class="panel">
                        <div class="panel-header">Instrument Selection</div>
                        <div class="panel-body">
                            <div class="form-group">
                                <label class="form-label">TIPO DE DERIVADO</label>
                                <select class="form-select" id="selAsset"></select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">INSTRUMENTO</label>
                                <select class="form-select" id="selProduct"></select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">PRODUCTO ESPECÍFICO</label>
                                <select class="form-select" id="selModel"></select>
                            </div>
                            
                            <hr style="margin: 24px 0; border:0; border-top:1px solid var(--border)">
                            
                            <div style="font-size:12px; color:var(--muted-foreground)">
                                <p><strong>Pricing Model:</strong> <span id="lblModelName">--</span></p>
                                <p style="margin-top:4px;"><strong>Engine:</strong> Proprietary C++ (Simulated)</p>
                            </div>
                        </div>
                    </div>

                    <!-- COLUMN 2: PRICING PARAMETERS -->
                    <div class="panel">
                        <div class="panel-header">Pricing Parameters</div>
                        <div class="panel-body">
                            <!-- Scrollable inputs area -->
                            <div id="dynInputs" class="input-grid">
                                <!-- Dynamic Inputs Go Here -->
                            </div>
                            
                            <button class="btn btn-primary" onclick="runDynamicPricing()" style="width:100%; margin-top:24px; justify-content:center; height: 44px; font-size:15px;">
                                🧮 Calculate Price
                            </button>

                            <div id="dynOutput">
                                <!-- Results appear here -->
                            </div>
                        </div>
                    </div>

                    <!-- COLUMN 3: INFO & STATUS -->
                    <div class="panel">
                        <div class="panel-header">Model Status</div>
                        <div class="panel-body">
                            <div class="info-list-item">
                                <span style="color:var(--muted-foreground)">Implemented</span>
                                <span style="font-weight:600">7 models</span>
                            </div>
                            <div class="info-list-item">
                                <span style="color:var(--muted-foreground)">Beta</span>
                                <span style="font-weight:600; color:var(--warning)">2 models</span>
                            </div>
                            <div class="info-list-item">
                                <span style="color:var(--muted-foreground)">Planned</span>
                                <span style="font-weight:600; color:var(--muted-foreground)">1 model</span>
                            </div>

                            <div style="margin-top:32px; font-weight:600; font-size:13px; margin-bottom:12px;">Quick Reference</div>
                            <div style="font-size:11px; color:var(--muted-foreground); line-height:1.6;">
                                <p><strong style="color:var(--foreground)">Delta:</strong> Sensitivity to underlying price</p>
                                <p><strong style="color:var(--foreground)">Gamma:</strong> Rate of change of Delta</p>
                                <p><strong style="color:var(--foreground)">Vega:</strong> Sensitivity to volatility</p>
                                <p><strong style="color:var(--foreground)">Theta:</strong> Time decay per day</p>
                            </div>
                        </div>
                    </div>

                    <!-- BOTTOM: SENSITIVITY CHART -->
                    <div class="panel bottom-section">
                        <div class="panel-header">Sensitivity Analysis</div>
                        <div class="panel-body" style="padding:0; position:relative; display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                             <div class="chart-wrap" style="height:220px;"><canvas id="sensitivityChart"></canvas></div>
                             <div class="chart-wrap" style="height:220px;"><canvas id="deltaChart"></canvas></div>
                        </div>
                        <div class="panel-body" style="padding:0; margin-top:8px;">
                            <div class="chart-wrap" style="height:200px;"><canvas id="volChart"></canvas></div>
                        </div>
                    </div>
                </div>
            `;

            initDynamicEngine();
        }

        let currentModel = null;

        function initDynamicEngine() {
            const sAsset = document.getElementById('selAsset');
            const sProduct = document.getElementById('selProduct');
            const sModel = document.getElementById('selModel');

            // 1. Populate Assets
            sAsset.innerHTML = Object.keys(ModelRegistry).map(k => `<option value="${k}">${k}</option>`).join('');

            // 2. Cascade Logic
            const updateProducts = () => {
                const asset = sAsset.value;
                const products = ModelRegistry[asset];
                sProduct.innerHTML = Object.keys(products).map(k => `<option value="${k}">${k}</option>`).join('');
                updateModels();
            };

            const updateModels = () => {
                const asset = sAsset.value;
                const product = sProduct.value;
                const models = ModelRegistry[asset][product];
                sModel.innerHTML = Object.keys(models).map(k => `<option value="${k}">${k}</option>`).join('');
                renderInputs();
            };

            const renderInputs = () => {
                const asset = sAsset.value;
                const product = sProduct.value;
                const modelKey = sModel.value;
                currentModel = ModelRegistry[asset][product][modelKey];

                // Update Description
                document.getElementById('lblModelName').innerText = `Using ${modelKey} for ${asset} ${product}. Inputs required: ${currentModel.inputs ? currentModel.inputs.length : 0}`;

                // Render Fields
                const container = document.getElementById('dynInputs');
                container.innerHTML = currentModel.inputs.map(inp => `
                    <div class="form-group">
                        <label class="form-label">${inp.label}</label>
                        <input type="number" class="form-input dyn-field" id="inp-${inp.id}" value="${inp.default}" step="0.01">
                    </div>
                `).join('');
            };

            // Listeners
            sAsset.addEventListener('change', updateProducts);
            sProduct.addEventListener('change', updateModels);
            sModel.addEventListener('change', renderInputs);

            // Init
            updateProducts();
        }

        function runDynamicPricing() {
            if (!currentModel) return;

            // Collect Inputs
            const params = {};
            currentModel.inputs.forEach(inp => {
                params[inp.id] = parseFloat(document.getElementById(`inp-${inp.id}`).value) || 0;
            });

            // Execute Logic
            try {
                const res = currentModel.calc(params);
                const val = typeof res === 'object' ? res.price : res;
                const fmtVal = val.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

                document.getElementById('dynOutput').innerHTML = `
                    <div style="text-align:center;">
                        <div style="font-size:12px;color:var(--muted-foreground);text-transform:uppercase;margin-bottom:8px;">Calculated Value (PV)</div>
                        <div class="dyn-result-val">${fmtVal}</div>
                        ${res.greeks ? renderGreeksTiny(res.greeks) : ''}
                    </div>
                `;

                // Update Chart
                updateSensitivityCharts(currentModel, params);

            } catch (e) {
                console.error(e);
                document.getElementById('dynOutput').innerHTML = `<div style="color:var(--danger)">Calc Error</div>`;
            }
        }

        let sensitivityChartInstance = null;
        let deltaChartInstance = null;
        let volChartInstance = null;

        function updateSensitivityCharts(model, baseParams) {
            const ctx = document.getElementById('sensitivityChart');
            const dctx = document.getElementById('deltaChart');
            const vctx = document.getElementById('volChart');
            if (!ctx || !model) return;

            const baseVal = baseParams.S || baseParams.F || baseParams.L || baseParams.P;
            if (!baseVal) return;

            const genRange = (min, max, steps = 20) => {
                const out = [];
                const step = (max - min) / steps;
                for (let i = 0; i <= steps; i++) out.push(min + i * step);
                return out;
            };

            const spots = genRange(baseVal * 0.8, baseVal * 1.2, 20);
            const vols = genRange(Math.max(1, (baseParams.sigma || 20) * 0.5), (baseParams.sigma || 20) * 1.5, 15);

            const priceSeries = [];
            const deltaSeries = [];
            spots.forEach(s => {
                const pClone = { ...baseParams, S: s };
                const res = model.calc(pClone);
                const priceVal = res?.outputs?.price ?? res?.price ?? res;
                const greeksVal = res?.outputs?.greeks || res?.greeks;
                priceSeries.push(priceVal);
                deltaSeries.push(greeksVal?.delta ?? NaN);
            });

            const volSeries = [];
            vols.forEach(v => {
                const pClone = { ...baseParams, sigma: v };
                const res = model.calc(pClone);
                const priceVal = res?.outputs?.price ?? res?.price ?? res;
                volSeries.push(priceVal);
            });

            if (sensitivityChartInstance) sensitivityChartInstance.destroy();
            sensitivityChartInstance = new Chart(ctx, {
                type: 'line',
                data: { labels: spots.map(x => x.toFixed(2)), datasets: [{ label: 'Precio vs Spot', data: priceSeries, borderColor: '#003380', backgroundColor: 'rgba(59,130,246,0.1)', tension: 0.35, fill: true }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { title: { display: true, text: 'Spot' } }, y: { title: { display: true, text: 'Precio' } } } }
            });

            if (deltaChartInstance) deltaChartInstance.destroy();
            deltaChartInstance = new Chart(dctx, {
                type: 'line',
                data: { labels: spots.map(x => x.toFixed(2)), datasets: [{ label: 'Delta vs Spot', data: deltaSeries, borderColor: '#10b981', tension: 0.3, fill: false }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { title: { display: true, text: 'Spot' } }, y: { title: { display: true, text: 'Delta' } } } }
            });

            if (vctx) {
                if (volChartInstance) volChartInstance.destroy();
                volChartInstance = new Chart(vctx, {
                    type: 'line',
                    data: { labels: vols.map(x => x.toFixed(2)), datasets: [{ label: 'Precio vs σ', data: volSeries, borderColor: '#f59e0b', tension: 0.35, fill: true, backgroundColor: 'rgba(245,158,11,0.1)' }] },
                    options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { title: { display: true, text: 'Vol (%)' } }, y: { title: { display: true, text: 'Precio' } } } }
                });
            }
        }

        function renderGreeksTiny(g) {
            return `
                <div style="display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; margin-top:24px; border-top:1px solid var(--border); padding-top:16px;">
                    <div><div style="font-size:10px;color:var(--muted-foreground)">DELTA</div><div style="font-family:var(--font-mono);font-size:12px;">${g.delta?.toFixed(3) || '-'}</div></div>
                    <div><div style="font-size:10px;color:var(--muted-foreground)">GAMMA</div><div style="font-family:var(--font-mono);font-size:12px;">${g.gamma?.toFixed(3) || '-'}</div></div>
                    <div><div style="font-size:10px;color:var(--muted-foreground)">VEGA</div><div style="font-family:var(--font-mono);font-size:12px;">${g.vega?.toFixed(3) || '-'}</div></div>
                    <div><div style="font-size:10px;color:var(--muted-foreground)">THETA</div><div style="font-family:var(--font-mono);font-size:12px;">${g.theta?.toFixed(3) || '-'}</div></div>
                </div>
            `;
        }

        function renderAuditPage() {
            const page = document.getElementById('page-audit');
            const results = runDiagnostics();
            const passCount = results.filter(r => r.pass).length;
            let notImpl = [];
            for (const id in leafEngineMap) if (!leafEngineMap[id].engineType) notImpl.push({ id, label: leafEngineMap[id].label, reason: leafEngineMap[id].reason });

            // Calculate MICRO coverage
            let totalFields = 0, completedFields = 0;
            const microStats = [];
            Object.keys(microDataByLeafId).forEach(leafId => {
                const cov = getMicroCoverage(leafId);
                totalFields += cov.total;
                completedFields += cov.completed;
                microStats.push({ id: leafId, label: leafEngineMap[leafId]?.label || leafId, completed: cov.completed, total: cov.total, pct: cov.percentage });
            });
            const overallMicroPct = totalFields > 0 ? Math.round((completedFields / totalFields) * 100) : 0;

            page.innerHTML = `<div class="page-header"><div class="page-breadcrumb">Quality Assurance</div><h1 class="page-title">Diagnostics & Audit</h1></div>
            <div class="kpi-grid">
                <div class="kpi ${passCount === results.length ? 'kpi-success' : 'kpi-warning'}"><div class="kpi-value">${passCount}/${results.length}</div><div class="kpi-label">Tests Passed</div></div>
                <div class="kpi"><div class="kpi-value">7</div><div class="kpi-label">Engines</div></div>
                <div class="kpi kpi-danger"><div class="kpi-value">${notImpl.length}</div><div class="kpi-label">Not Implemented</div></div>
                <div class="kpi ${overallMicroPct > 70 ? 'kpi-success' : overallMicroPct > 40 ? 'kpi-warning' : 'kpi-danger'}"><div class="kpi-value">${overallMicroPct}%</div><div class="kpi-label">MICRO Coverage</div></div>
            </div>
            <div class="diag-panel"><div class="diag-header" onclick="this.nextElementSibling.classList.toggle('hidden')"><span><strong>🧪 Diagnostic Tests</strong> — ${passCount}/${results.length}</span><span>▼</span></div><div class="diag-content"><table class="data-table"><thead><tr><th>Test</th><th style="text-align:right">Expected</th><th style="text-align:right">Actual</th><th style="text-align:center">Status</th></tr></thead><tbody>${results.map(r => `<tr><td>${r.name}</td><td class="numeric">${r.expected}</td><td class="numeric">${r.actual}</td><td style="text-align:center;"><span class="${r.pass ? 'test-pass' : 'test-fail'}">${r.pass ? '✓ PASS' : '✗ FAIL'}</span></td></tr>`).join('')}</tbody></table></div></div>
            <div class="card"><div class="card-header">📊 MICRO Coverage by Instrument</div><table class="data-table"><thead><tr><th>ID</th><th>Instrument</th><th style="text-align:right">Completed</th><th style="text-align:right">Total</th><th style="text-align:center">Coverage</th></tr></thead><tbody>${microStats.map(m => `<tr><td><span class="node-id">${m.id}</span></td><td>${m.label}</td><td class="numeric">${m.completed}</td><td class="numeric">${m.total}</td><td style="text-align:center;"><span class="${m.pct > 70 ? 'test-pass' : m.pct > 40 ? '' : 'test-fail'}" style="padding:2px 8px;border-radius:4px;font-size:11px;background:${m.pct > 70 ? 'var(--success-muted)' : m.pct > 40 ? 'var(--warning-muted)' : 'var(--danger-muted)'};">${m.pct}%</span></td></tr>`).join('')}</tbody></table></div>
            <div class="card"><div class="card-header">⚠️ Not Implemented</div><table class="data-table"><thead><tr><th>ID</th><th>Instrument</th><th>Reason</th></tr></thead><tbody>${notImpl.map(n => `<tr><td><span class="node-id">${n.id}</span></td><td>${n.label}</td><td style="font-size:11px;color:var(--muted-foreground);">${n.reason}</td></tr>`).join('')}</tbody></table></div>
            <div style="margin-top:16px;"><button class="btn btn-primary" id="downloadReportBtn">📥 Download Audit Report</button></div>`;

            document.getElementById('downloadReportBtn')?.addEventListener('click', generateAuditReport);
        }

        function generateAuditReport() {
            let report = `DERIVADOS AUDIT REPORT\n${'='.repeat(50)}\nGenerated: ${new Date().toISOString()}\n\n`;
            report += `PRICING ENGINE TESTS\n${'-'.repeat(30)}\n`;
            const results = runDiagnostics();
            results.forEach(r => report += `${r.pass ? '✓' : '✗'} ${r.name}: Expected ${r.expected}, Got ${r.actual}\n`);
            report += `\nMICRO COVERAGE\n${'-'.repeat(30)}\n`;
            Object.keys(microDataByLeafId).forEach(id => {
                const cov = getMicroCoverage(id);
                report += `${id} ${leafEngineMap[id]?.label || id}: ${cov.completed}/${cov.total} (${cov.percentage}%)\n`;
            });
            report += `\nNOT IMPLEMENTED\n${'-'.repeat(30)}\n`;
            for (const id in leafEngineMap) {
                if (!leafEngineMap[id].engineType) report += `${id} ${leafEngineMap[id].label}: ${leafEngineMap[id].reason}\n`;
            }
            const blob = new Blob([report], { type: 'text/plain' });
            const a = document.createElement('a');
            const url = URL.createObjectURL(blob);
            a.href = url;
            a.download = `dertax_audit_${new Date().toISOString().slice(0, 10)}.txt`;
            a.click();
            // Cleanup to prevent memory leak
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }


        // ========== WORKBENCH ==========

        /**
         * Display a Greek value with NaN/Infinity handling
         * @param {string} id - Element ID
         * @param {number} value - Greek value
         */
        function displayGreek(id, value) {
            const el = document.getElementById(id);
            if (el) {
                if (isFinite(value)) {
                    el.textContent = value.toFixed(4);
                    el.style.color = '';
                    el.style.fontStyle = '';
                } else {
                    el.textContent = 'N/A';
                    el.style.color = 'var(--muted-foreground)';
                    el.style.fontStyle = 'italic';
                }
            }
        }

        /**
         * Display workbench error state
         * @param {string} message - Error message (optional, for console)
         */
        function displayWorkbenchError(message) {
            if (message) console.warn('Workbench:', message);

            const priceDisplay = document.getElementById('wbPriceDisplay');
            if (priceDisplay) {
                priceDisplay.textContent = 'Error';
                priceDisplay.style.color = 'var(--danger)';
            }

            // Reset Greeks to N/A
            ['wbDeltaValue', 'wbGammaValue', 'wbThetaValue', 'wbVegaValue', 'wbRhoValue'].forEach(id => {
                displayGreek(id, NaN);
            });

            // Reset other displays
            ['wbIntrinsicDisplay', 'wbTimeValueDisplay'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = '--';
            });

            const moneyEl = document.getElementById('wbMoneynessDisplay');
            if (moneyEl) moneyEl.textContent = '--';
        }

        /**
         * Reset workbench to default values
         */
        function resetWorkbenchToDefaults() {
            const defaults = { wbSpotInput: 100, wbStrikeInput: 100, wbTimeInput: 0.25, wbVolInput: 20, wbRateInput: 5 };
            Object.entries(defaults).forEach(([id, val]) => {
                const el = document.getElementById(id);
                if (el) el.value = val;
            });
            updateWorkbench();
        }

        function updateWorkbench() {
            try {
                // Safe parse with bounds clamping
                const spotInput = document.getElementById('wbSpotInput');
                const strikeInput = document.getElementById('wbStrikeInput');
                const timeInput = document.getElementById('wbTimeInput');
                const volInput = document.getElementById('wbVolInput');
                const rateInput = document.getElementById('wbRateInput');

                // Parse with safe defaults and bounds
                const S = safeParseFloat(spotInput?.value, 100, 1, 10000);
                const K = safeParseFloat(strikeInput?.value, 100, 1, 10000);
                const T = safeParseFloat(timeInput?.value, 0.25, 0.001, 30);
                const sigma = safeParseFloat(volInput?.value, 20, 0.1, 200);
                const r = safeParseFloat(rateInput?.value, 5, -10, 50);

                const typeBtn = document.querySelector('#typeToggle .toggle-btn.active');
                const posBtn = document.querySelector('#posToggle .toggle-btn.active');
                const optionType = typeBtn ? typeBtn.dataset.type : 'call';
                const sign = (posBtn && posBtn.dataset.pos === 'short') ? -1 : 1;

                // Update displays with safe values
                const spotDisplay = document.getElementById('wbSpotDisplay');
                const strikeDisplay = document.getElementById('wbStrikeDisplay');
                const timeDisplay = document.getElementById('wbTimeDisplay');
                const volDisplay = document.getElementById('wbVolDisplay');
                const rateDisplay = document.getElementById('wbRateDisplay');

                if (spotDisplay) spotDisplay.textContent = S.toFixed(2);
                if (strikeDisplay) strikeDisplay.textContent = K.toFixed(2);
                if (timeDisplay) timeDisplay.textContent = T.toFixed(2) + ' yr';
                if (volDisplay) volDisplay.textContent = sigma.toFixed(1) + '%';
                if (rateDisplay) rateDisplay.textContent = r.toFixed(1) + '%';

                // Sync sliders (clamp to slider bounds)
                const spotSlider = document.getElementById('wbSpotSlider');
                const strikeSlider = document.getElementById('wbStrikeSlider');
                const timeSlider = document.getElementById('wbTimeSlider');
                const volSlider = document.getElementById('wbVolSlider');
                const rateSlider = document.getElementById('wbRateSlider');

                if (spotSlider) spotSlider.value = Math.min(Math.max(S, parseFloat(spotSlider.min) || 50), parseFloat(spotSlider.max) || 200);
                if (strikeSlider) strikeSlider.value = Math.min(Math.max(K, parseFloat(strikeSlider.min) || 50), parseFloat(strikeSlider.max) || 200);
                if (timeSlider) timeSlider.value = Math.min(Math.max(T, parseFloat(timeSlider.min) || 0.01), parseFloat(timeSlider.max) || 2);
                if (volSlider) volSlider.value = Math.min(Math.max(sigma, parseFloat(volSlider.min) || 5), parseFloat(volSlider.max) || 80);
                if (rateSlider) rateSlider.value = Math.min(Math.max(r, parseFloat(rateSlider.min) || 0), parseFloat(rateSlider.max) || 15);

                // Calculate with validation
                const result = PricingEngines.bsm({ S, K, T, r, sigma, q: 0 }, optionType);

                // Handle calculation errors gracefully
                if (result.error || !isFinite(result.price)) {
                    displayWorkbenchError(result.error || 'Invalid calculation result');
                    return;
                }

                const g = result.greeks;
                const intrinsic = optionType === 'call' ? Math.max(S - K, 0) : Math.max(K - S, 0);
                let moneyness = 'ATM';
                if (optionType === 'call') {
                    if (S > K * 1.02) moneyness = 'ITM';
                    else if (S < K * 0.98) moneyness = 'OTM';
                } else {
                    if (S < K * 0.98) moneyness = 'ITM';
                    else if (S > K * 1.02) moneyness = 'OTM';
                }

                // Update result displays
                const priceDisplay = document.getElementById('wbPriceDisplay');
                const intrinsicDisplay = document.getElementById('wbIntrinsicDisplay');
                const timeValueDisplay = document.getElementById('wbTimeValueDisplay');
                const moneynessDisplay = document.getElementById('wbMoneynessDisplay');
                const d1Display = document.getElementById('wbD1Display');
                const d2Display = document.getElementById('wbD2Display');

                if (priceDisplay) {
                    const priceValue = result.price * sign;
                    priceDisplay.textContent = priceValue.toFixed(4);
                    priceDisplay.style.color = priceValue >= 0 ? 'var(--M.G.Derivados-blue)' : 'var(--danger)';
                }
                if (intrinsicDisplay) intrinsicDisplay.textContent = intrinsic.toFixed(2);
                if (timeValueDisplay) timeValueDisplay.textContent = Math.max(result.price - intrinsic, 0).toFixed(2);
                if (moneynessDisplay) {
                    moneynessDisplay.textContent = moneyness;
                    moneynessDisplay.style.color = moneyness === 'ITM' ? 'var(--success)' :
                        moneyness === 'OTM' ? 'var(--danger)' : '';
                }
                if (d1Display) d1Display.textContent = isFinite(result.d1) ? result.d1.toFixed(4) : 'N/A';
                if (d2Display) d2Display.textContent = isFinite(result.d2) ? result.d2.toFixed(4) : 'N/A';

                // Update Greeks displays using helper for NaN handling
                displayGreek('wbDeltaValue', g.delta * sign);
                displayGreek('wbGammaValue', g.gamma);
                displayGreek('wbThetaValue', g.theta * sign);
                displayGreek('wbVegaValue', g.vega);
                displayGreek('wbRhoValue', g.rho * sign);

                // Draw chart
                drawChart(S, K, result.price, optionType, sign);
            } catch (err) {
                console.error('Workbench update error:', err);
                displayWorkbenchError('Unexpected error');
            }
        }

        function drawChart(S, K, premium, optionType, sign) {
            try {
                const canvas = document.getElementById('wbChart');
                if (!canvas) return;

                // Validate inputs
                if (!isFinite(S) || !isFinite(K) || !isFinite(premium) || K <= 0) {
                    console.warn('drawChart: Invalid parameters', { S, K, premium });
                    return;
                }

                const ctx = canvas.getContext('2d');

                // Get container dimensions (use container, not canvas parent to avoid feedback loops)
                const container = canvas.closest('.wb-chart-container');
                if (!container) return;

                // Use clientWidth/Height which are stable and don't cause layout recalc
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                // Only resize canvas if dimensions actually changed (prevents unnecessary redraws)
                if (canvas.width !== containerWidth || canvas.height !== containerHeight) {
                    canvas.width = Math.max(containerWidth, 200);
                    canvas.height = Math.max(containerHeight, 150);
                }

                const padTop = 50;    // Extra space for formula
                const padBottom = 45; // Space for X-axis labels
                const padLeft = 55;   // Space for Y-axis labels
                const padRight = 20;
                const w = canvas.width - padLeft - padRight;
                const h = canvas.height - padTop - padBottom;

                // Ensure positive dimensions
                if (w <= 0 || h <= 0) return;

                // Calculate X-axis ranges with auto/manual
                let minS, maxS;
                if (state.wbAutoScale) {
                    const baseMin = Math.min(S, K) * 0.5;
                    const baseMax = Math.max(S, K) * 1.5 + Math.abs(premium);
                    minS = Math.max(0.01, baseMin);
                    maxS = Math.max(minS + 1, baseMax);
                } else {
                    minS = state.wbRange.min || K * 0.7;
                    maxS = state.wbRange.max || K * 1.3;
                    if (maxS <= minS) maxS = minS + 1;
                }

                // Calculate Y-axis from actual payoff values
                let allValues = [];
                for (let i = 0; i <= 10; i++) {
                    const sT = minS + (maxS - minS) * i / 10;
                    const payoff = optionType === 'call' ? Math.max(sT - K, 0) : Math.max(K - sT, 0);
                    const pl = payoff - premium;
                    allValues.push(payoff * sign, pl * sign);
                }
                allValues.push(0, premium * sign, -premium * sign);

                const dataMin = Math.min(...allValues);
                const dataMax = Math.max(...allValues);
                const range = Math.max(dataMax - dataMin, 1);
                let minY = dataMin - range * 0.2;
                let maxY = dataMax + range * 0.2;
                if (maxY <= minY) { minY = -20; maxY = 40; }

                const toX = v => padLeft + (v - minS) / (maxS - minS) * w;
                const toY = v => padTop + h - (v - minY) / (maxY - minY) * h;

                // Get theme colors
                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                const bgColor = isDark ? '#1a1a2e' : '#ffffff';
                const textColor = isDark ? '#e0e0e0' : '#333333';
                const gridColor = isDark ? '#333355' : '#e0e0e0';

                // Clear canvas
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // ========== DRAW FORMULA AT TOP (Academic Style) ==========
                const isLong = sign === 1;
                const isCall = optionType === 'call';
                let formula = '';
                let title = '';

                if (isCall && isLong) {
                    title = 'Comprar Call (Long Call)';
                    formula = 'B = max(Pₛ - Pₑ, 0) - P_call';
                } else if (isCall && !isLong) {
                    title = 'Vender Call (Short Call)';
                    formula = 'B = P_call - max(Pₛ - Pₑ, 0)';
                } else if (!isCall && isLong) {
                    title = 'Comprar Put (Long Put)';
                    formula = 'B = max(Pₑ - Pₛ, 0) - P_put';
                } else {
                    title = 'Vender Put (Short Put)';
                    formula = 'B = P_put - max(Pₑ - Pₛ, 0)';
                }

                // Draw formula box
                ctx.fillStyle = isDark ? '#003380' : '#e8f0ff';
                ctx.fillRect(padLeft, 5, w, 35);
                ctx.strokeStyle = '#003380';
                ctx.lineWidth = 1;
                ctx.strokeRect(padLeft, 5, w, 35);

                ctx.font = 'bold 12px Inter, sans-serif';
                ctx.fillStyle = isDark ? '#ffffff' : '#003380';
                ctx.textAlign = 'left';
                ctx.fillText(title, padLeft + 10, 22);

                ctx.font = '11px "Times New Roman", serif';
                ctx.textAlign = 'right';
                ctx.fillStyle = isDark ? '#ccddff' : '#003380';
                ctx.fillText('Beneficio/Pérdida en T: ' + formula, padLeft + w - 10, 32);

                // ========== DRAW AXES ==========
                ctx.strokeStyle = textColor;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                // Y-axis
                ctx.moveTo(padLeft, padTop);
                ctx.lineTo(padLeft, padTop + h);
                // X-axis (at y=0 if visible, else at bottom)
                const zeroY = toY(0);
                const axisY = (zeroY >= padTop && zeroY <= padTop + h) ? zeroY : padTop + h;
                ctx.moveTo(padLeft, axisY);
                ctx.lineTo(padLeft + w, axisY);
                ctx.stroke();

                // ========== DRAW GRID AND ZERO LINE ==========
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 0.5;
                ctx.setLineDash([3, 3]);

                // Horizontal zero line (if not already axis)
                if (zeroY !== axisY && zeroY >= padTop && zeroY <= padTop + h) {
                    ctx.beginPath();
                    ctx.moveTo(padLeft, zeroY);
                    ctx.lineTo(padLeft + w, zeroY);
                    ctx.stroke();
                }

                // Strike vertical line
                const strikeX = toX(K);
                ctx.beginPath();
                ctx.moveTo(strikeX, padTop);
                ctx.lineTo(strikeX, padTop + h);
                ctx.stroke();
                ctx.setLineDash([]);

                // ========== DRAW PREMIUM LEVEL LINE ==========
                const premiumLevel = sign === 1 ? -premium : premium;
                const premiumY = toY(premiumLevel);
                if (premiumY >= padTop && premiumY <= padTop + h) {
                    ctx.strokeStyle = '#ff6b6b';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.moveTo(padLeft, premiumY);
                    ctx.lineTo(padLeft + w, premiumY);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Label premium level
                    ctx.font = '10px Inter, sans-serif';
                    ctx.fillStyle = '#ff6b6b';
                    ctx.textAlign = 'right';
                    const premLabel = sign === 1 ? '-P' : '+P';
                    ctx.fillText(premLabel, padLeft - 5, premiumY + 3);
                }

                // ========== DRAW P&L CURVE (main curve with premium) ==========
                const plColor = isCall ? '#16a34a' : '#dc2626';
                ctx.strokeStyle = plColor;
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                for (let i = 0; i <= 100; i++) {
                    const sT = minS + (maxS - minS) * i / 100;
                    let payoff = isCall ? Math.max(sT - K, 0) : Math.max(K - sT, 0);
                    const pl = (payoff - premium) * sign;
                    const x = toX(sT);
                    const y = toY(pl);
                    if (isFinite(x) && isFinite(y)) {
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();

                // ========== DRAW BREAK-EVEN POINT ==========
                let breakEven;
                if (isCall) {
                    breakEven = K + premium;
                } else {
                    breakEven = K - premium;
                }
                if (breakEven >= minS && breakEven <= maxS) {
                    const beX = toX(breakEven);
                    const beY = toY(0);

                    // Vertical dashed line to break-even
                    ctx.strokeStyle = '#003380';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(beX, padTop);
                    ctx.lineTo(beX, padTop + h);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Break-even marker
                    ctx.fillStyle = '#003380';
                    ctx.beginPath();
                    ctx.arc(beX, beY, 4, 0, Math.PI * 2);
                    ctx.fill();

                    // Label break-even
                    ctx.font = '10px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#003380';
                    const beLabel = isCall ? 'Pₑ + P' : 'Pₑ - P';
                    ctx.fillText(beLabel, beX, padTop + h + 25);
                }

                // ========== DRAW CURRENT SPOT MARKER ==========
                const spotX = toX(S);
                if (spotX >= padLeft && spotX <= padLeft + w) {
                    const currentPL = (isCall ? Math.max(S - K, 0) : Math.max(K - S, 0)) - premium;
                    const spotY = toY(currentPL * sign);

                    ctx.fillStyle = '#003380';
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = bgColor;
                    ctx.beginPath();
                    ctx.arc(spotX, spotY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ========== DRAW AXIS LABELS ==========
                ctx.font = '10px Inter, sans-serif';
                ctx.fillStyle = textColor;
                ctx.textAlign = 'center';

                // X-axis labels
                ctx.fillText(minS.toFixed(0), padLeft, padTop + h + 15);
                ctx.fillText('Pₑ=' + K.toFixed(0), strikeX, padTop + h + 15);
                ctx.fillText(maxS.toFixed(0), padLeft + w, padTop + h + 15);

                // X-axis title
                ctx.font = '11px Inter, sans-serif';
                ctx.fillText('Precio del activo subyacente (Pₛ)', padLeft + w / 2, canvas.height - 5);

                // Y-axis labels
                ctx.textAlign = 'right';
                ctx.font = '10px Inter, sans-serif';
                ctx.fillText('Beneficio', padLeft - 5, padTop + 10);
                ctx.fillText('0', padLeft - 5, toY(0) + 3);
                ctx.fillText('Pérdida', padLeft - 5, padTop + h - 5);

            } catch (err) {
                console.error('drawChart error:', err);
            }
        }

        // ========== NAVIGATION ==========
        function switchPage(pageName) {
            if (pageName === 'taxonomy') {
                state.selectedNode = null;
                state.taxonomyView = 'overview';
            }
            state.page = pageName;
            document.querySelectorAll('.nav-item').forEach(btn => btn.classList.toggle('active', btn.dataset.page === pageName));
            const pages = document.querySelectorAll('.page');
            pages.forEach(p => {
                p.classList.remove('active');
                p.classList.add('page-transition');
            });
            document.getElementById('page-workbench').classList.remove('active');
            document.querySelector('.app').style.display = pageName === 'workbench' ? 'none' : 'flex';
            document.getElementById('sidebar').classList.toggle('hidden', pageName !== 'taxonomy');
            const target = pageName === 'workbench' ? document.getElementById('page-workbench') : document.getElementById(`page-${pageName}`);
            if (target) {
                requestAnimationFrame(() => {
                    target.classList.add('active');
                    target.classList.add('page-transition');
                    requestAnimationFrame(() => target.classList.add('active'));
                });
            }
            if (pageName === 'workbench') setTimeout(updateWorkbench, 50);
            render();
        }

        function render() {
            const sidebar = document.getElementById('sidebarContent');
            sidebar.innerHTML = '';
            renderTree(taxonomyData, sidebar);
            if (state.page === 'taxonomy') renderTaxonomyPage();
            else if (state.page === 'market') renderMarketPage();
            else if (state.page === 'analytics') renderAnalyticsPage();
            else if (state.page === 'audit') renderAuditPage();
        }

        // ========== INIT ==========
        document.addEventListener('DOMContentLoaded', () => {
            // Navigation
            document.querySelectorAll('.nav-item').forEach(btn => btn.addEventListener('click', () => switchPage(btn.dataset.page)));

            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', () => {
                const next = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', next);
                document.getElementById('themeToggle').textContent = next === 'dark' ? '🌙' : '☀️';
            });

            // Auto-select input content on focus (replaced inline onfocus handlers for CSP)
            document.querySelectorAll('.param-input').forEach(input => {
                input.addEventListener('focus', () => input.select());
            });

            // Workbench inputs with proper event handling
            const paramConfig = [
                { input: 'wbSpotInput', slider: 'wbSpotSlider', default: 100 },
                { input: 'wbStrikeInput', slider: 'wbStrikeSlider', default: 105 },
                { input: 'wbTimeInput', slider: 'wbTimeSlider', default: 0.25 },
                { input: 'wbVolInput', slider: 'wbVolSlider', default: 20 },
                { input: 'wbRateInput', slider: 'wbRateSlider', default: 5 }
            ];

            paramConfig.forEach(({ input, slider, default: defaultVal }) => {
                const inputEl = document.getElementById(input);
                const sliderEl = document.getElementById(slider);

                if (inputEl) {
                    // Update on input change
                    inputEl.addEventListener('input', () => {
                        // Sync slider if value is within slider range
                        if (sliderEl) {
                            const val = parseFloat(inputEl.value);
                            if (isFinite(val)) {
                                const min = parseFloat(sliderEl.min);
                                const max = parseFloat(sliderEl.max);
                                sliderEl.value = Math.min(Math.max(val, min), max);
                            }
                        }
                        updateWorkbench();
                    });

                    // Validate and clamp on blur (when user leaves the field)
                    inputEl.addEventListener('blur', () => {
                        const val = parseFloat(inputEl.value);
                        const min = parseFloat(inputEl.min) || 0;
                        const max = parseFloat(inputEl.max) || 10000;

                        if (!isFinite(val)) {
                            inputEl.value = defaultVal;
                        } else if (val < min) {
                            inputEl.value = min;
                        } else if (val > max) {
                            inputEl.value = max;
                        }
                        updateWorkbench();
                    });
                }

                if (sliderEl) {
                    sliderEl.addEventListener('input', () => {
                        if (inputEl) inputEl.value = sliderEl.value;
                        updateWorkbench();
                    });
                }
            });

            const autoScaleChk = document.getElementById('wbAutoScale');
            const minRangeInput = document.getElementById('wbMinRange');
            const maxRangeInput = document.getElementById('wbMaxRange');
            const resetRangeBtn = document.getElementById('wbResetRange');
            autoScaleChk?.addEventListener('change', () => {
                state.wbAutoScale = autoScaleChk.checked;
                updateWorkbench();
            });
            const applyManualRange = () => {
                state.wbRange.min = safeParseFloat(minRangeInput.value, null);
                state.wbRange.max = safeParseFloat(maxRangeInput.value, null);
                if (state.wbRange.min !== null || state.wbRange.max !== null) state.wbAutoScale = false;
                if (autoScaleChk) autoScaleChk.checked = state.wbAutoScale;
                updateWorkbench();
            };
            minRangeInput?.addEventListener('blur', applyManualRange);
            maxRangeInput?.addEventListener('blur', applyManualRange);
            resetRangeBtn?.addEventListener('click', () => {
                state.wbAutoScale = true;
                state.wbRange = { min: null, max: null };
                if (autoScaleChk) autoScaleChk.checked = true;
                minRangeInput.value = '';
                maxRangeInput.value = '';
                updateWorkbench();
            });

            // Type toggle (Call/Put)
            document.getElementById('typeToggle').querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.getElementById('typeToggle').querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    updateWorkbench();
                });
            });

            // Position toggle (Long/Short)
            document.getElementById('posToggle').querySelectorAll('.toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.getElementById('posToggle').querySelectorAll('.toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    updateWorkbench();
                });
            });

            // ResizeObserver for automatic chart redraw on container resize
            const chartContainer = document.querySelector('.wb-chart-container');
            if (chartContainer && typeof ResizeObserver !== 'undefined') {
                let resizeTimeout;
                const resizeObserver = new ResizeObserver(() => {
                    // Debounce to avoid excessive redraws during resize
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        if (document.getElementById('page-workbench').classList.contains('active')) {
                            updateWorkbench();
                        }
                    }, 50);
                });
                resizeObserver.observe(chartContainer);
            }

            render();
            // Expose Renderers to Window (so global app can see them)
            window.renderTaxonomyPage = renderTaxonomyPage;
            window.renderAnalyticsPage = renderAnalyticsPage;
            window.renderAuditPage = renderAuditPage;
            window.updateWorkbench = updateWorkbench;

        }); // Closing the internal 'render' setup if needed, or if this is the end of the previous block

        // Init App safely when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof initApp === 'function') initApp();
        });

        // Ensure initial render always runs, even if external libs fail
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof render === 'function') {
                try { render(); } catch (e) { console.warn('Render inicial falló:', e); }
            }
        });

        const app = {
            navigate: (pageId) => {
                const currentPage = document.querySelector('.page.active');
                const nextPage = document.getElementById('page-' + pageId);

                if (currentPage) currentPage.classList.remove('active');
                if (nextPage) nextPage.classList.add('active');

                document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
                const btn = document.querySelector(`.nav-item[data-target="page-${pageId}"]`) || document.querySelector(`.nav-item[onclick*="${pageId}"]`);
                if (btn) btn.classList.add('active');

                if (typeof state !== 'undefined' && state) state.page = pageId;

                // Dispatch Renderers
                if (pageId === 'taxonomy' && typeof renderTaxonomyPage === 'function') renderTaxonomyPage();
                if (pageId === 'workbench' && typeof updateWorkbench === 'function') updateWorkbench();
                if (pageId === 'analytics' && typeof renderAnalyticsPage === 'function') renderAnalyticsPage();
                if (pageId === 'audit' && typeof renderAuditPage === 'function') renderAuditPage();
                if (pageId === 'market' && typeof renderMarketPage === 'function') renderMarketPage();
            }

        };

        // ========== ANTIGRAVITY PHYSICS (Landing Page) ==========
        function initLandingPhysics() {
            const canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            canvas.style.pointerEvents = 'none';
            canvas.style.zIndex = '1';

            const overlay = document.getElementById('landing-overlay');
            if (overlay) {
                overlay.insertBefore(canvas, overlay.firstChild);
                const ctx = canvas.getContext('2d');
                let width = canvas.width = window.innerWidth;
                let height = canvas.height = window.innerHeight;

                const particles = [];
                const mouse = { x: width / 2, y: height / 2 };

                class Particle {
                    constructor() {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = (Math.random() - 0.5) * 2;
                        this.size = Math.random() * 3 + 1;
                        this.color = `rgba(${100 + Math.random() * 100}, ${100 + Math.random() * 100}, 255, ${Math.random() * 0.5 + 0.2})`;
                    }
                    update() {
                        const dx = mouse.x - this.x;
                        const dy = mouse.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 300) {
                            this.vx += dx * 0.00015;
                            this.vy += dy * 0.00015;
                        }
                        this.x += this.vx;
                        this.y += this.vy;
                        this.vx *= 0.99;
                        this.vy *= 0.99;
                        if (this.x < 0 || this.x > width) this.vx *= -1;
                        if (this.y < 0 || this.y > height) this.vy *= -1;
                    }
                    draw() {
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                for (let i = 0; i < 150; i++) particles.push(new Particle());
                window.addEventListener('resize', () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; });
                window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });

                function animate() {
                    if (overlay.style.display === 'none') {
                        canvas.remove(); // Cleanup when overlay closes
                        return;
                    }
                    ctx.clearRect(0, 0, width, height);
                    particles.forEach(p => { p.update(); p.draw(); });
                    requestAnimationFrame(animate);
                }
                animate();
            }
        }

        // Inject Physics on Load
        document.addEventListener('DOMContentLoaded', initLandingPhysics);

        // Initialize App
        initApp();

        // Attach Overlay Click Handler
        const overlay = document.getElementById('landing-overlay');
        if (overlay) {
            overlay.addEventListener('click', function () {
                // Force hide overlay
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.style.display = 'none';
                    overlay.classList.add('hidden');
                }, 500);

                // Force show app
                document.querySelectorAll('.app, .header').forEach(el => {
                    el.style.display = 'flex';
                    el.style.opacity = '1';
                });

                // Initialize physics or other logic if needed
                if (typeof startApp === 'function') startApp();
            });
        }

        // ========== GLOBAL EXPOSURE (CRITICAL FIX) ==========
        // This ensures the HTML attributes (onclick="...") can see these objects
        window.app = app;
        window.ModelRegistry = ModelRegistry;
        window.microDataByLeafId = microDataByLeafId;
        window.categoryDescriptions = categoryDescriptions;
        window.leafEngineMap = leafEngineMap;
        window.renderTaxonomyPage = renderTaxonomyPage;
        window.renderAnalyticsPage = renderAnalyticsPage;
        window.renderAuditPage = renderAuditPage;
        window.updateWorkbench = updateWorkbench;
    </script>
    <!--
    MANUAL VERIFICATION CHECKLIST (TFG Platform Official v2.2)
    TEST INPUT SETS:
    1. Put-Call Parity: S=100, K=100, T=0.25, r=5%, σ=20% → |C - P - (S - K·e^(-rT))| < 0.0001
    2. T=0 ITM Call: S=110, K=100, T=0 → Price = 10.00
    3. T=0 OTM Put: S=110, K=100, T=0 → Price = 0.00
    4. Long/Short Sign: Short P&L = -Long P&L
    NOT IMPLEMENTED: 1.3.1.1 (IRS), 3.1.1.1 (Autocall), 3.2.1.1 (Range Accrual)
    DESIGN TOKENS: #003380 (azul corporativo), EB Garamond, Inter, 0px radius
    VERSION: v2.2 | BUILD: 2026-01-30
    -->
    <!-- ========== LIVE MARKET SIMULATION ========== -->
    <style>
        @keyframes flash-green {
            0% {
                background-color: rgba(16, 185, 129, 0.4);
                color: #064e3b;
            }

            100% {
                background-color: transparent;
            }
        }

        @keyframes flash-red {
            0% {
                background-color: rgba(239, 68, 68, 0.4);
                color: #7f1d1d;
            }

            100% {
                background-color: transparent;
            }
        }

        .value-up {
            animation: flash-green 1s ease-out;
            border-radius: 4px;
        }

        .value-down {
            animation: flash-red 1s ease-out;
            border-radius: 4px;
        }

        .market-status {
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--success);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background-color: var(--success);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--success);
            animation: pulse-dot 2s infinite;
        }

        @keyframes pulse-dot {
            0% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.8);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }
    </style>

    <script>
        // ========== MARKET HEARTBEAT ENGINE ==========
        const MarketEngine = {
            isRunning: false,
            updateInterval: 2500, // Update every 2.5 seconds

            // Random walk simulation
            simulateChange: (currentValue, volatility = 0.02) => {
                const change = 1 + (Math.random() * volatility * 2 - volatility);
                return currentValue * change;
            },

            formatMoney: (val) => {
                return val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            },

            start() {
                // Find all KPI values to animate
                const kpiValues = document.querySelectorAll('.kpi-value');
                const greekValues = document.querySelectorAll('.greek-value');

                setInterval(() => {
                    if (!this.isRunning) return;

                    // 1. Update Main Price (Theoretical)
                    if (kpiValues.length > 0) {
                        this.updateElement(kpiValues[0], 0.005); // Low vol for price
                    }

                    // 2. Update Random Greek
                    const randomGreek = greekValues[Math.floor(Math.random() * greekValues.length)];
                    if (randomGreek) {
                        this.updateElement(randomGreek, 0.05); // Higher vol for greeks
                    }

                }, this.updateInterval);
            },

            updateElement(el, vol) {
                // Parse current value (remove commas/symbols)
                let text = el.innerText.replace(/,/g, '').replace(/%/g, '');
                let current = parseFloat(text);

                if (isNaN(current)) return;

                let newValue = this.simulateChange(current, vol);

                // Determine direction
                const isUp = newValue > current;
                const animClass = isUp ? 'value-up' : 'value-down';

                // Update text
                if (el.innerText.includes('%')) {
                    el.innerText = newValue.toFixed(2) + '%';
                } else {
                    el.innerText = this.formatMoney(newValue);
                }

                // Trigger Animation
                el.classList.remove('value-up', 'value-down');
                void el.offsetWidth; // Trigger reflow to restart animation
                el.classList.add(animClass);
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            MarketEngine.start();

            // Add live status to header if possible
            const headerActions = document.querySelector('.header-actions');
            if (headerActions) {
                const statusDiv = document.createElement('div');
                statusDiv.className = 'market-status';
                statusDiv.innerHTML = '<div class="status-dot"></div> LIVE FEED';
                headerActions.prepend(statusDiv);
            }
        });
    </script>

    <!-- ========== AI ASSISTANT (NOTEBOOKLM) ========== -->
    <style>
        .ai-fab {
            position: fixed;
            bottom: 32px;
            right: 32px;
            width: 56px;
            height: 56px;
            background: var(--primary-gradient);
            border-radius: 50%;
            box-shadow: var(--shadow-float);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 900;
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .ai-fab:hover {
            transform: scale(1.1);
        }

        .ai-fab-icon {
            font-size: 24px;
            color: white;
        }

        .ai-window {
            position: fixed;
            bottom: 100px;
            right: 32px;
            width: 380px;
            height: 500px;
            background: var(--surface);
            backdrop-filter: blur(20px);
            border: 1px solid var(--surface-border);
            border-radius: 16px;
            box-shadow: var(--shadow-float);
            display: flex;
            flex-direction: column;
            z-index: 900;
            transform-origin: bottom right;
            transform: scale(0);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .ai-window.open {
            transform: scale(1);
            opacity: 1;
        }

        .ai-header {
            padding: 16px;
            background: var(--primary-gradient);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .ai-title {
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .ai-messages {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .ai-msg {
            max-width: 80%;
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 13px;
            line-height: 1.5;
        }

        .ai-msg.bot {
            background: rgba(0, 0, 0, 0.05);
            color: var(--foreground);
            align-self: flex-start;
            border-bottom-left-radius: 2px;
        }

        .ai-msg.user {
            background: var(--primary);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 2px;
        }

        .ai-input-area {
            padding: 12px;
            border-top: 1px solid var(--border);
            background: rgba(255, 255, 255, 0.5);
            display: flex;
            gap: 8px;
        }

        .ai-input {
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 8px 16px;
            font-size: 13px;
            outline: none;
            background: var(--background);
            color: var(--foreground);
        }

        .ai-send {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Typing indicator */
        .typing-dots {
            display: flex;
            gap: 4px;
            padding: 4px;
        }

        .dot {
            width: 6px;
            height: 6px;
            background: var(--muted-foreground);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
            opacity: 0.6;
        }

        .dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: scale(0);
            }

            40% {
                transform: scale(1);
            }
        }
    </style>

    <!-- Floating Action Button -->
    <div class="ai-fab" onclick="AIChat.toggle()">
        <span class="ai-fab-icon">🧠</span>
    </div>

    <!-- Chat Window -->
    <div class="ai-window" id="aiWindow">
        <div class="ai-header">
            <div class="ai-title">
                <span>🤖</span> M.G.Derivados AI Advisor
            </div>
            <div style="cursor:pointer; opacity:0.8" onclick="AIChat.toggle()">✕</div>
        </div>
        <div class="ai-messages" id="aiMessages">
            <div class="ai-msg bot">
                Hola. Soy tu asistente experto en derivados financieros. Tengo acceso a tu base de conocimientos de
                NotebookLM. ¿En qué puedo ayudarte hoy?
            </div>
        </div>
        <div class="ai-input-area">
            <input type="text" class="ai-input" placeholder="Pregunta sobre opciones, greeks..." id="aiInput"
                onkeypress="if(event.key==='Enter') AIChat.send()">
            <button class="ai-send" onclick="AIChat.send()">➤</button>
        </div>
    </div>

    <script>
        const AIChat = {
            isOpen: false,
            window: document.getElementById('aiWindow'),
            messages: document.getElementById('aiMessages'),
            input: document.getElementById('aiInput'),

            toggle() {
                this.isOpen = !this.isOpen;
                this.window.classList.toggle('open', this.isOpen);
                if (this.isOpen) this.input.focus();
            },

            send() {
                const text = this.input.value.trim();
                if (!text) return;

                // 1. Add User Message
                this.addMessage(text, 'user');
                this.input.value = '';

                // 2. Show Typing Indicator
                const typingId = this.addTypingIndicator();

                // 3. Simulate NotebookLM Response (Mock for UI Demo)
                setTimeout(() => {
                    this.removeMessage(typingId);
                    this.generateResponse(text);
                }, 1500);
            },

            addMessage(text, type) {
                const div = document.createElement('div');
                div.className = `ai-msg ${type}`;
                div.textContent = text;
                this.messages.appendChild(div);
                this.scrollToBottom();
                return div.id = 'msg-' + Date.now();
            },

            removeMessage(id) {
                const el = document.getElementById(id);
                if (el) el.remove();
            },

            addTypingIndicator() {
                const div = document.createElement('div');
                div.className = 'ai-msg bot';
                div.innerHTML = '<div class="typing-dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>';
                div.id = 'typing-' + Date.now();
                this.messages.appendChild(div);
                this.scrollToBottom();
                return div.id;
            },

            scrollToBottom() {
                this.messages.scrollTop = this.messages.scrollHeight;
            },

            generateResponse(query) {
                // Local Knowledge Base (Simulating NotebookLM for instant demo performance)
                const knowledge = {
                    "forward": "Un **Forward** es un contrato a plazo 'hecho a medida' (OTC) entre dos partes para comprar o vender un activo a un precio fijado hoy para una fecha futura. A diferencia de los futuros, no estandarizado y tiene riesgo de contrapartida.",
                    "futuro": "Un **Futuro** es similar a un Forward pero estandarizado y negociado en mercados organizados (como MEFF). La cámara de compensación elimina el riesgo de contrapartida mediante la liquidación diaria de pérdidas y ganancias.",
                    "call": "Una opción **Call** otorga al comprador el derecho (pero no la obligación) a *comprar* el subyacente a un precio de ejercicio (Strike) en una fecha determinada. El comprador paga una prima por este derecho.",
                    "put": "Una opción **Put** otorga al comprador el derecho (pero no la obligación) a *vender* el subyacente a un precio de ejercicio (Strike). Se utiliza típicamente para cubrir carteras contra caídas de mercado.",
                    "delta": "La **Delta** (Δ) mide cuánto cambia el precio de la opción ante un movimiento de 1€ en el subyacente. También se interpreta como la probabilidad aproximada de que la opción termine 'In-The-Money'.",
                    "gamma": "La **Gamma** (Γ) mide la aceleración de la Delta. Es el riesgo de convexidad. Una Gamma alta significa que la Delta cambiará muy rápido, obligando a reajustar la cobertura frecuentemente.",
                    "vega": "La **Vega** (ν) mide la sensibilidad de la opción ante cambios en la volatilidad del mercado. Si la volatilidad sube 1%, el precio de la opción sube por el valor de Vega.",
                    "theta": "La **Theta** (Θ) mide el paso del tiempo. Indica cuánto valor pierde la opción cada día que pasa (Time Decay), asumiendo que nada más cambia.",
                    "swap": "Un **Swap** es un acuerdo para intercambiar flujos de caja futuros. El más común es el IRS (Interest Rate Swap), donde se intercambia un tipo fijo por uno variable.",
                    "default": "No tengo esa información específica en mi base de datos local del TFG, pero puedo buscarla en NotebookLM si conectamos el backend. ¿Quieres probar con términos como 'Delta', 'Forward' o 'Call'?"
                };

                // Simple Keyword Matching Logic
                const q = query.toLowerCase();
                let response = knowledge.default;

                // Check against keys
                for (const [key, answer] of Object.entries(knowledge)) {
                    if (q.includes(key)) {
                        response = answer;
                        break;
                    }
                }

                // Add specific logic for conversational inputs
                if (q.includes('hola') || q.includes('buenos')) response = "¡Hola! Soy M.G.Derivados AI. Pregúntame sobre cualquier derivado.";
                if (q.includes('gracias')) response = "¡De nada! Aquí para ayudar con tu TFG.";

                // Render with simplified markdown support (bold)
                const div = document.createElement('div');
                div.className = 'ai-msg bot';
                div.innerHTML = response.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                this.messages.appendChild(div);
                this.scrollToBottom();
            }
        };
    </script>


    <script>
        // ========== FLUID NAV LOGIC ==========
        document.addEventListener('DOMContentLoaded', () => {
            const navItems = document.querySelectorAll('.nav-item');
            const navBackdrop = document.getElementById('navBackdrop');
            const dropdownWrapper = document.getElementById('dropdownWrapper');
            const dropdownBg = document.getElementById('dropdownBg');
            const dropdownArrow = document.getElementById('dropdownArrow');
            const dropdownSections = document.querySelectorAll('.dropdown-section');
            const navWrapper = document.querySelector('.nav-wrapper');

            let activeDropdown = null;
            let navLeaveTimer = null;

            function showDropdown(item) {
                clearTimeout(navLeaveTimer);
                const targetId = item.getAttribute('data-target');
                const targetSection = document.getElementById(targetId);

                if (!targetSection) {
                    // If no dropdown content (e.g. simple link), hide everything
                    hideDropdown();
                    return;
                }

                // 1. Position Nav Backdrop (The gray pill behind the link)
                const itemRect = item.getBoundingClientRect();
                // Since .nav-backdrop is inside .nav (relative), we calculate relative pos.
                // But .nav is inside .nav-wrapper.
                // .nav-backdrop is absolute to .nav.
                const nav = item.closest('.nav');
                const navRect = nav.getBoundingClientRect();

                navBackdrop.style.width = `${itemRect.width}px`;
                navBackdrop.style.height = `${itemRect.height}px`;
                navBackdrop.style.transform = `translateX(${itemRect.left - navRect.left}px)`;
                navBackdrop.style.opacity = '1';

                // 2. Setup Dropdown dimensions
                // Activate target to measure it
                dropdownSections.forEach(s => s.classList.remove('active'));
                targetSection.classList.add('active');

                const width = targetSection.offsetWidth;
                const height = targetSection.offsetHeight;

                // 3. Move/Resize Dropdown Background
                dropdownBg.style.width = `${width}px`;
                dropdownBg.style.height = `${height}px`;

                // Calculate X position relative to wrapper to center it under the nav item
                const wrapperRect = navWrapper.getBoundingClientRect();
                const centerX = (itemRect.left + itemRect.width / 2) - wrapperRect.left;

                // Center the dropdown bubble
                const bgLeft = centerX - (width / 2);
                dropdownBg.style.transform = `translateX(${bgLeft}px)`;

                // Move content section to match
                // Since section is absolute to .dropdown-wrapper (top left), we visually move it to match bg
                targetSection.style.transform = `translateX(${bgLeft}px)`;

                // Move Arrow
                if (dropdownArrow) {
                    dropdownArrow.style.transform = `translateX(${centerX - 6}px) rotate(45deg)`;
                }

                // Show Wrapper
                dropdownWrapper.classList.add('visible');
            }

            function hideDropdown() {
                navLeaveTimer = setTimeout(() => {
                    dropdownWrapper.classList.remove('visible');
                    navBackdrop.style.opacity = '0';
                    dropdownSections.forEach(s => s.classList.remove('active'));
                }, 150);
            }

            navItems.forEach(item => {
                item.addEventListener('mouseenter', () => showDropdown(item));
                item.addEventListener('mouseleave', hideDropdown);
            });

            dropdownWrapper.addEventListener('mouseenter', () => {
                clearTimeout(navLeaveTimer);
            });

            dropdownWrapper.addEventListener('mouseleave', hideDropdown);
        });
    </script>


    <!-- FRA MODULE INTEGRATION -->
    <style>
        /* Scoped Styles for FRA Module */
        .fra-container {
            font-family: 'Inter', sans-serif;
            text-align: left;
            color: #0f172a;
        }

        .fra-hero {
            background: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('https://images.unsplash.com/photo-1611974765270-ca12586343bb?ixlib=rb-1.2.1&auto=format&fit=crop&w=1920&q=80');
            background-size: cover;
            color: white;
            padding: 40px;
            border-radius: 12px;
            margin-bottom: 24px;
        }

        .fra-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            overflow-x: auto;
            padding-bottom: 5px;
            border-bottom: 1px solid #e2e8f0;
        }

        .fra-tab {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            background: transparent;
            color: #64748b;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .fra-tab:hover {
            background: #f1f5f9;
            color: #0f172a;
        }

        .fra-tab.active {
            background: #eff6ff;
            color: #003380;
        }

        .fra-content-section {
            animation: fadeIn 0.3s ease-out;
        }

        .fra-card {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .fra-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .fra-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            margin-top: 4px;
            font-family: 'JetBrains Mono', monospace;
        }

        .fra-btn {
            width: 100%;
            background: #003380;
            color: white;
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 16px;
        }

        .fra-btn:hover {
            background: #0040a0;
        }

        .hidden {
            display: none;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(5px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>

    <!-- FRA module replaced by unified PricingPipeline implementation below -->
    <script>
        // ========== FLUID NAV LOGIC ==========
        document.addEventListener('DOMContentLoaded', () => {
            const navItems = document.querySelectorAll('.nav-item');
            const navBackdrop = document.getElementById('navBackdrop');
            const dropdownWrapper = document.getElementById('dropdownWrapper');
            const dropdownBg = document.getElementById('dropdownBg');
            const dropdownArrow = document.getElementById('dropdownArrow');
            const dropdownSections = document.querySelectorAll('.dropdown-section');
            const navWrapper = document.querySelector('.nav-wrapper');

            let activeDropdown = null;
            let navLeaveTimer = null;

            function showDropdown(item) {
                clearTimeout(navLeaveTimer);
                const targetId = item.getAttribute('data-target');
                const targetSection = document.getElementById(targetId);

                if (!targetSection) {
                    hideDropdown();
                    return;
                }

                // 1. Position Nav Backdrop
                const itemRect = item.getBoundingClientRect();
                const nav = item.closest('.nav');
                const navRect = nav.getBoundingClientRect();

                navBackdrop.style.width = `${itemRect.width}px`;
                navBackdrop.style.height = `${itemRect.height}px`;
                navBackdrop.style.transform = `translateX(${itemRect.left - navRect.left}px)`;
                navBackdrop.style.opacity = '1';

                // 2. Setup Dropdown dimensions
                dropdownSections.forEach(s => s.classList.remove('active'));
                targetSection.classList.add('active');

                const width = targetSection.offsetWidth;
                const height = targetSection.offsetHeight;

                // 3. Move/Resize Dropdown Background
                dropdownBg.style.width = `${width}px`;
                dropdownBg.style.height = `${height}px`;

                const wrapperRect = navWrapper.getBoundingClientRect();
                const centerX = (itemRect.left + itemRect.width / 2) - wrapperRect.left;
                const bgLeft = centerX - (width / 2);

                dropdownBg.style.transform = `translateX(${bgLeft}px)`;
                targetSection.style.transform = `translateX(${bgLeft}px)`;

                if (dropdownArrow) {
                    dropdownArrow.style.transform = `translateX(${centerX - 6}px) rotate(45deg)`;
                }

                dropdownWrapper.classList.add('visible');
            }

            function hideDropdown() {
                navLeaveTimer = setTimeout(() => {
                    dropdownWrapper.classList.remove('visible');
                    navBackdrop.style.opacity = '0';
                    dropdownSections.forEach(s => s.classList.remove('active'));
                }, 150);
            }

            navItems.forEach(item => {
                item.addEventListener('mouseenter', () => showDropdown(item));
                item.addEventListener('mouseleave', hideDropdown);
            });

            dropdownWrapper.addEventListener('mouseenter', () => {
                clearTimeout(navLeaveTimer);
            });

            dropdownWrapper.addEventListener('mouseleave', hideDropdown);

            // Ensure nav-wrapper has correct positioning context
            if (navWrapper && getComputedStyle(navWrapper).position === 'static') {
                navWrapper.style.position = 'relative';
            }
        });
    </script>

    <!-- ========== DERIVATIVES WORKBENCH UPGRADE LAYER ========== -->
    <script>
        (function () {
            const STORAGE_KEYS = {
                expanded: 'dertax_expanded_nodes',
                selected: 'dertax_selected_node',
                search: 'dertax_search',
                filter: 'dertax_filter_incomplete',
                compare: 'dertax_compare_pair',
                verified: 'dertax_verified_flags'
            };

            const hasLocalStorage = (() => {
                try {
                    localStorage.setItem('__dertax_probe__', '1');
                    localStorage.removeItem('__dertax_probe__');
                    return true;
                } catch (e) { return false; }
            })();

            const loadJSON = (key, fallback) => {
                if (!hasLocalStorage) return fallback;
                try {
                    const raw = localStorage.getItem(key);
                    return raw ? JSON.parse(raw) : fallback;
                } catch (e) { return fallback; }
            };
            const saveJSON = (key, val) => {
                if (!hasLocalStorage) return;
                try { localStorage.setItem(key, JSON.stringify(val)); } catch (e) { }
            };
            const loadSet = (key) => new Set(loadJSON(key, []));
            const saveSet = (key, set) => saveJSON(key, Array.from(set || []));

            // Graceful fallback if Chart.js CDN fails
            if (typeof Chart === 'undefined') {
                console.warn('Chart.js no disponible - usando stub para evitar errores.');
                window.Chart = class {
                    constructor() { }
                    destroy() { }
                };
            }

            // ---------- Helpers ----------
            function findNodeById(nodes, id) {
                for (const n of nodes) {
                    if (n.id === id) return n;
                    if (n.children) {
                        const found = findNodeById(n.children, id);
                        if (found) return found;
                    }
                }
                return null;
            }

            function findPath(nodes, id, acc = []) {
                for (const n of nodes) {
                    const path = [...acc, n];
                    if (n.id === id) return path;
                    if (n.children) {
                        const childPath = findPath(n.children, id, path);
                        if (childPath.length) return childPath;
                    }
                }
                return [];
            }

            function highlight(text, query) {
                if (!query) return text;
                const safe = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                return text.replace(new RegExp(`(${safe})`, 'ig'), '<mark>$1</mark>');
            }

            class TabController {
                constructor({ buttons, panels, activeClass = 'active', hiddenClass = 'hidden', onChange }) {
                    this.buttons = Array.from(buttons || []);
                    this.panels = Array.from(panels || []);
                    this.activeClass = activeClass;
                    this.hiddenClass = hiddenClass;
                    this.onChange = onChange;
                    this.buttons.forEach(btn => {
                        btn.setAttribute('role', 'tab');
                        btn.addEventListener('click', () => this.activate(btn.dataset.tab));
                        btn.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                                e.preventDefault();
                                this.activate(btn.dataset.tab);
                            }
                        });
                    });
                }
                activate(tabName) {
                    this.buttons.forEach(btn => btn.classList.toggle(this.activeClass, btn.dataset.tab === tabName));
                    this.panels.forEach(panel => panel.classList.toggle(this.hiddenClass, panel.dataset.panel !== tabName));
                    if (typeof this.onChange === 'function') this.onChange(tabName);
                }
            }

            // ---------- State extension ----------
            const savedExpanded = loadSet(STORAGE_KEYS.expanded);
            state.expandedNodes = (savedExpanded && savedExpanded.size) ? savedExpanded : new Set(['1', '2', '3']);
            state.searchQuery = loadJSON(STORAGE_KEYS.search, '');
            state.lastSearchQuery = state.searchQuery;
            state.filterIncomplete = !!loadJSON(STORAGE_KEYS.filter, false);
            state.compare = loadJSON(STORAGE_KEYS.compare, { a: null, b: null });
            const savedSelectedId = loadJSON(STORAGE_KEYS.selected, null);
            if (!state.selectedNode && savedSelectedId) {
                const found = findNodeById(taxonomyData, savedSelectedId);
                if (found) state.selectedNode = found;
            }
            const verificationStatus = loadJSON(STORAGE_KEYS.verified, {});

            // ---------- Governance schema ----------
            const TaxonomySchema = [
                { key: 'definition', label: 'Definición' },
                { key: 'type', label: 'Tipo (lineal/no lineal/híbrido/exótico)' },
                { key: 'market', label: 'Mercado (OTC/estandarizado)' },
                { key: 'parties', label: 'Partes' },
                { key: 'underlying', label: 'Subyacente' },
                { key: 'contractSize', label: 'Magnitud contractual' },
                { key: 'dates', label: 'Fechas / vencimiento' },
                { key: 'settlement', label: 'Liquidación' },
                { key: 'payoff', label: 'Payoff / fórmula' },
                { key: 'risks', label: 'Riesgos' },
                { key: 'references', label: 'Referencias / fuentes' }
            ];

            const fieldPaths = {
                definition: ['s1.s1_1'],
                type: ['s1.s1_2'],
                market: ['s1.s1_3'],
                parties: ['s2.s2_1'],
                underlying: ['s2.s2_2'],
                contractSize: ['s2.s2_3'],
                dates: ['s2.s2_4', 's4.s4_1'],
                settlement: ['s3.s3_1', 's3.s3_2', 's3.s3_3'],
                payoff: ['s3.s3_3', 's10.principio'],
                risks: ['s9.mercado', 's9.credito', 's9.liquidez', 's9.operacional', 's9.correlacion'],
                references: ['s5_1', 's6_1']
            };

            const getPathVal = (obj, path) => path.split('.').reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : null), obj);

            function extractField(leafId, field) {
                const micro = microDataByLeafId[leafId];
                if (!micro || !fieldPaths[field]) return null;
                for (const p of fieldPaths[field]) {
                    const val = getPathVal(micro, p);
                    if (typeof val === 'string') return val;
                }
                return null;
            }

            function computeCompleteness(leafId) {
                const missing = [];
                const values = {};
                TaxonomySchema.forEach(f => {
                    const val = extractField(leafId, f.key);
                    const isPending = !val || /pendiente/i.test(val) || /PENDIENTE_VERIFICACI[oó]N/i.test(val) || /PENDIENTE_FUENTES/i.test(val);
                    if (!isPending) values[f.key] = val;
                    else missing.push(f);
                });
                const score = Math.round(((TaxonomySchema.length - missing.length) / TaxonomySchema.length) * 100);
                return { score, missing, values };
            }

            function collectPendings(leafId) {
                const micro = microDataByLeafId[leafId];
                const pendings = [];
                function walk(obj, prefix = '') {
                    if (!obj) return;
                    if (typeof obj === 'string') {
                        if (/PENDIENTE/i.test(obj)) pendings.push({ key: prefix || 'texto', excerpt: obj.slice(0, 160) });
                        return;
                    }
                    if (typeof obj === 'object') {
                        Object.keys(obj).forEach(k => walk(obj[k], prefix ? `${prefix}.${k}` : k));
                    }
                }
                walk(micro, '');
                const leafInfo = leafEngineMap[leafId];
                if (leafInfo && leafInfo.reason && /NOT IMPLEMENTED/i.test(leafInfo.reason)) {
                    pendings.push({ key: 'engine', excerpt: leafInfo.reason });
                }
                if (leafId === '1.1.1.2') {
                    pendings.push({ key: 'convencion_tiempo', excerpt: 'Base ACT/360 asumida para cálculos FRA · PENDIENTE_FUENTES' });
                }
                return pendings;
            }

            function collectAllPendings() {
                const out = [];
                Object.keys(leafEngineMap).forEach(id => {
                    collectPendings(id).forEach(p => out.push({ id, key: p.key, excerpt: p.excerpt }));
                });
                return out;
            }

            function renderAssumptionsPanel(leafId, leafInfo, modelId) {
                const rows = [
                    { label: 'Day count', value: 'PENDIENTE_DE_FUENTES' },
                    { label: 'Rates', value: 'Inputs en % → decimal interna' },
                    { label: 'Discounting', value: 'PENDIENTE_DE_FUENTES (exponencial si aplica)' },
                    { label: 'Signos', value: 'Long (+) comprador / Short (−) vendedor' },
                    { label: 'Modelo', value: modelId || (leafInfo?.engineType || 'PENDIENTE_DE_FUENTES') }
                ];
                return `<div class="card" style="margin-bottom:12px;">
                    <div class="card-header">Assumptions & Conventions</div>
                    <div class="card-body">
                        <table class="data-table"><tbody>
                            ${rows.map(r => `<tr><td>${r.label}</td><td>${r.value}</td></tr>`).join('')}
                        </tbody></table>
                        <button class="btn btn-ghost btn-sm" onclick="document.getElementById('${leafId}-steps')?.classList.toggle('hidden')">Show steps / Ver pasos</button>
                        <pre id="${leafId}-steps" class="hidden" style="background:var(--muted);padding:8px;border-radius:6px;white-space:pre-wrap;font-family:var(--font-mono);">No disponible (se muestra tras calcular)</pre>
                    </div>
                </div>`;
            }

            function renderInstrumentProfile(node, leafInfo, models) {
                const inputs = leafInfo?.engineType === 'linear' ? ['S', 'K', 'T', 'r', 'q'] :
                    leafInfo?.engineType === 'fra' ? ['t', 'n', 'Bid/Ask', 'Nominal'] :
                    ['S', 'K', 'T', 'σ', 'r', 'q'];
                const outputs = leafInfo?.engineType === 'fra' ? ['FRA Bid/Ask', 'Liquidación'] : ['Precio', 'Greeks'];
                const modelList = models && models.length ? models.map(m => `${m.label}${m.impl ? '' : ' (PENDIENTE_DE_FUENTES)'}`).join(', ') : (leafInfo?.engineType || 'PENDIENTE_DE_FUENTES');
                return `<div class="card" style="margin-bottom:12px;">
                    <div class="card-header">Instrument Profile</div>
                    <div class="card-body">
                        <div class="inline-controls" style="gap:16px;">
                            <div><span class="mini-label">¿Qué es?</span><div>${leafInfo?.label || node.label || 'PENDIENTE_DE_FUENTES'}</div></div>
                            <div><span class="mini-label">Inputs</span><div>${inputs.join(', ')}</div></div>
                            <div><span class="mini-label">Modelos</span><div>${modelList}</div></div>
                            <div><span class="mini-label">Outputs</span><div>${outputs.join(', ')}</div></div>
                        </div>
                    </div>
                </div>`;
            }

            const scenarioStoreKey = 'dertax_scenarios';
            const scenarioSlots = { A: null, B: null, C: null };
            Object.assign(scenarioSlots, loadJSON(scenarioStoreKey, scenarioSlots));

            function renderScenarioLab(leafId) {
                return `
                    <div class="card" style="margin-top:12px;">
                        <div class="card-header">Scenario Lab (A/B/C)</div>
                        <div class="card-body">
                            <div class="inline-controls" style="gap:6px;margin-bottom:6px;">
                                ${['A','B','C'].map(s => `<button class="btn btn-ghost btn-sm scenario-save" data-slot="${s}" data-leaf="${leafId}">Guardar ${s}</button>
                                <button class="btn btn-ghost btn-sm scenario-load" data-slot="${s}" data-leaf="${leafId}">Cargar ${s}</button>`).join('')}
                                <button class="btn btn-primary btn-sm scenario-compare" data-leaf="${leafId}">Comparar</button>
                                <button class="btn btn-ghost btn-sm scenario-export" data-leaf="${leafId}">Export CSV</button>
                            </div>
                            <div id="${leafId}-scenario-table"></div>
                        </div>
                    </div>`;
            }

            const scenarioState = { last: {}, slots: loadJSON(scenarioStoreKey, { A: null, B: null, C: null }) };

            function persistScenarios() {
                saveJSON(scenarioStoreKey, scenarioState.slots);
            }

            function getModelsForLeaf(node, leafInfo) {
                const out = [];
                if (!leafInfo) return out;
                if (['bsm', 'digital', 'garman'].includes(leafInfo.engineType || '')) {
                    out.push({ id: 'black-scholes', label: 'Black-Scholes', impl: true });
                    out.push({ id: 'black76', label: 'Black-76 (sobre F)', impl: true });
                    out.push({ id: 'binomial', label: 'Árbol binomial (CRR)', impl: true });
                }
                if (leafInfo.engineType === 'linear') {
                    out.push({ id: 'linear', label: 'Cost of carry', impl: true });
                }
                if (leafInfo.engineType === 'fra') {
                    out.push({ id: 'fra-pricing', label: 'FRA pricing', impl: true });
                    out.push({ id: 'fra-sim', label: 'Sim FRA', impl: true });
                }
                return out;
            }

            function loadModelSelection(leafId, models) {
                const key = `dertax_model_${leafId}`;
                const saved = hasLocalStorage ? localStorage.getItem(key) : null;
                if (saved && models.find(m => m.id === saved && m.impl)) return saved;
                return (models.find(m => m.impl) || models[0] || {}).id || null;
            }

            function saveModelSelection(leafId, modelId) {
                if (!hasLocalStorage) return;
                try { localStorage.setItem(`dertax_model_${leafId}`, modelId); } catch (e) { }
            }

            function isNodeIncomplete(node) {
                if (node.children && node.children.length) {
                    return node.children.some(isNodeIncomplete);
                }
                const info = leafEngineMap[node.id];
                if (!info) return true;
                const { score } = computeCompleteness(node.id);
                return score < 100 || !info.engineType;
            }

            // ---------- Pricing Pipeline ----------
            const PricingPipeline = {
                run: ({ instrumentId, modelId, rawInputs }) => {
                    const trace = [];
                    const errors = [];
                    const outputs = {};
                    const normalized = {};

                    const addTrace = (title, detail) => trace.push({ title, detail });
                    const num = (v) => safeParseFloat(v, 0);

                    if (['bsm', 'digital', 'garman', 'black76', 'binomial', 'black-scholes'].includes(modelId)) {
                        const S = num(rawInputs.S);
                        const F = num(rawInputs.F || rawInputs.forward || rawInputs.future || S);
                        const K = num(rawInputs.K);
                        const T = num(rawInputs.T);
                        const rPct = num(rawInputs.r);
                        const sigmaPct = num(rawInputs.sigma);
                        const qPct = num(rawInputs.q || 0);
                        const optionType = rawInputs.optionType || 'call';

                        normalized.S = S; normalized.K = K; normalized.T = T;
                        normalized.rPct = rPct; normalized.sigmaPct = sigmaPct; normalized.qPct = qPct;
                        normalized.r = rPct / 100; normalized.sigma = sigmaPct / 100; normalized.q = qPct / 100;
                        normalized.F = F;

                        if (S <= 0) errors.push('S debe ser > 0');
                        if (K <= 0) errors.push('K debe ser > 0');
                        if (T < 0) errors.push('T no puede ser negativa');
                        if (sigmaPct <= 0) errors.push('σ debe ser > 0');

                        if (errors.length) return { status: 'error', errors, trace };

                        addTrace('Modelo', modelId);
                        addTrace('Sustitución', `S=${S}, F=${F}, K=${K}, T=${T}, r=${normalized.r.toFixed(4)}, q=${normalized.q.toFixed(4)}, σ=${normalized.sigma.toFixed(4)}`);

                        let engineKey = 'bsm';
                        if (modelId === 'digital') engineKey = 'digital';
                        else if (modelId === 'garman') engineKey = 'garman';
                        else if (modelId === 'black76') engineKey = 'black76';
                        else if (modelId === 'binomial') engineKey = 'binomial';

                        let res;
                        if (engineKey === 'black76') {
                            res = PricingEngines.black76({ F, K, T, r: rPct, sigma: sigmaPct }, optionType === 'put' ? 'put' : 'call');
                        } else if (engineKey === 'binomial') {
                            res = PricingEngines.binomial({ S, K, T, r: rPct, sigma: sigmaPct, q: qPct, steps: rawInputs.steps || 100 }, optionType === 'put' ? 'put' : 'call');
                        } else if (engineKey === 'garman') {
                            res = PricingEngines.garman({ S, K, T, r_d: rPct, r_f: qPct, sigma: sigmaPct }, optionType === 'put' ? 'put' : 'call');
                        } else {
                            res = PricingEngines.bsm({ S, K, T, r: rPct, sigma: sigmaPct, q: qPct }, optionType === 'put' ? 'put' : 'call');
                        }
                        outputs.price = res.price;
                        outputs.greeks = res.greeks || {};
                        outputs.d1 = res.d1;
                        outputs.d2 = res.d2;
                        addTrace('Resultado', `Precio=${isFinite(res.price) ? res.price.toFixed(4) : 'N/A'}`);
                        return { status: 'ok', errors, outputs, normalized, trace };
                    }

                    if (modelId === 'fra-pricing') {
                        const t = num(rawInputs.t_days);
                        const n = num(rawInputs.n_days);
                        const tBid = num(rawInputs.t_bid);
                        const tAsk = num(rawInputs.t_ask);
                        const nBid = num(rawInputs.n_bid);
                        const nAsk = num(rawInputs.n_ask);
                        const days = n - t;
                        normalized.t = t; normalized.n = n; normalized.days = days;
                        normalized.dayCount = 'ACT/360 (operativo, PENDIENTE_FUENTES si difiere)';

                        if (days <= 0) errors.push('n debe ser mayor que t');
                        if (errors.length) return { status: 'error', errors, trace };

                        addTrace('Replica FRA (comprador)', '[(1+nAsk·n/360)/(1+tBid·t/360) -1] · 360/(n-t)');
                        const fraBuy = (((1 + nAsk * n / 360) / (1 + tBid * t / 360)) - 1) * (360 / days);
                        const fraSell = (((1 + nBid * n / 360) / (1 + tAsk * t / 360)) - 1) * (360 / days);
                        outputs.buyer = fraBuy * 100;
                        outputs.seller = fraSell * 100;
                        addTrace('Resultado', `Bid=${outputs.buyer.toFixed(4)}%, Ask=${outputs.seller.toFixed(4)}%`);
                        return { status: 'ok', outputs, normalized, trace };
                    }

                    if (modelId === 'fra-sim') {
                        const N = num(rawInputs.N);
                        const d = num(rawInputs.d);
                        const K = num(rawInputs.K);
                        const R = num(rawInputs.R);
                        normalized.dayCount = 'ACT/360 (operativo, PENDIENTE_FUENTES si difiere)';
                        if (N <= 0) errors.push('Nominal debe ser > 0');
                        if (d <= 0) errors.push('Días debe ser > 0');
                        const tau = d / 360;
                        normalized.tau = tau;
                        const fra = K / 100;
                        const mkt = R / 100;
                        const df = 1 + mkt * tau;
                        const settlement = (N * (mkt - fra) * tau) / df;
                        outputs.settlement = settlement;
                        outputs.tau = tau;
                        outputs.df = df;
                        outputs.K = K;
                        outputs.R = R;
                        outputs.N = N;
                        outputs.direction = settlement >= 0 ? 'Comprador recibe' : 'Comprador paga';
                        addTrace('Fórmula', 'Liquidación = N·(R-K)·τ / (1+R·τ)');
                        addTrace('Sustitución', `N=${N}, R=${mkt.toFixed(4)}, K=${fra.toFixed(4)}, τ=${tau.toFixed(6)}, DF=${df.toFixed(6)}`);
                        addTrace('Resultado', `${outputs.direction}: ${settlement.toFixed(2)} EUR`);
                        if (errors.length) return { status: 'error', errors, trace };
                        return { status: 'ok', outputs, normalized, trace };
                    }

                    return { status: 'error', errors: ['PENDIENTE_FUENTES / NO_IMPLEMENTADO'], trace };
                }
            };

            const ShockEngine = {
                run: ({ instrumentId, modelId, rawInputs }) => {
                    const base = PricingPipeline.run({ instrumentId, modelId, rawInputs });
                    if (base.status !== 'ok' || typeof base.outputs.price !== 'number' || isNaN(base.outputs.price)) {
                        return { base, scenarios: [] };
                    }
                    const defs = [
                        { label: '+1bp r', field: 'r', bp: 1 },
                        { label: '-1bp r', field: 'r', bp: -1 },
                        { label: '+10bp r', field: 'r', bp: 10 },
                        { label: '-10bp r', field: 'r', bp: -10 },
                        { label: '+1% S', field: 'S', rel: 0.01 },
                        { label: '-1% S', field: 'S', rel: -0.01 },
                        { label: '+5% σ', field: 'sigma', rel: 0.05 },
                        { label: '-5% σ', field: 'sigma', rel: -0.05 }
                    ];
                    const scenarios = [];
                    defs.forEach(def => {
                        if (!(def.field in rawInputs)) return;
                        const shocked = { ...rawInputs };
                        if (def.bp) shocked[def.field] = safeParseFloat(rawInputs[def.field], 0) + def.bp / 100;
                        if (def.rel) shocked[def.field] = safeParseFloat(rawInputs[def.field], 0) * (1 + def.rel);
                        const res = PricingPipeline.run({ instrumentId, modelId, rawInputs: shocked });
                        scenarios.push({
                            label: def.label,
                            price: res.outputs.price,
                            delta: res.outputs.price - base.outputs.price,
                            status: res.status
                        });
                    });
                    return { base, scenarios };
                }
            };

            // ---------- Market module ----------
            const marketState = {
                inputs: { spot: 100, forward: 101, r: 3, q: 0, vol: 20, tenor: '3M' },
                smile: [
                    { kRel: 0.8, vol: 24, label: 'DEMO' },
                    { kRel: 0.9, vol: 22, label: 'DEMO' },
                    { kRel: 1.0, vol: 20, label: 'DEMO' },
                    { kRel: 1.1, vol: 21, label: 'DEMO' },
                    { kRel: 1.2, vol: 23, label: 'DEMO' }
                ],
                imported: []
            };
            let smileChart, fwdChart;

            function renderMarketPage() {
                const root = document.getElementById('market-root');
                if (!root) return;
                root.innerHTML = `
                    <div class="page-header">
                        <div class="page-breadcrumb">Mercado</div>
                        <h1 class="page-title">Market Snapshot & Volatility</h1>
                        <p class="page-subtitle">Datos cargados por el usuario o DEMO (marcados como tal). No se asumen fuentes externas.</p>
                    </div>
                    <div class="market-grid">
                        <div class="market-card">
                            <h4>📈 Market Snapshot</h4>
                            <div class="mini-label">Spot</div>
                            <input id="mSpot" class="market-input" type="number" value="${marketState.inputs.spot}">
                            <div class="mini-label">Forward / Future</div>
                            <input id="mFwd" class="market-input" type="number" value="${marketState.inputs.forward}">
                            <div class="mini-label">r (%)</div>
                            <input id="mR" class="market-input" type="number" step="0.01" value="${marketState.inputs.r}">
                            <div class="mini-label">q / div (%)</div>
                            <input id="mQ" class="market-input" type="number" step="0.01" value="${marketState.inputs.q}">
                            <div class="mini-label">Vol ATM (%)</div>
                            <input id="mVol" class="market-input" type="number" step="0.01" value="${marketState.inputs.vol}">
                            <div class="mini-label">Tenor</div>
                            <input id="mTenor" class="market-input" type="text" value="${marketState.inputs.tenor}">
                            <div class="inline-controls" style="margin-top:8px;">
                                <button class="btn btn-primary btn-sm" id="mApply">Aplicar</button>
                                <button class="btn btn-ghost btn-sm" id="mReset">Reset</button>
                            </div>
                        </div>
                        <div class="market-card">
                            <h4>🧭 Volatility Smile</h4>
                            <div class="mini-label">Rango strikes (% de Spot)</div>
                            <div class="inline-controls">
                                <input id="mKmin" type="number" class="market-input" style="max-width:90px;" value="60">
                                <span class="mini-label">a</span>
                                <input id="mKmax" type="number" class="market-input" style="max-width:90px;" value="140">
                                <button class="btn btn-ghost btn-sm" id="mSmileRefresh">Actualizar</button>
                            </div>
                            <div class="chart-wrap"><canvas id="smileChart"></canvas></div>
                        </div>
                        <div class="market-card">
                            <h4>📥 Market Data Import</h4>
                            <p class="mini-label">Pega filas: strike, tenor(años), vol%</p>
                            <textarea id="mImport" class="textarea-compact" placeholder="100,0.25,20&#10;110,0.25,21"></textarea>
                            <div class="inline-controls" style="margin-top:8px;">
                                <button class="btn btn-primary btn-sm" id="mImportBtn">Cargar</button>
                                <button class="btn btn-ghost btn-sm" id="mImportClear">Limpiar</button>
                            </div>
                            <div id="mImportStatus" class="mini-label" style="margin-top:6px;"></div>
                        </div>
                        <div class="market-card">
                            <h4>🌐 Forward/Vol Points</h4>
                            <div class="chart-wrap"><canvas id="fwdChart"></canvas></div>
                            <div class="mini-label" style="margin-top:6px;">Sin datos de usuario se usa DEMO (no real).</div>
                        </div>
                    </div>
                `;

                document.getElementById('mApply')?.addEventListener('click', () => {
                    marketState.inputs = {
                        spot: safeParseFloat(document.getElementById('mSpot').value, 100, 0.0001),
                        forward: safeParseFloat(document.getElementById('mFwd').value, 101, 0.0001),
                        r: safeParseFloat(document.getElementById('mR').value, 3),
                        q: safeParseFloat(document.getElementById('mQ').value, 0),
                        vol: safeParseFloat(document.getElementById('mVol').value, 20, 0),
                        tenor: document.getElementById('mTenor').value || 'TENOR_PENDIENTE_DE_FUENTES'
                    };
                    updateMarketCharts();
                });
                document.getElementById('mReset')?.addEventListener('click', () => {
                    marketState.inputs = { spot: 100, forward: 101, r: 3, q: 0, vol: 20, tenor: '3M' };
                    document.getElementById('mSpot').value = 100;
                    document.getElementById('mFwd').value = 101;
                    document.getElementById('mR').value = 3;
                    document.getElementById('mQ').value = 0;
                    document.getElementById('mVol').value = 20;
                    document.getElementById('mTenor').value = '3M';
                    updateMarketCharts();
                });
                document.getElementById('mSmileRefresh')?.addEventListener('click', updateMarketCharts);
                document.getElementById('mImportBtn')?.addEventListener('click', importMarketData);
                document.getElementById('mImportClear')?.addEventListener('click', () => {
                    marketState.imported = [];
                    document.getElementById('mImportStatus').textContent = 'Import limpio';
                    updateMarketCharts();
                });

                updateMarketCharts();
            }

            function importMarketData() {
                const src = document.getElementById('mImport')?.value || '';
                const lines = src.split('\n').map(l => l.trim()).filter(Boolean);
                const parsed = [];
                for (const line of lines) {
                    const parts = line.split(',').map(p => p.trim());
                    if (parts.length < 3) continue;
                    const K = safeParseFloat(parts[0], NaN);
                    const T = safeParseFloat(parts[1], NaN);
                    const vol = safeParseFloat(parts[2], NaN);
                    if (!isFinite(K) || !isFinite(T) || !isFinite(vol)) continue;
                    parsed.push({ K, T, vol, label: 'USER' });
                }
                const status = document.getElementById('mImportStatus');
                if (!parsed.length) {
                    status.textContent = 'Sin líneas válidas';
                    status.style.color = 'var(--danger)';
                } else {
                    marketState.imported = parsed;
                    status.textContent = `Cargados ${parsed.length} puntos`;
                    status.style.color = 'var(--foreground)';
                }
                updateMarketCharts();
            }

            function updateMarketCharts() {
                const spot = marketState.inputs.spot;
                const kmin = safeParseFloat(document.getElementById('mKmin')?.value, 60);
                const kmax = safeParseFloat(document.getElementById('mKmax')?.value, 140);
                const smileData = (marketState.imported.length ? marketState.imported.map(p => ({ strike: p.K, vol: p.vol, label: p.label })) :
                    marketState.smile.map(p => ({ strike: p.kRel * spot, vol: p.vol, label: p.label })))
                    .filter(p => p.strike >= spot * kmin / 100 && p.strike <= spot * kmax / 100);

                const smileCtx = document.getElementById('smileChart');
                if (smileCtx && Chart) {
                    if (smileChart) smileChart.destroy();
                    smileChart = new Chart(smileCtx, {
                        type: 'line',
                        data: {
                            labels: smileData.map(p => p.strike.toFixed(2)),
                            datasets: [{
                                label: 'Vol (%)',
                                data: smileData.map(p => p.vol),
                                borderColor: '#003380',
                                backgroundColor: 'rgba(0,51,128,0.08)',
                                tension: 0.3,
                                pointRadius: 3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => `${ctx.parsed.y.toFixed(2)}% (${smileData[ctx.dataIndex].label})` } } },
                            scales: {
                                x: { title: { display: true, text: 'Strike' } },
                                y: { title: { display: true, text: 'Vol (%)' } }
                            }
                        }
                    });
                }

                const fwdData = marketState.imported.length ? marketState.imported : [
                    { K: spot, T: 0.25, vol: marketState.inputs.vol, label: 'DEMO' },
                    { K: spot, T: 0.5, vol: marketState.inputs.vol + 1, label: 'DEMO' },
                    { K: spot, T: 1, vol: marketState.inputs.vol + 2, label: 'DEMO' }
                ];
                const fwdCtx = document.getElementById('fwdChart');
                if (fwdCtx && Chart) {
                    if (fwdChart) fwdChart.destroy();
                    fwdChart = new Chart(fwdCtx, {
                        type: 'scatter',
                        data: {
                            datasets: [{
                                label: 'Vol term (DEMO si no hay datos)',
                                data: fwdData.map(p => ({ x: p.T, y: p.vol })),
                                borderColor: '#0ea5e9',
                                backgroundColor: 'rgba(14,165,233,0.2)',
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                x: { title: { display: true, text: 'Tenor (años)' } },
                                y: { title: { display: true, text: 'Vol (%)' } }
                            }
                        }
                    });
                }
            }

            // ---------- Workbench override (Pipeline) ----------
            function updateWorkbenchUnified() {
                const spot = document.getElementById('wbSpotInput');
                const strike = document.getElementById('wbStrikeInput');
                const time = document.getElementById('wbTimeInput');
                const vol = document.getElementById('wbVolInput');
                const rate = document.getElementById('wbRateInput');
                if (!spot || !strike || !time || !vol || !rate) return;

                const S = safeParseFloat(spot.value, 100);
                const K = safeParseFloat(strike.value, 100);
                const T = safeParseFloat(time.value, 0.25);
                const sigma = safeParseFloat(vol.value, 20);
                const r = safeParseFloat(rate.value, 5);
                const optionType = document.querySelector('#typeToggle .toggle-btn.call.active') ? 'call' : 'put';
                const position = document.querySelector('#posToggle .toggle-btn.active')?.dataset.pos || 'long';

                const res = PricingPipeline.run({ instrumentId: 'workbench', modelId: 'bsm', rawInputs: { S, K, T, r, sigma, q: 0, optionType } });
                if (res.status === 'error' || !isFinite(res.outputs.price)) {
                    displayWorkbenchError(res.errors ? res.errors.join('; ') : 'Error');
                    return;
                }

                const sign = position === 'short' ? -1 : 1;
                const price = res.outputs.price * sign;
                const intrinsic = optionType === 'call' ? Math.max(S - K, 0) : Math.max(K - S, 0);
                const timeVal = res.outputs.price - intrinsic;
                const moneyness = S > K ? 'ITM' : S === K ? 'ATM' : 'OTM';

                const setText = (id, val) => { const el = document.getElementById(id); if (el) el.textContent = val; };
                setText('wbSpotDisplay', S.toFixed(2));
                setText('wbStrikeDisplay', K.toFixed(2));
                setText('wbTimeDisplay', `${T.toFixed(2)} yr`);
                setText('wbVolDisplay', `${sigma.toFixed(2)}%`);
                setText('wbRateDisplay', `${r.toFixed(2)}%`);
                setText('wbPriceDisplay', price.toFixed(4));
                setText('wbIntrinsicDisplay', intrinsic.toFixed(4));
                setText('wbTimeValueDisplay', timeVal.toFixed(4));
                setText('wbMoneynessDisplay', moneyness);
                setText('wbD1Display', res.outputs.d1?.toFixed ? res.outputs.d1.toFixed(4) : 'N/A');
                setText('wbD2Display', res.outputs.d2?.toFixed ? res.outputs.d2.toFixed(4) : 'N/A');

                const premium = res.outputs.price;
                let breakEven = optionType === 'call' ? K + premium : K - premium;
                let maxLoss = position === 'long' ? premium : (optionType === 'call' ? 'Ilimitada' : `≈${(K - premium).toFixed(2)}`);
                let maxProfit;
                if (optionType === 'call') maxProfit = position === 'long' ? 'Ilimitada' : `Prima ${premium.toFixed(2)}`;
                else maxProfit = position === 'long' ? `${(K - premium).toFixed(2)}` : premium.toFixed(2);
                setText('wbBreakEven', isFinite(breakEven) ? breakEven.toFixed(4) : 'N/A');
                setText('wbMaxLoss', typeof maxLoss === 'string' ? maxLoss : maxLoss.toFixed(2));
                setText('wbMaxProfit', typeof maxProfit === 'string' ? maxProfit : maxProfit.toString());
                setText('wbSign', `${position === 'long' ? 'Long' : 'Short'} ${optionType}`);

                displayGreek('wbDeltaValue', res.outputs.greeks?.delta * sign ?? NaN);
                displayGreek('wbGammaValue', res.outputs.greeks?.gamma ?? NaN);
                displayGreek('wbThetaValue', res.outputs.greeks?.theta * sign ?? NaN);
                displayGreek('wbVegaValue', res.outputs.greeks?.vega ?? NaN);
                displayGreek('wbRhoValue', res.outputs.greeks?.rho * sign ?? NaN);

                updateSensitivityCharts({
                    calc: (p) => PricingPipeline.run({ instrumentId: 'workbench', modelId: 'bsm', rawInputs: p })
                }, { S, K, T, r, sigma, q: 0 });

                drawChart(S, K, res.outputs.price, optionType, sign);
            }
            window.updateWorkbench = updateWorkbenchUnified;

            // ---------- Dynamic pricing override (Pipeline) ----------
            function runDynamicPricingUnified() {
                if (!currentModel) return;
                const params = {};
                currentModel.inputs.forEach(inp => {
                    params[inp.id] = safeParseFloat(document.getElementById(`inp-${inp.id}`).value, inp.default);
                });

                let modelId = 'bsm';
                if (params.F && !params.K) modelId = 'linear';
                if (currentModel.calc && currentModel.calc.name && currentModel.calc.name.toLowerCase().includes('digital')) modelId = 'digital';

                const res = PricingPipeline.run({ instrumentId: 'dynamic', modelId, rawInputs: params });
                const out = document.getElementById('dynOutput');
                if (!out) return;

                if (res.status === 'error') {
                    out.innerHTML = `<div class="alert alert-danger">${res.errors.join('<br>')}</div>`;
                    return;
                }

                const val = res.outputs.price;
                out.innerHTML = `<div style="text-align:center;">
                        <div style="font-size:12px;color:var(--muted-foreground);text-transform:uppercase;margin-bottom:8px;">PV</div>
                        <div class="dyn-result-val">${isFinite(val) ? val.toFixed(4) : 'N/A'}</div>
                        ${res.outputs.greeks ? renderGreeksTiny(res.outputs.greeks) : ''}
                    </div>`;

                // Sensitivity chart using pipeline
                const pipelineModel = {
                    calc: (p) => {
                        const r = PricingPipeline.run({ instrumentId: 'dynamic', modelId, rawInputs: p });
                        return { price: r.outputs.price || 0 };
                    }
                };
                updateSensitivityCharts(pipelineModel, params);
            }
            window.runDynamicPricing = runDynamicPricingUnified;

            // ---------- Tree rendering ----------
            function nodeMatchesQuery(node, query) {
                if (!query) return true;
                const q = query.toLowerCase();
                return node.label.toLowerCase().includes(q) || node.id.toLowerCase().includes(q);
            }

            function hasMatchOrDesc(node, query) {
                if (nodeMatchesQuery(node, query)) return true;
                return (node.children || []).some(child => hasMatchOrDesc(child, query));
            }

            function renderTree(nodes, container, level = 0) {
                const ul = document.createElement('ul');
                nodes.forEach(node => {
                    if (state.filterIncomplete && !isNodeIncomplete(node)) return;
                    if (!hasMatchOrDesc(node, state.searchQuery)) return;

                    const li = document.createElement('li');
                    const hasChildren = Array.isArray(node.children) && node.children.length > 0;
                    const isExpanded = state.expandedNodes.has(node.id);
                    const isSelected = state.selectedNode && state.selectedNode.id === node.id;
                    const leafInfo = leafEngineMap[node.id];
                    const completeness = leafInfo ? computeCompleteness(node.id).score : 0;

                    const row = document.createElement('div');
                    row.className = 'tree-node' + (isSelected ? ' selected' : '');

                    const caret = document.createElement('button');
                    caret.type = 'button';
                    caret.className = 'caret' + (hasChildren ? (isExpanded ? ' open' : '') : ' none');
                    caret.textContent = hasChildren ? (isExpanded ? '▼' : '▶') : '•';
                    caret.setAttribute('aria-label', hasChildren ? 'Expandir/Colapsar' : 'Sin hijos');
                    caret.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (!hasChildren) return;
                        if (isExpanded) state.expandedNodes.delete(node.id);
                        else state.expandedNodes.add(node.id);
                        saveSet(STORAGE_KEYS.expanded, state.expandedNodes);
                        render();
                    });

                    const labelBtn = document.createElement('button');
                    labelBtn.type = 'button';
                    labelBtn.className = 'node-label';
                    labelBtn.dataset.nodeId = node.id;
                    labelBtn.innerHTML = `<span class="node-id">${node.id}</span> ${highlight(node.label, state.searchQuery)}`;
                    labelBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        state.selectedNode = node;
                        state.page = 'taxonomy';
                        saveJSON(STORAGE_KEYS.selected, node.id);
                        render();
                    });
                    labelBtn.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            labelBtn.click();
                        }
                    });

                    const badge = document.createElement('span');
                    badge.className = 'badge badge-neutral';
                    if (hasChildren) badge.textContent = 'Carpeta';
                    else if (leafInfo && leafInfo.engineType) badge.textContent = 'Implementado';
                    else badge.textContent = 'N/A';
                    badge.style.marginLeft = 'auto';

                    const completenessBadge = document.createElement('span');
                    completenessBadge.className = 'badge';
                    completenessBadge.textContent = hasChildren ? '' : `${completeness}%`;
                    completenessBadge.style.background = completeness >= 70 ? 'var(--success-muted)' : completeness >= 40 ? 'var(--warning-muted)' : 'var(--danger-muted)';
                    completenessBadge.style.marginLeft = '6px';
                    completenessBadge.style.color = 'var(--foreground)';

                    row.appendChild(caret);
                    row.appendChild(labelBtn);
                    if (!hasChildren) { row.appendChild(badge); row.appendChild(completenessBadge); }
                    li.appendChild(row);

                    if (hasChildren && isExpanded) {
                        const childContainer = document.createElement('div');
                        childContainer.className = 'tree-children open';
                        renderTree(node.children, childContainer, level + 1);
                        li.appendChild(childContainer);
                    }
                    ul.appendChild(li);
                });
                container.appendChild(ul);
            }

            // ---------- Taxonomy page ----------
        function renderTaxonomyPage() {
            const page = document.getElementById('page-taxonomy');
            if (!page) return;

            const selected = state.selectedNode;
            const breadcrumb = selected ? findPath(taxonomyData, selected.id).map(n => n.label).join(' › ') : 'Taxonomía de derivados';

            const searchBox = `
                <div class="card" style="margin-bottom:12px;">
                    <div style="display:flex; gap:8px; align-items:center;">
                        <input id="taxonomySearch" type="search" placeholder="Buscar por ID, nombre o tag" value="${state.searchQuery || ''}" style="flex:1; padding:10px 12px; border:1px solid var(--border); border-radius:8px;">
                        <button class="btn btn-ghost btn-sm" id="btnExpandAll">Expandir todo</button>
                        <button class="btn btn-ghost btn-sm" id="btnCollapseAll">Colapsar todo</button>
                        <button class="btn btn-ghost btn-sm ${state.filterIncomplete ? 'btn-primary' : ''}" id="btnIncomplete">Mostrar solo incompletos</button>
                        <button class="btn btn-primary btn-sm" id="btnDownloadSnapshot">Descargar HTML (snapshot)</button>
                    </div>
                </div>`;

            const comparePanel = renderComparePanel();

            const overviewMetrics = `
                <div class="page-header">
                    <div class="page-breadcrumb">Derivatives Taxonomy</div>
                    <h1 class="page-title">Taxonomy Explorer 2.0</h1>
                    <p class="page-subtitle">Selecciona un instrumento en la barra lateral para ver el detalle, gobierno y pricing.</p>
                </div>
                <div class="kpi-grid">
                    <div class="kpi"><div class="kpi-value">${Object.keys(leafEngineMap).length}</div><div class="kpi-label">Instrumentos hojas</div></div>
                    <div class="kpi kpi-success"><div class="kpi-value">${Object.values(leafEngineMap).filter(l => l.engineType).length}</div><div class="kpi-label">Implementados</div></div>
                    <div class="kpi kpi-warning"><div class="kpi-value">${Object.values(leafEngineMap).filter(l => !l.engineType).length}</div><div class="kpi-label">Pendientes</div></div>
                    <div class="kpi"><div class="kpi-value">${state.searchQuery ? 'Filtro activo' : 'Sin filtro'}</div><div class="kpi-label">Estado búsqueda</div></div>
                </div>`;
            const help = `
                <div class="card">
                    <div class="card-header">How to use / Qué está implementado</div>
                    <div class="card-body">
                        <ul style="line-height:1.8;">
                            <li>Instrumentos con motor: Opciones vanilla (BS/Black-76/Binomial), FRA (pricing & liquidación), forwards lineales.</li>
                            <li>Modelos disponibles se adaptan al instrumento; selecciona en “Modelo de precios”.</li>
                            <li>Scenario Lab: guarda A/B/C y compara; exporta CSV.</li>
                            <li>Health Check muestra NaN/inputs faltantes tras calcular.</li>
                            <li>Pendiente de fuentes se lista en QA (Audit).</li>
                        </ul>
                        <div class="mini-label">Changelog 2026-02-05: mercado reforzado, binomial añadido, autoscale payoff, Scenario Lab, Assumptions panel, export CSV/HTML.</div>
                    </div>
                </div>`;

            const detailHtml = selected ? renderNodeDetailHtml(selected) : `<div class="card"><div class="card-header">Selecciona un nodo</div><div class="card-body">Haz clic en la clasificación de la izquierda para ver el detalle.</div></div>`;

            page.innerHTML = `
                <div class="page-header">
                    <div class="page-breadcrumb">${breadcrumb}</div>
                    <h1 class="page-title">Derivatives Taxonomy Workbench</h1>
                    <p class="page-subtitle">Gobernanza, trazabilidad y simulación sobre la taxonomía existente.</p>
                </div>
                ${searchBox}
                ${comparePanel}
                ${overviewMetrics}
                ${help}
                <div id="taxonomyDetailContainer">${detailHtml}</div>
            `;

            const searchEl = document.getElementById('taxonomySearch');
            searchEl?.addEventListener('input', (e) => {
                state.searchQuery = e.target.value.trim();
                state.lastSearchQuery = state.searchQuery;
                saveJSON(STORAGE_KEYS.search, state.searchQuery);
                render();
            });
            document.getElementById('btnExpandAll')?.addEventListener('click', () => {
                const allIds = [];
                (function collect(nodes) { nodes.forEach(n => { allIds.push(n.id); if (n.children) collect(n.children); }); })(taxonomyData);
                state.expandedNodes = new Set(allIds);
                saveSet(STORAGE_KEYS.expanded, state.expandedNodes);
                render();
            });
            document.getElementById('btnCollapseAll')?.addEventListener('click', () => {
                state.expandedNodes = new Set();
                saveSet(STORAGE_KEYS.expanded, state.expandedNodes);
                render();
            });
            document.getElementById('btnIncomplete')?.addEventListener('click', () => {
                state.filterIncomplete = !state.filterIncomplete;
                saveJSON(STORAGE_KEYS.filter, state.filterIncomplete);
                render();
            });
            document.getElementById('btnDownloadSnapshot')?.addEventListener('click', downloadSnapshot);

            bindCompareEvents();
            if (selected) bindDetailEvents(selected);
        }

            function renderComparePanel() {
                const leafOptions = Object.keys(leafEngineMap).map(id => `<option value="${id}">${id} — ${leafEngineMap[id].label}</option>`).join('');
                return `
                    <div class="card" style="margin-bottom:12px;">
                        <div class="card-header">🔀 Modo Comparar</div>
                        <div class="card-body" style="display:grid;grid-template-columns:1fr 1fr auto;gap:10px;align-items:center;">
                            <select id="cmpA">${leafOptions}</select>
                            <select id="cmpB">${leafOptions}</select>
                            <button class="btn btn-primary btn-sm" id="cmpRun">Comparar</button>
                        </div>
                        <div id="cmpResult"></div>
                    </div>`;
            }

            function bindCompareEvents() {
                const cmpA = document.getElementById('cmpA');
                const cmpB = document.getElementById('cmpB');
                const cmpResult = document.getElementById('cmpResult');
                const btn = document.getElementById('cmpRun');
                if (!cmpA || !cmpB || !btn) return;
                cmpA.value = state.compare.a || cmpA.value;
                cmpB.value = state.compare.b || cmpB.value;
                const renderCmp = () => {
                    const idA = cmpA.value;
                    const idB = cmpB.value;
                    state.compare = { a: idA, b: idB };
                    saveJSON(STORAGE_KEYS.compare, state.compare);
                    const cA = computeCompleteness(idA);
                    const cB = computeCompleteness(idB);
                    const rows = TaxonomySchema.map(f => {
                        const vA = extractField(idA, f.key) || 'PENDIENTE_FUENTES';
                        const vB = extractField(idB, f.key) || 'PENDIENTE_FUENTES';
                        return `<tr><td>${f.label}</td><td>${vA}</td><td>${vB}</td></tr>`;
                    }).join('');
                    cmpResult.innerHTML = `<table class="data-table"><thead><tr><th>Campo</th><th>${idA}</th><th>${idB}</th></tr></thead><tbody>${rows}</tbody></table>`;
                };
                btn.addEventListener('click', renderCmp);
                renderCmp();
            }

            function renderNodeDetailHtml(node) {
                const hasChildren = node.children && node.children.length;
                const leafInfo = leafEngineMap[node.id];
                if (hasChildren) {
                    return `
                        <div class="card">
                            <div class="card-header">📂 Categoría</div>
                            <div class="card-body">
                                <p>Este nodo es una categoría. Selecciona una hoja para ver pricing y trazabilidad.</p>
                                <div style="margin-top:8px;color:var(--muted-foreground);">${categoryDescriptions[node.id]?.definition || ''}</div>
                            </div>
                        </div>`;
                }

                const completeness = computeCompleteness(node.id);
                const pending = collectPendings(node.id);
                const leafBadge = leafInfo && leafInfo.engineType ? `<span class="badge badge-success">${leafInfo.engineType}</span>` : `<span class="badge badge-danger">No implementado</span>`;
                const governance = renderGovernancePanel(node.id, completeness, pending);
                const pricingUI = leafInfo ? renderPricingUI(node, leafInfo) : `<div class="card"><div class="card-header">Pricing</div><div class="card-body">PENDIENTE_FUENTES / NO_IMPLEMENTADO</div></div>`;
                const pendingPanel = renderPendingPanel(node.id, pending);
                const assumptionsPanel = renderAssumptionsPanel(node.id, leafInfo, selectedModel);
                const instrumentProfile = renderInstrumentProfile(node, leafInfo, models);
                const scenarioLab = renderScenarioLab(node.id);
                const healthPanel = `<div class="card" style="margin-top:12px;"><div class="card-header">Health Check</div><div class="card-body"><div id="${prefix}_health" class="mini-label">A la espera de cálculo...</div></div></div>`;

                return `
                    <div class="card">
                        <div class="card-header" style="display:flex;gap:8px;align-items:center;">
                            <span class="node-id">${node.id}</span>
                            <strong>${node.label}</strong>
                            ${leafBadge}
                        </div>
                        <div class="card-body">
                            ${instrumentProfile}
                            ${assumptionsPanel}
                            ${governance}
                            ${pricingUI}
                            ${healthPanel}
                            ${scenarioLab}
                            ${pendingPanel}
                        </div>
                    </div>`;
            }

            function renderGovernancePanel(leafId, completeness, pending) {
                const missingList = completeness.missing.map(f => `<li>${f.label}</li>`).join('') || '<li>Sin pendientes en esquema</li>';
                const flagCount = pending.length;
                return `
                    <div class="card" style="margin-bottom:12px;">
                        <div class="card-header">🛡️ Gobierno del instrumento</div>
                        <div class="card-body">
                            <div style="display:flex;gap:12px;align-items:center;">
                                <div style="flex:1;">
                                    <div style="font-size:12px;color:var(--muted-foreground);">Score de completitud</div>
                                    <div style="height:10px;background:var(--muted);border-radius:999px;overflow:hidden;">
                                        <div style="width:${completeness.score}%;height:10px;background:${completeness.score >= 70 ? 'var(--success)' : completeness.score >= 40 ? 'var(--warning)' : 'var(--danger)'};"></div>
                                    </div>
                                    <div style="font-weight:700;margin-top:4px;">${completeness.score}% completo</div>
                                </div>
                                <div class="badge ${flagCount ? 'badge-warning' : 'badge-success'}">${flagCount} PENDIENTE_FUENTES</div>
                            </div>
                            <div style="margin-top:10px;">
                                <strong>Campos faltantes:</strong>
                                <ul>${missingList}</ul>
                            </div>
                            <div style="margin-top:10px;">
                                <strong>Quality flags:</strong>
                                <ul>
                                    <li>PENDIENTE_FUENTES: ${flagCount}</li>
                                    <li>Inputs sin validar: 0 (validación aplicada en PricingPipeline)</li>
                                </ul>
                            </div>
                        </div>
                    </div>`;
            }

            function renderPendingPanel(leafId, pending) {
                if (!pending.length) return '';
                const items = pending.map((p, idx) => {
                    const key = `${leafId}|${p.key}|${idx}`;
                    const verified = verificationStatus[key] === 'verificado';
                    return `<tr>
                        <td>${leafId}</td>
                        <td>${p.key}</td>
                        <td>${p.excerpt}</td>
                        <td style="text-align:center;"><button class="btn btn-ghost btn-sm pending-toggle" data-key="${key}" data-status="${verified ? 'verificado' : 'pendiente'}">${verified ? 'Verificado' : 'Pendiente'}</button></td>
                    </tr>`;
                }).join('');
                return `
                    <div class="card" style="margin-top:12px;">
                        <div class="card-header">📌 Índice “PENDIENTE_FUENTES”</div>
                        <div class="card-body">
                            <table class="data-table"><thead><tr><th>Instrumento</th><th>Sección</th><th>Extracto</th><th>Estado</th></tr></thead><tbody>${items}</tbody></table>
                        </div>
                    </div>`;
            }

            function renderPricingUI(node, leafInfo) {
                const models = getModelsForLeaf(node, leafInfo);
                if (node.id === '1.1.1.2') models.length = 0; // FRA usa lógica dedicada
                const selectedModel = loadModelSelection(node.id, models);
                const modelSelect = models.length ? `
                    <div class="inline-controls" style="margin:8px 0;">
                        <div class="mini-label">Modelo de precios</div>
                        <select id="${node.id}-model-select" class="market-input" style="max-width:240px;">
                            ${models.map(m => `<option value="${m.id}" ${m.id === selectedModel ? 'selected' : ''} ${m.impl ? '' : 'disabled'}>${m.label}${m.impl ? '' : ' · PENDIENTE_DE_FUENTES'}</option>`).join('')}
                        </select>
                        <span class="mini-label">Dependiente del instrumento</span>
                    </div>` : '';

                const isFRA = node.id === '1.1.1.2';
                const prefix = isFRA ? 'fra' : 'px';
                const tabButtons = `
                    <div class="tab-nav" data-tab-group="${prefix}">
                        <button class="tab-btn active" data-tab="pricing">Pricing</button>
                        <button class="tab-btn" data-tab="sim">Simulación</button>
                        <button class="tab-btn" data-tab="trace">Trazabilidad</button>
                        <button class="tab-btn" data-tab="escenarios">Escenarios</button>
                    </div>`;

                const pricingForm = isFRA ? `
                    <div class="fra-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;">
                        <label>t días<input type="number" id="${prefix}_t" value="90" class="fra-input"></label>
                        <label>n días<input type="number" id="${prefix}_n" value="180" class="fra-input"></label>
                        <div></div>
                        <label>t Bid (%)<input type="number" id="${prefix}_tbid" value="3.5" class="fra-input" step="0.01"></label>
                        <label>t Ask (%)<input type="number" id="${prefix}_task" value="3.54" class="fra-input" step="0.01"></label>
                        <div></div>
                        <label>n Bid (%)<input type="number" id="${prefix}_nbid" value="3.75" class="fra-input" step="0.01"></label>
                        <label>n Ask (%)<input type="number" id="${prefix}_nask" value="3.8" class="fra-input" step="0.01"></label>
                    </div>
                    <button class="btn btn-primary" id="${prefix}_run_pricing">Calcular cotización</button>
                    <div id="${prefix}_pricing_out" class="panel" style="margin-top:8px;"></div>
                ` : `
                    <div class="fra-grid" style="display:grid;grid-template-columns:repeat(3,1fr);gap:10px;">
                        <label>Spot S<input type="number" id="${prefix}_S" value="100" class="fra-input"></label>
                        <label>Strike K<input type="number" id="${prefix}_K" value="100" class="fra-input"></label>
                        <label>Tiempo T (años)<input type="number" id="${prefix}_T" value="0.25" step="0.01" class="fra-input"></label>
                        <label>r (%)<input type="number" id="${prefix}_r" value="5" step="0.01" class="fra-input"></label>
                        <label>σ (%)<input type="number" id="${prefix}_sigma" value="20" step="0.01" class="fra-input"></label>
                        <label>q/div (%)<input type="number" id="${prefix}_q" value="0" step="0.01" class="fra-input"></label>
                    </div>
                    <button class="btn btn-primary" id="${prefix}_run_pricing">Calcular</button>
                    <div id="${prefix}_pricing_out" class="panel" style="margin-top:8px;"></div>
                `;

                const simForm = isFRA ? `
                    <div class="fra-grid" style="display:grid;grid-template-columns:repeat(2,1fr);gap:10px;">
                        <label>Nominal N<input type="number" id="${prefix}_N" value="1000000" class="fra-input"></label>
                        <label>Días d<input type="number" id="${prefix}_d" value="182" class="fra-input"></label>
                        <label>FRA K (%)<input type="number" id="${prefix}_K" value="4.00" class="fra-input" step="0.01"></label>
                        <label>Mercado R (%)<input type="number" id="${prefix}_R" value="4.50" class="fra-input" step="0.01"></label>
                    </div>
                    <button class="btn btn-primary" id="${prefix}_run_sim">Simular liquidación</button>
                    <div id="${prefix}_sim_out" class="panel" style="margin-top:8px;"></div>
                ` : `
                    <div style="color:var(--muted-foreground);">La simulación aplica el motor de shocks deterministas.</div>
                    <div id="${prefix}_sim_out" class="panel" style="margin-top:8px;"></div>
                `;

                return `
                    ${tabButtons}
                    <div class="tab-panel" data-panel="pricing">
                        ${modelSelect}
                        ${pricingForm}
                    </div>
                    <div class="tab-panel hidden" data-panel="sim">
                        ${simForm}
                    </div>
                    <div class="tab-panel hidden" data-panel="trace">
                        <div id="${prefix}_trace" class="panel" style="font-family:var(--font-mono);white-space:pre-wrap;"></div>
                    </div>
                    <div class="tab-panel hidden" data-panel="escenarios">
                        <div id="${prefix}_scenarios" class="panel"></div>
                    </div>`;
            }

            function bindDetailEvents(node) {
                const leafInfo = leafEngineMap[node.id];
                const prefix = node.id === '1.1.1.2' ? 'fra' : 'px';
                const tabGroup = document.querySelector(`[data-tab-group="${prefix}"]`);
                if (tabGroup) {
                    new TabController({
                        buttons: tabGroup.querySelectorAll('.tab-btn'),
                        panels: tabGroup.parentElement.querySelectorAll('.tab-panel'),
                        activeClass: 'active',
                        hiddenClass: 'hidden'
                    });
                }

                document.querySelectorAll('.pending-toggle').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const key = btn.dataset.key;
                        const current = btn.dataset.status === 'verificado';
                        verificationStatus[key] = current ? 'pendiente' : 'verificado';
                        saveJSON(STORAGE_KEYS.verified, verificationStatus);
                        btn.dataset.status = verificationStatus[key];
                        btn.textContent = verificationStatus[key] === 'verificado' ? 'Verificado' : 'Pendiente';
                    });
                });

                const runBtn = document.getElementById(`${prefix}_run_pricing`);
                const modelSelect = document.getElementById(`${node.id}-model-select`);
                if (modelSelect) {
                    modelSelect.addEventListener('change', () => {
                        saveModelSelection(node.id, modelSelect.value);
                    });
                }
                if (runBtn) {
                    runBtn.addEventListener('click', () => {
                        if (node.id === '1.1.1.2') {
                            const raw = {
                                t_days: document.getElementById(`${prefix}_t`).value,
                                n_days: document.getElementById(`${prefix}_n`).value,
                                t_bid: document.getElementById(`${prefix}_tbid`).value,
                                t_ask: document.getElementById(`${prefix}_task`).value,
                                n_bid: document.getElementById(`${prefix}_nbid`).value,
                                n_ask: document.getElementById(`${prefix}_nask`).value
                            };
                            const res = PricingPipeline.run({ instrumentId: node.id, modelId: 'fra-pricing', rawInputs: raw });
                            renderPricingResult(prefix, res, true);
                            updateSteps(node.id, res);
                            updateHealth(prefix, res, raw, 'fra-pricing');
                            scenarioState.last[node.id] = { inputs: raw, outputs: res.outputs, model: 'fra-pricing', instrument: leafInfo?.label || node.label };
                            refreshScenarioTable(node.id);
                        } else {
                            const selectedModelId = modelSelect ? modelSelect.value : (leafInfo.engineType || 'bsm');
                            const raw = {
                                S: document.getElementById(`${prefix}_S`).value,
                                K: document.getElementById(`${prefix}_K`).value,
                                T: document.getElementById(`${prefix}_T`).value,
                                r: document.getElementById(`${prefix}_r`).value,
                                sigma: document.getElementById(`${prefix}_sigma`).value,
                                q: document.getElementById(`${prefix}_q`).value,
                                optionType: 'call'
                            };
                            const res = PricingPipeline.run({ instrumentId: node.id, modelId: selectedModelId, rawInputs: raw });
                            renderPricingResult(prefix, res, false);
                            renderShocks(prefix, node.id, { ...leafInfo, engineType: selectedModelId }, raw);
                            updateSteps(node.id, res);
                            updateHealth(prefix, res, raw, selectedModelId);
                            scenarioState.last[node.id] = { inputs: raw, outputs: res.outputs, model: selectedModelId, instrument: leafInfo?.label || node.label };
                            refreshScenarioTable(node.id);
                        }
                    });
                }

                const simBtn = document.getElementById(`${prefix}_run_sim`);
                if (simBtn) {
                    simBtn.addEventListener('click', () => {
                        const raw = {
                            N: document.getElementById(`${prefix}_N`).value,
                            d: document.getElementById(`${prefix}_d`).value,
                            K: document.getElementById(`${prefix}_K`).value,
                            R: document.getElementById(`${prefix}_R`).value
                        };
                        const res = PricingPipeline.run({ instrumentId: node.id, modelId: 'fra-sim', rawInputs: raw });
                        const out = document.getElementById(`${prefix}_sim_out`);
                        if (res.status === 'error') {
                            out.innerHTML = `<div class="alert alert-danger">${res.errors.join('<br>')}</div>`;
                        } else {
                            out.innerHTML = `
                                <div><strong>${res.outputs.direction}</strong></div>
                                <table class="data-table" style="margin-top:8px;">
                                    <thead><tr><th>K (FRA %)</th><th>R (Mkt %)</th><th>τ</th><th>DF</th><th>Liquidación</th></tr></thead>
                                    <tbody><tr>
                                        <td class="numeric">${res.outputs.K.toFixed(4)}%</td>
                                        <td class="numeric">${res.outputs.R.toFixed(4)}%</td>
                                        <td class="numeric">${res.outputs.tau.toFixed(6)}</td>
                                        <td class="numeric">${res.outputs.df.toFixed(6)}</td>
                                        <td class="numeric">${res.outputs.settlement.toFixed(2)} EUR</td>
                                    </tr></tbody>
                            </table>`;
                        }
                        const traceEl = document.getElementById(`${prefix}_trace`);
                        if (traceEl) traceEl.innerHTML = res.trace.map(t => `• ${t.title}: ${t.detail}`).join('\n');
                        if (res.status === 'ok') {
                            scenarioState.last[node.id] = { inputs: raw, outputs: res.outputs, model: 'fra-sim', instrument: leafInfo?.label || node.label };
                            refreshScenarioTable(node.id);
                        }
                    });
                }
            }

            function renderPricingResult(prefix, res, isFRA) {
                const out = document.getElementById(`${prefix}_pricing_out`);
                const traceEl = document.getElementById(`${prefix}_trace`);
                if (!out) return;
                if (res.status === 'error') {
                    out.innerHTML = `<div class="alert alert-danger">${res.errors.join('<br>')}</div>`;
                } else if (isFRA) {
                    out.innerHTML = `<div style="display:flex;gap:12px;"><div><div class="muted">FRA BID</div><div style="font-size:24px;">${res.outputs.buyer.toFixed(4)}%</div></div><div><div class="muted">FRA ASK</div><div style="font-size:24px;">${res.outputs.seller.toFixed(4)}%</div></div></div>`;
                } else {
                    out.innerHTML = `
                        <div style="font-size:28px;font-weight:700;">${res.outputs.price?.toFixed ? res.outputs.price.toFixed(4) : res.outputs.price}</div>
                        <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;margin-top:6px;">
                            <div>Δ ${res.outputs.greeks?.delta?.toFixed ? res.outputs.greeks.delta.toFixed(4) : 'N/A'}</div>
                            <div>Γ ${res.outputs.greeks?.gamma?.toFixed ? res.outputs.greeks.gamma.toFixed(4) : 'N/A'}</div>
                            <div>Θ ${res.outputs.greeks?.theta?.toFixed ? res.outputs.greeks.theta.toFixed(4) : 'N/A'}</div>
                            <div>V ${res.outputs.greeks?.vega?.toFixed ? res.outputs.greeks.vega.toFixed(4) : 'N/A'}</div>
                            <div>ρ ${res.outputs.greeks?.rho?.toFixed ? res.outputs.greeks.rho.toFixed(4) : 'N/A'}</div>
                        </div>`;
                }
                if (traceEl) traceEl.innerHTML = res.trace.map(t => `• ${t.title}: ${t.detail}`).join('\n');
                // Store last result for Scenario Lab
                if (res.status === 'ok') {
                    scenarioState.last[prefix] = res;
                }
            }

            function updateSteps(leafId, res) {
                const steps = document.getElementById(`${leafId}-steps`);
                if (!steps) return;
                if (res.status !== 'ok') {
                    steps.textContent = res.errors ? res.errors.join('\n') : 'Sin pasos';
                    return;
                }
                const lines = [];
                lines.push('Inputs:');
                Object.keys(res.normalized || {}).forEach(k => lines.push(`  ${k}: ${res.normalized[k]}`));
                lines.push('Trace:');
                (res.trace || []).forEach(t => lines.push(`  - ${t.title}: ${t.detail}`));
                lines.push('Resultado: ' + (res.outputs?.price ?? 'N/A'));
                steps.textContent = lines.join('\n');
            }

            function updateHealth(prefix, res, rawInputs, modelId) {
                const el = document.getElementById(`${prefix}_health`);
                if (!el) return;
                if (!rawInputs) { el.textContent = 'Sin cálculos aún'; return; }
                const issues = [];
                const add = (msg) => issues.push(msg);
                const vals = Object.values(rawInputs).map(v => parseFloat(v));
                if (vals.some(v => !isFinite(v))) add('Inputs incompletos o inválidos');
                if (rawInputs.sigma !== undefined && parseFloat(rawInputs.sigma) > 300) add('Volatilidad >300%');
                if (rawInputs.T !== undefined && parseFloat(rawInputs.T) <= 0) add('T debe ser >0');
                if (rawInputs.K !== undefined && parseFloat(rawInputs.K) <= 0) add('K debe ser >0');
                if (res.status === 'error') add(res.errors?.join('; ') || 'Error de cálculo');
                if (!issues.length && res.outputs && !isNaN(res.outputs.price)) {
                    el.innerHTML = '<span style="color:var(--success)">OK</span>';
                } else {
                    el.innerHTML = issues.map(i => `<div style="color:var(--warning)">${i}</div>`).join('');
                }
            }

            function renderShocks(prefix, instrumentId, leafInfo, rawInputs) {
                const target = document.getElementById(`${prefix}_scenarios`);
                if (!target) return;
                const modelId = (leafInfo && leafInfo.engineType) ? leafInfo.engineType : 'bsm';
                const shockRes = ShockEngine.run({ instrumentId, modelId, rawInputs });
                if (!shockRes.scenarios.length || shockRes.base.status !== 'ok') {
                    target.innerHTML = `<div class="alert alert-warning">Escenarios no disponibles</div>`;
                    return;
                }
                const rows = shockRes.scenarios.map(s => `<tr><td>${s.label}</td><td class="numeric">${s.price?.toFixed ? s.price.toFixed(4) : 'N/A'}</td><td class="numeric">${s.delta?.toFixed ? s.delta.toFixed(4) : 'N/A'}</td></tr>`).join('');
                target.innerHTML = `<table class="data-table"><thead><tr><th>Escenario</th><th>PV</th><th>ΔPV vs base</th></tr></thead><tbody>${rows}</tbody></table>
                <button class="btn btn-ghost btn-sm" onclick="exportTableAsCSV('${prefix}_scenarios','escenarios.csv')">Export CSV</button>`;
            }

            // ---------- Tests & Audit ----------
            function runDiagnostics() {
                const results = [];
                const parity = PricingPipeline.run({ instrumentId: '2.1.1.1', modelId: 'bsm', rawInputs: { S: 100, K: 100, T: 0.25, r: 5, sigma: 20, q: 0 } });
                const call = PricingPipeline.run({ instrumentId: '2.1.1.1', modelId: 'bsm', rawInputs: { S: 100, K: 100, T: 0.25, r: 5, sigma: 20, q: 0 } });
                const put = PricingPipeline.run({ instrumentId: '2.1.3.1', modelId: 'bsm', rawInputs: { S: 100, K: 100, T: 0.25, r: 5, sigma: 20, q: 0, optionType: 'put' } });
                const pcCheck = (call.outputs.price - put.outputs.price - (100 - 100 * Math.exp(-0.05 * 0.25)));
                results.push({ name: 'Put-Call Parity', expected: '≈0', actual: pcCheck.toFixed(6), pass: Math.abs(pcCheck) < 1e-3 });

                const sigmaZero = PricingPipeline.run({ instrumentId: '2.1.1.1', modelId: 'bsm', rawInputs: { S: 100, K: 100, T: 0.25, r: 5, sigma: 0, q: 0 } });
                results.push({ name: 'Validación σ<=0', expected: 'Error', actual: sigmaZero.status, pass: sigmaZero.status === 'error' });

                const tZero = PricingPipeline.run({ instrumentId: '2.1.1.1', modelId: 'bsm', rawInputs: { S: 110, K: 100, T: 0, r: 5, sigma: 20, q: 0 } });
                results.push({ name: 'BSM T=0 intrinsic', expected: '10.0000', actual: tZero.outputs.price?.toFixed ? tZero.outputs.price.toFixed(4) : 'NaN', pass: Math.abs(tZero.outputs.price - 10) < 1e-4 });

                const fraBad = PricingPipeline.run({ instrumentId: '1.1.1.2', modelId: 'fra-pricing', rawInputs: { t_days: 180, n_days: 90, t_bid: 3, t_ask: 3, n_bid: 4, n_ask: 4 } });
                results.push({ name: 'FRA t>=n', expected: 'Error', actual: fraBad.status, pass: fraBad.status === 'error' });

                const shocks = ShockEngine.run({ instrumentId: '2.1.1.1', modelId: 'bsm', rawInputs: { S: 100, K: 100, T: 0.5, r: 5, sigma: 20, q: 0 } });
                results.push({ name: 'ShockEngine escenarios', expected: '≥1 escenario', actual: shocks.scenarios.length, pass: shocks.scenarios.length > 0 });

                const bin = PricingPipeline.run({ instrumentId: '2.1.1.1', modelId: 'binomial', rawInputs: { S: 100, K: 100, T: 0.5, r: 5, sigma: 20, q: 0, steps: 150 } });
                const ref = call.outputs.price;
                results.push({ name: 'Binomial ~ BSM', expected: 'Cercano', actual: bin.outputs.price?.toFixed ? bin.outputs.price.toFixed(4) : 'NaN', pass: Math.abs(bin.outputs.price - ref) < 0.05 });

                // Tab Controller test
                const btnA = document.createElement('button'); btnA.dataset.tab = 'a';
                const btnB = document.createElement('button'); btnB.dataset.tab = 'b';
                const panelA = document.createElement('div'); panelA.dataset.panel = 'a';
                const panelB = document.createElement('div'); panelB.dataset.panel = 'b';
                const tc = new TabController({ buttons: [btnA, btnB], panels: [panelA, panelB] });
                tc.activate('b');
                results.push({ name: 'TabController activa panel', expected: 'panel b visible', actual: !panelB.classList.contains('hidden'), pass: !panelB.classList.contains('hidden') });

                return results;
            }

            function renderAuditPage() {
                const page = document.getElementById('page-audit');
                if (!page) return;
                const results = runDiagnostics();
                const pass = results.filter(r => r.pass).length;
                const pendingAssets = ['PENDIENTE_DE_FUENTES: asset de alta resolución para fondos/hero (reemplazo en espera)'];
                const pendingList = collectAllPendings();
                const pendingGlobal = pendingList.length + pendingAssets.length;
                const rows = results.map(r => `<tr><td>${r.name}</td><td>${r.expected}</td><td>${r.actual}</td><td style="text-align:center;"><span class="${r.pass ? 'test-pass' : 'test-fail'}">${r.pass ? '✓' : '✗'}</span></td></tr>`).join('');
                const pendingRows = pendingList.map(p => `<tr><td>${p.id}</td><td>${p.key}</td><td>${p.excerpt}</td></tr>`).join('') + pendingAssets.map(a => `<tr><td>asset</td><td>imagen</td><td>${a}</td></tr>`).join('');
                page.innerHTML = `
                    <div class="page-header"><div class="page-breadcrumb">QA</div><h1 class="page-title">Panel de Tests</h1></div>
                    <div class="kpi-grid">
                        <div class="kpi ${pass === results.length ? 'kpi-success' : 'kpi-warning'}"><div class="kpi-value">${pass}/${results.length}</div><div class="kpi-label">Tests OK</div></div>
                        <div class="kpi kpi-warning"><div class="kpi-value">${pendingGlobal}</div><div class="kpi-label">Pendiente de fuentes</div></div>
                    </div>
                    <div class="card"><div class="card-header">🧪 Tests</div><div class="card-body"><table class="data-table"><thead><tr><th>Test</th><th>Esperado</th><th>Actual</th><th>Estado</th></tr></thead><tbody>${rows}</tbody></table></div></div>
                    <div class="card"><div class="card-header">Pendiente de fuentes</div><div class="card-body"><table class="data-table"><thead><tr><th>Instrumento</th><th>Sección</th><th>Detalle</th></tr></thead><tbody>${pendingRows}</tbody></table></div></div>`;
            }

            // ---------- Render wiring ----------
            window.renderTaxonomyPage = renderTaxonomyPage;
            window.renderAuditPage = renderAuditPage;
            window.renderMarketPage = renderMarketPage;
            window.runDiagnostics = runDiagnostics;
            window.renderTree = renderTree;
            const originalRender = window.render || (() => { });
            function render() {
                const sidebar = document.getElementById('sidebarContent');
                if (sidebar) { sidebar.innerHTML = ''; renderTree(taxonomyData, sidebar); }
                if (state.page === 'taxonomy') renderTaxonomyPage();
                else if (state.page === 'market') renderMarketPage();
                else if (state.page === 'analytics') renderAnalyticsPage();
                else if (state.page === 'audit') renderAuditPage();
            }
            window.render = render;

            function downloadSnapshot() {
                const blob = new Blob([document.documentElement.outerHTML], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'derivatives_workbench_snapshot.html';
                a.click();
                setTimeout(() => URL.revokeObjectURL(url), 500);
            }

            function exportTableAsCSV(containerId, filename) {
                const container = document.getElementById(containerId);
                if (!container) return;
                const table = container.querySelector('table') || container;
                let csv = '';
                table.querySelectorAll('tr').forEach(tr => {
                    const cells = Array.from(tr.querySelectorAll('th,td')).map(td => `"${(td.textContent || '').trim()}"`);
                    csv += cells.join(',') + '\n';
                });
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename || 'export.csv';
                a.click();
                setTimeout(() => URL.revokeObjectURL(url), 300);
            }

            // Run once DOM is ready
            document.addEventListener('DOMContentLoaded', () => {
                render();
            });
        })();
    </script>
</body>

</html>
